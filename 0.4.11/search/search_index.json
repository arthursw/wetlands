{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Overview","text":""},{"location":"#wetlands","title":"Wetlands","text":"<p>Wetlands is a lightweight Python library for managing Conda environments.</p> <p>Wetlands can create Conda environments on demand, install dependencies, and execute arbitrary code within them. This makes it easy to build plugin systems or integrate external modules into an application without dependency conflicts, as each environment remains isolated.</p> <p>The name Wetlands comes from the tropical environments where anacondas thrive.</p> <p>Documentation: https://arthursw.github.io/wetlands/latest/</p> <p>Source Code: https://github.com/arthursw/wetlands/</p>"},{"location":"#features","title":"\u2728 Features","text":"<ul> <li>Automatic Environment Management: Create and configure environments on demand.</li> <li>Dependency Isolation: Install dependencies without conflicts.</li> <li>Embedded Execution: Run Python functions inside isolated environments.</li> <li>Pixi &amp; Micromamba: Wetlands uses either a self-contained <code>pixi</code> or <code>micromamba</code> for fast and lightweight Conda environment handling.</li> </ul>"},{"location":"#installation","title":"\ud83d\udce6 Installation","text":"<p>To install Wetlands, simply run:</p> <pre><code>pip install wetlands\n</code></pre>"},{"location":"#usage","title":"\ud83d\ude80 Usage","text":""},{"location":"#minimal-example","title":"Minimal example","text":"<p>Here is a minimal example usage:</p> <pre><code>from wetlands.environment_manager import EnvironmentManager\n\n# Initialize the environment manager\nenvironment_manager = EnvironmentManager(\"pixi/\")\n\n# Create and launch a Conda environment named \"numpy_env\"\nenv = environment_manager.create(\"numpy_env\", {\"pip\": [\"numpy==2.2.4\"]})\nenv.launch()\n\n# Import minimal_module in the environment (see minimal_module.py below)\nminimal_module = env.import_module(\"minimal_module.py\")\n# minimal_module is a proxy to minimal_module.py in the environment\narray = [1, 2, 3]\n# Execute the sum() function in the numpy_env environment and get the result\nresult = minimal_module.sum(array)\n\nprint(f\"Sum of {array} is {result}.\")\n\n# Clean up and exit the environment\nenv.exit()\n</code></pre> <p>With <code>minimal_module.py</code>:</p> <pre><code>def sum(x):\n    import numpy as np  # type: ignore\n    return int(np.sum(x))\n</code></pre>"},{"location":"#general-usage","title":"General usage","text":"<p>Wetlands allows you to interact with isolated Conda environments in two main ways:</p> <ol> <li>Simplified Execution (<code>env.import_module</code> / <code>env.execute</code>): Wetlands manages the communication details, providing a proxy object to call functions within the environment seamlessly. See Getting started.</li> <li>Manual Control (<code>env.execute_commands</code>): You run specific commands (like starting a Python script that listens for connections) and manage the inter-process communication yourself. See Advanced example.</li> </ol> <p>You can run those examples form the <code>examples/</code> folder in the repository.</p> <p>Explore the inner workings on the How it Works page.</p>"},{"location":"#license","title":"\ud83d\udcdc License","text":"<p>This project was made at Inria in Rennes (Centre Inria de l'Universit\u00e9 de Rennes) and is licensed under the MIT License.</p> <p>The logo Wetland was made by Dan Hetteix from Noun Project (CC BY 3.0).</p>"},{"location":"advanced_example/","title":"Advanced example","text":""},{"location":"advanced_example/#manual-communication-with-envexecute_commands","title":"Manual Communication with <code>env.execute_commands</code>","text":"<p>This example shows how to use Wetlands to run a specific script within the environment and manage the communication manually using Python's <code>multiprocessing.connection</code>. This gives you full control over the interaction protocol but requires more setup.</p> <p>Let's see the main script <code>advanced_example.py</code> step by step. </p>"},{"location":"advanced_example/#initialize-wetlands-and-logging","title":"Initialize Wetlands and Logging","text":"<p>We import necessary modules, including <code>Client</code> for manual connection and standard Python libraries like <code>subprocess</code>, <code>threading</code>, and <code>logging</code>. We also enable debug logging for Wetlands to see more internal details and initialize the <code>EnvironmentManager</code>.</p> <pre><code># main_script_manual.py\nfrom multiprocessing.connection import Client\nimport subprocess\nimport sys\nimport threading\nimport logging\nfrom pathlib import Path\nimport time\n\nfrom wetlands.environment_manager import EnvironmentManager\nfrom wetlands import logger\n\n_base = logging.getLogger(\"wetlands\")\n_base.setLevel(logging.DEBUG)\n\nenvironment_manager = EnvironmentManager(\"micromamba/\", False)\n</code></pre>"},{"location":"advanced_example/#create-the-environment","title":"Create the Environment","text":"<p>Similar to the first example, we create the environment (<code>advanced_cellpose_env</code>) and specify its dependencies.</p> <pre><code>deps = {\"conda\": [\"cellpose==3.1.0\"]}\nenv = environment_manager.create(\"advanced_cellpose_env\", deps)\n</code></pre>"},{"location":"advanced_example/#execute-a-custom-script-in-the-environment","title":"Execute a Custom Script in the Environment","text":"<p>Instead of <code>env.launch()</code>, we use <code>env.execute_commands()</code>. This method allows us to run arbitrary shell commands within the activated environment. Here, we execute a specific Python script (<code>advanced_example_module.py</code>) using <code>python -u</code> (unbuffered output, important for reading stdout line-by-line immediately). We capture the <code>Popen</code> object for the launched process. We also redirect stderr to stdout for easier log capture.</p> <pre><code>print(\"Executing advanced_example_module.py in environment...\")\nprocess = env.execute_commands([\"python -u advanced_example_module.py\"])\n</code></pre> <p>Windows users</p> <p>The <code>python</code> command will be available since it will be run in the conda environment.</p>"},{"location":"advanced_example/#establish-manual-connection","title":"Establish Manual Connection","text":"<p>The script we just launched (<code>advanced_example_module.py</code>) is designed to start a server and print the port it's listening on to its standard output. Our main script now needs to read the <code>stdout</code> of the <code>process</code> launched by Wetlands to discover this port number. We loop through the output lines until we find the line indicating the port.</p> <pre><code>port = None\nif process.stdout is None:\n    print(\"Process has no stdout stream.\", file=sys.stderr)\n    sys.exit(1)\nprint(\"Waiting for environment process to report listening port...\")\nfor line in process.stdout:\n    if line.strip().startswith(\"Listening port \"):\n        port = int(line.strip().replace(\"Listening port \", \"\"))\n        break\n\nprint(f\"Connecting to localhost:{port}...\")\nconnection = Client((\"localhost\", port))\n</code></pre>"},{"location":"advanced_example/#log-environment-output-optional","title":"Log Environment Output (Optional)","text":"<p>To see ongoing output from the script running in the environment, we can start a background thread that continuously reads and prints lines from the process's stdout.</p> <pre><code>def log_output(proc: subprocess.Popen):\n    if proc.stdout:\n        for line_bytes in iter(proc.stdout.readline, b''):\n            print(f\"[Env Output]: {line_bytes.decode().strip()}\")\n\noutput_thread = threading.Thread(target=log_output, args=(process,), daemon=True)\noutput_thread.start()\n</code></pre>"},{"location":"advanced_example/#send-commands-and-receive-results-manually","title":"Send Commands and Receive Results Manually","text":"<p>Now that we have a direct <code>connection</code> object (from <code>multiprocessing.connection.Client</code>), we can implement our own communication protocol. We send dictionaries containing an <code>action</code>, <code>function</code> name, and <code>args</code>. We then wait (<code>connection.recv()</code>) for a response dictionary from the server script running in the environment.</p> <pre><code>image_path = \"cellpose_img02.png\"\n\nprint(f\"Sending command: download image {image_path}\")\nconnection.send(dict(action=\"execute\", function=\"download_image\", args=[image_path]))\nresult = connection.recv()\nprint(f\"Received response: {result}\")\n\nsegmentation_path = \"cellpose_img02_segmentation.png\"\nprint(f\"Sending command: segment image {image_path}\")\nargs = [str(image_path), str(segmentation_path)]\nconnection.send(dict(action=\"execute\", function=\"segment_image\", args=args))\nresult = connection.recv()\nprint(f\"Received response: {result}\")\nif 'diameters' in result:\n    print(f\"Object diameters: {result['diameters']}\")\n</code></pre>"},{"location":"advanced_example/#tell-the-environment-process-to-exit-and-clean-up","title":"Tell the Environment Process to Exit and clean up","text":"<p>We send a custom 'exit' message according to our protocol. The server script is designed to shut down upon receiving this message.</p> <pre><code>print(\"Sending exit command...\")\nconnection.send(dict(action=\"exit\"))\n</code></pre> <p>We close our client-side connection and wait for the process we launched with <code>execute_commands</code> to terminate.</p> <pre><code>connection.close()\nprocess.wait(timeout=10)\nif process.returncode is None:\n    process.kill()\n</code></pre> <p>Now, let's examine the <code>advanced_example_module.py</code> script, which is executed by Wetlands in the isolated environment via <code>execute_commands</code>.</p> <p>Define Callable Functions</p> <p>This script defines the functions (<code>download_image</code>, <code>segment_image</code>) that the main script will invoke remotely. These functions perform the actual work (downloading, segmenting using <code>example_module</code>) inside the environment and use the provided <code>connection</code> object to send back results or status messages.</p> <pre><code># advanced_example_module.py\nimport sys\nimport urllib.request\nfrom multiprocessing.connection import Listener\nfrom pathlib import Path\nimport example_module # Reuse logic from the simple example module\n\ndef download_image(image_path_str, connection):\n    \"\"\"Downloads the image *inside* the environment.\"\"\"\n    image_path = Path(image_path_str)\n    image_url = \"https://www.cellpose.org/static/images/img02.png\"\n    print(f\"[Inside Env] Downloading image to {image_path}...\")\n    try:\n        with urllib.request.urlopen(image_url) as response:\n            image_data = response.read()\n        with open(image_path, \"wb\") as handler:\n            handler.write(image_data)\n        print(\"[Inside Env] Image downloaded.\")\n        connection.send(dict(status=\"success\", message=\"Image downloaded.\"))\n    except Exception as e:\n        print(f\"[Inside Env] Error downloading image: {e}\")\n        connection.send(dict(status=\"error\", message=str(e)))\n\ndef segment_image(image_path_str, segmentation_path_str, connection):\n    \"\"\"Runs segmentation *inside* the environment.\"\"\"\n    image_path = Path(image_path_str)\n    segmentation_path = Path(segmentation_path_str)\n    print(f\"[Inside Env] Segmenting {image_path}...\")\n    try:\n        diameters = example_module.segment(image_path, segmentation_path)\n        print(\"[Inside Env] Segmentation complete.\")\n        connection.send(dict(status=\"success\", message=\"Image segmented.\", diameters=diameters))\n    except Exception as e:\n        print(f\"[Inside Env] Error during segmentation: {e}\")\n        connection.send(dict(status=\"error\", message=str(e)))\n</code></pre> <p>Set Up the Server</p> <p>The main part of the script uses <code>multiprocessing.connection.Listener</code> to create a server socket listening on <code>localhost</code> and an OS-assigned port (<code>0</code>). Crucially, it prints the chosen port number to standard output, which is how the main script discovers where to connect. It then waits for the main script to connect (<code>listener.accept()</code>).</p> <pre><code>with Listener((\"localhost\", 0)) as listener:\n    # Print the port for the main process to read\n    print(f\"Listening port {listener.address[1]}\", flush=True)\n    with listener.accept() as connection:\n</code></pre> <p>Process Incoming Messages</p> <p>Once connected, the script enters a loop, waiting to receive messages (<code>connection.recv()</code>). It parses the received dictionary, checks the <code>action</code>, and calls the corresponding local function (<code>download_image</code> or <code>segment_image</code>) if the action is <code>execute</code>. If the action is <code>exit</code>, it sends a confirmation and terminates the script (<code>sys.exit(0)</code>).</p> <pre><code>        while message := connection.recv():\n            if message[\"action\"] == \"execute\":\n                locals()[message[\"function\"]](*(message[\"args\"] + [connection]))\n            if message[\"action\"] == \"exit\":\n                connection.send(dict(action=\"Exited.\"))\n                sys.exit(0)\n</code></pre> <p>Summary of Example 2 Flow:</p> <p>The main script uses <code>EnvironmentManager</code> to create an environment. <code>env.execute_commands()</code> starts a custom server script (<code>advanced_example_module.py</code>) inside the environment. The main script reads the server's port from stdout and connects manually using <code>Client</code>. Communication happens via custom message dictionaries sent over this connection. The main script explicitly tells the server to exit before cleaning up the process started by <code>execute_commands</code>. This approach offers more control but requires implementing the server logic and communication protocol.</p>"},{"location":"debugging/","title":"Debugging Wetlands Environments","text":"<p>Wetlands provides built-in debugging tools that allow you to attach a debugger to an isolated environment and step through code execution in real-time. This is essential for development and troubleshooting when running code in isolated Conda environments.</p>"},{"location":"debugging/#overview","title":"Overview","text":"<p>The debugging system includes:</p> <ul> <li>IDE Integration: Support for VS Code and PyCharm</li> <li>Remote Debugging: Attach to running environment processes</li> <li>Environment Management: List and kill running environments</li> <li>Port Allocation: Automatic debug port assignment for each environment</li> </ul>"},{"location":"debugging/#installation","title":"Installation","text":"<p>The debugging tools are part of the Wetlands package and are automatically installed with:</p> <pre><code>pip install wetlands\n</code></pre>"},{"location":"debugging/#usage-commands","title":"Usage Commands","text":""},{"location":"debugging/#1-wetlands-list-view-running-environments","title":"1. <code>wetlands list</code> - View Running Environments","text":"<p>List all currently running Wetlands environments and their debug ports.</p> <pre><code>wetlands list [-wip PATH]\n</code></pre> <p>Arguments:</p> <ul> <li><code>-wip, --wetlands_instance_path PATH</code> (optional): Path to the Wetlands instance folder (default: <code>wetlands</code>)</li> </ul> <p>Example:</p> <pre><code>$ wetlands list\nRunning wetlands environments (for all wetlands instance):\n\nCommand line | Process ID | Parent process ID\n---\npython /path/to/wetlands/module_executor.py env1 --wetlands_instance_path path/to/wetlands | 12345 | 12340\npython /path/to/wetlands/module_executor.py env2 --wetlands_instance_path path/to/wetlands | 12346 | 12340\n\nEnvironments of the wetlands instance path/to/wetlands:\n\nEnvironment | Debug Port | Path\n---\nenv1 | 5678 | /path/to/module_executor.py\nenv2 | 5679 | /path/to/module_executor.py\n</code></pre> <p>This command displays:</p> <ul> <li>Running processes: All active Wetlands environment processes with their PIDs</li> <li>Available debug ports: The port number assigned to each environment for debugging</li> <li>Module executor paths: Where the module executor is located for each environment</li> </ul>"},{"location":"debugging/#2-wetlands-debug-attach-debugger-to-an-environment","title":"2. <code>wetlands debug</code> - Attach Debugger to an Environment","text":"<p>Attach VS Code or PyCharm to a running Wetlands environment for debugging.</p> <pre><code>wetlands debug -s SOURCE_PATH -n ENV_NAME [-ide {vscode,pycharm}] [-wip PATH] [-jmc]\n</code></pre> <p>Arguments:</p> <ul> <li><code>-s, --sources SOURCE_PATH</code> (required): Path to the source code directory you want to debug</li> <li><code>-n, --name ENV_NAME</code> (required): Name of the environment to debug</li> <li><code>-ide, --ide {vscode,pycharm}</code> (optional): IDE to use (default: <code>vscode</code>)</li> <li><code>-wip, --wetlands_instance_path PATH</code> (optional): Path to the Wetlands instance folder (default: <code>pixi/wetlands</code>)</li> <li><code>-jmc, --just_my_code</code> (optional, VS Code only): Only debug your source files, not library code</li> </ul> <p>Example - VS Code:</p> <pre><code>wetlands debug -s /path/to/my/project -n my_env\n</code></pre> <p>Example - PyCharm:</p> <pre><code>wetlands debug -s /path/to/my/project -n my_env -ide pycharm\n</code></pre> <p>Example - VS Code with Just My Code:</p> <pre><code>wetlands debug -s /path/to/my/project -n my_env -jmc\n</code></pre>"},{"location":"debugging/#what-happens-when-you-run-wetlands-debug","title":"What Happens When You Run <code>wetlands debug</code>","text":"<ol> <li>Configuration Detection: Wetlands searches for running processes matching the environment name</li> <li>Port Discovery: The debug port for the environment is read from <code>debug_ports.json</code> in the Wetlands instance directory</li> <li>IDE Configuration:</li> <li>VS Code: Creates/updates <code>.vscode/launch.json</code> with remote attach configuration</li> <li>PyCharm: Creates <code>.idea/runConfigurations/Remote_Attach_Wetlands.xml</code> with remote debugging configuration</li> <li>IDE Launch: Opens the specified IDE with the source directory</li> <li>Debugger Connection: The IDE connects to the remote debugger running in the isolated environment</li> </ol>"},{"location":"debugging/#3-wetlands-kill-stop-an-environment","title":"3. <code>wetlands kill</code> - Stop an Environment","text":"<p>Terminate a running Wetlands environment and all its child processes.</p> <pre><code>wetlands kill -n ENV_NAME [-wip PATH]\n</code></pre> <p>Arguments:</p> <ul> <li><code>-n, --name ENV_NAME</code> (required): Name of the environment to kill</li> <li><code>-wip, --wetlands_instance_path PATH</code> (optional): Path to the Wetlands instance folder (default: <code>pixi/wetlands</code>)</li> </ul> <p>Example:</p> <pre><code>wetlands kill -n my_env\n</code></pre>"},{"location":"debugging/#debugging-with-vs-code","title":"Debugging with VS Code","text":""},{"location":"debugging/#setup-and-debugging","title":"Setup and Debugging","text":"<ol> <li>Start your Wetlands environment in your Python script:</li> </ol> <pre><code>from wetlands.environment_manager import EnvironmentManager\n\nenv_manager = EnvironmentManager()\nenv = env_manager.create(\"my_env\", {\"pip\": [\"numpy\", \"pandas\"]})\nenv.launch()\n\n# Your code here\n</code></pre> <ol> <li>List available environments to verify it's running:</li> </ol> <pre><code>wetlands list\n</code></pre> <ol> <li>Attach the debugger with VS Code:</li> </ol> <pre><code>wetlands debug -s /path/to/my/project -n my_env\n</code></pre> <ol> <li> <p>Set breakpoints in VS Code and interact with your environment code</p> </li> <li> <p>Stop debugging when finished:</p> </li> </ol> <pre><code>wetlands kill -n my_env\n</code></pre>"},{"location":"debugging/#configuration-details","title":"Configuration Details","text":"<p>The <code>launch.json</code> file created by Wetlands for VS Code contains:</p> <pre><code>{\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n    {\n      \"name\": \"Python Debugger: Remote Attach Wetlands\",\n      \"type\": \"debugpy\",\n      \"request\": \"attach\",\n      \"just_my_code\": false,\n      \"connect\": {\n        \"host\": \"localhost\",\n        \"port\": 5678\n      },\n      \"pathMappings\": [\n        {\n          \"localRoot\": \"/path/to/module/executor\",\n          \"remoteRoot\": \"/path/to/module/executor\"\n        }\n      ]\n    }\n  ]\n}\n</code></pre> <ul> <li>type: Uses <code>debugpy</code> for Python debugging</li> <li>connect: Specifies <code>localhost</code> and the assigned debug port</li> <li>just_my_code: Set to <code>true</code> if you used the <code>-jmc</code> flag</li> <li>pathMappings: Maps local source paths to remote paths in the environment</li> </ul>"},{"location":"debugging/#debugging-with-pycharm","title":"Debugging with PyCharm","text":""},{"location":"debugging/#setup-and-debugging_1","title":"Setup and Debugging","text":"<ol> <li> <p>Start your Wetlands environment in your Python script (same as VS Code)</p> </li> <li> <p>Attach the debugger with PyCharm:</p> </li> </ol> <pre><code>wetlands debug -s /path/to/my/project -n my_env -ide pycharm\n</code></pre> <ol> <li>Select the run configuration in PyCharm:</li> <li>Look for \"Remote_Attach_Wetlands\" in the run configurations dropdown</li> <li> <p>Click the Debug button</p> </li> <li> <p>Set breakpoints in PyCharm and interact with your environment code</p> </li> <li> <p>Stop debugging when finished:</p> </li> </ol> <pre><code>wetlands kill -n my_env\n</code></pre>"},{"location":"debugging/#configuration-details_1","title":"Configuration Details","text":"<p>The XML configuration file created in <code>.idea/runConfigurations/Remote_Attach_Wetlands.xml</code> contains:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;component name=\"ProjectRunConfigurationManager\"&gt;\n  &lt;configuration name=\"Remote Attach Wetlands\" type=\"Python\"\n                 factoryName=\"Python\" show_console_on_std_err=\"false\"\n                 show_console_on_std_out=\"false\"&gt;\n    &lt;module name=\"$PROJECT_NAME\" /&gt;\n    &lt;option name=\"PATH_MAPPINGS\"&gt;\n      &lt;list&gt;\n        &lt;item index=\"0\" itemvalue=\"/path/to/module/executor:/path/to/module/executor\" /&gt;\n      &lt;/list&gt;\n    &lt;/option&gt;\n  &lt;/configuration&gt;\n&lt;/component&gt;\n</code></pre> <ul> <li>Creates a Python remote debugging configuration</li> <li>Path mappings ensure source code paths are correctly resolved</li> </ul>"},{"location":"debugging/#workflow-example","title":"Workflow Example","text":"<p>Here's a complete workflow for debugging a Wetlands environment:</p>"},{"location":"debugging/#1-create-your-project-structure","title":"1. Create Your Project Structure","text":"<pre><code>my_project/\n\u251c\u2500\u2500 main.py              # Main script\n\u251c\u2500\u2500 module_to_debug.py   # Code to debug\n\u2514\u2500\u2500 requirements.txt     # Dependencies\n</code></pre>"},{"location":"debugging/#2-create-the-main-script","title":"2. Create the Main Script","text":"<pre><code># main.py\nfrom pathlib import Path\nfrom wetlands.environment_manager import EnvironmentManager\n\nenv_manager = EnvironmentManager(\"pixi/\")\nenv = env_manager.create(\n    \"my_debug_env\",\n    {\"pip\": [\"requests\", \"numpy\"]}\n)\nenv.launch()\n\n# Import module and call function\nmy_module = env.import_module(\"module_to_debug.py\")\nresult = my_module.process_data([1, 2, 3, 4, 5])\n\nprint(f\"Result: {result}\")\nenv.exit()\n</code></pre>"},{"location":"debugging/#3-create-the-module-to-debug","title":"3. Create the Module to Debug","text":"<pre><code># module_to_debug.py\nimport numpy as np\n\ndef process_data(data):\n    \"\"\"Process data with numpy\"\"\"\n    arr = np.array(data)\n    result = np.sum(arr) * 2\n    return int(result)  # Breakpoint here to inspect values\n</code></pre>"},{"location":"debugging/#4-start-your-application","title":"4. Start Your Application","text":"<pre><code>python main.py\n</code></pre>"},{"location":"debugging/#5-launch-the-environment","title":"5. Launch the Environment","text":"<p>Keep the main script running, and in another terminal:</p> <pre><code>wetlands list\n</code></pre> <p>You'll see <code>my_debug_env</code> listed.</p>"},{"location":"debugging/#6-attach-the-debugger","title":"6. Attach the Debugger","text":"<pre><code># For VS Code:\nwetlands debug -s /path/to/my_project -n my_debug_env\n\n# Or for PyCharm:\nwetlands debug -s /path/to/my_project -n my_debug_env -ide pycharm\n</code></pre>"},{"location":"debugging/#7-debug-your-code","title":"7. Debug Your Code","text":"<ul> <li>Set breakpoints in <code>module_to_debug.py</code></li> <li>Call functions from your main script</li> <li>Step through code and inspect variables</li> <li>VS Code/PyCharm will break at your breakpoints</li> </ul>"},{"location":"debugging/#8-clean-up","title":"8. Clean Up","text":"<p>When finished:</p> <pre><code>wetlands kill -n my_debug_env\n</code></pre>"},{"location":"debugging/#troubleshooting","title":"Troubleshooting","text":""},{"location":"debugging/#debug-ports-file-does-not-exist","title":"\"Debug ports file does not exist\"","text":"<p>Cause: The Wetlands instance hasn't created the <code>debug_ports.json</code> file yet.</p> <p>Solution: Make sure your environment has been launched with <code>env.launch()</code> before running the debug command.</p>"},{"location":"debugging/#debug-port-not-found-for-environment","title":"\"Debug port not found for environment\"","text":"<p>Cause: The environment name doesn't exist or is spelled incorrectly.</p> <p>Solution: - Verify the environment is running: <code>wetlands list</code> - Check the exact environment name - Make sure you're using the correct <code>-wip</code> path if you have multiple Wetlands instances</p>"},{"location":"debugging/#no-wetlands-process-with-environment-name-found","title":"\"No wetlands process with environment name found\"","text":"<p>Cause: The specified environment is not currently running.</p> <p>Solution: - Start your Python script that creates and launches the environment - Keep the script running while debugging - Verify with <code>wetlands list</code></p>"},{"location":"debugging/#debugger-doesnt-break-at-breakpoints","title":"Debugger doesn't break at breakpoints","text":"<p>Cause: The source code path mapping might be incorrect.</p> <p>Solution: - Ensure the source path you provide to <code>wetlands debug</code> matches your actual source code location - Check the path mappings in the generated configuration file - Verify that the line numbers haven't changed since you set the breakpoint</p>"},{"location":"debugging/#kill-environment-no-process-found","title":"\"Kill environment: no process found\"","text":"<p>Cause: The environment is not currently running.</p> <p>Solution: This is usually not a problem. Verify with <code>wetlands list</code> that the environment isn't running, and proceed.</p>"},{"location":"debugging/#advanced-usage","title":"Advanced Usage","text":""},{"location":"debugging/#debugging-multiple-environments","title":"Debugging Multiple Environments","text":"<p>You can debug multiple environments simultaneously by:</p> <ol> <li>Opening multiple IDE windows</li> <li>Using <code>wetlands debug</code> with different environment names</li> <li>Each environment gets its own debug port</li> </ol> <pre><code># Terminal 1\nwetlands debug -s /project1 -n env1\n\n# Terminal 2\nwetlands debug -s /project2 -n env2\n</code></pre>"},{"location":"debugging/#debugging-with-custom-wetlands-instances","title":"Debugging with Custom Wetlands Instances","text":"<p>If you have multiple Wetlands instances, specify the instance path:</p> <pre><code>wetlands debug -s /path/to/project -n my_env -wip /custom/wetlands/path\n</code></pre>"},{"location":"debugging/#vs-code-only-just-my-code-mode","title":"VS Code Only: Just My Code Mode","text":"<p>Debug only your code, skipping library internals:</p> <pre><code>wetlands debug -s /path/to/project -n my_env -jmc\n</code></pre> <p>This sets <code>just_my_code: true</code> in the VS Code launch configuration, which speeds up debugging by not stepping into library code.</p>"},{"location":"debugging/#how-it-works-under-the-hood","title":"How It Works Under the Hood","text":"<ol> <li>Process Detection: Wetlands uses <code>psutil</code> to find running processes matching your environment</li> <li>Port Assignment: Each environment gets a unique debug port from <code>debug_ports.json</code></li> <li>Debugpy Integration: The environment's module executor runs <code>debugpy</code> in socket mode</li> <li>IDE Configuration: Wetlands generates IDE-specific configuration files for remote attach</li> <li>Network Connection: Your IDE connects via localhost to the debug port in the isolated environment</li> </ol>"},{"location":"debugging/#see-also","title":"See Also","text":"<ul> <li>Getting Started - Basic Wetlands usage</li> <li>Advanced Example - More complex scenarios</li> <li>How It Works - Internal architecture</li> </ul>"},{"location":"dependencies/","title":"\ud83d\udce6 Dependency Specification Documentation","text":"<p>This document explains how to define dependencies using Wetlands' structured format. The schema supports specifying dependencies for different platforms, optional dependencies, and conditional dependencies via <code>conda</code> or <code>pip</code>.</p>"},{"location":"dependencies/#type-definitions","title":"\ud83d\udd27 Type Definitions","text":""},{"location":"dependencies/#platform","title":"Platform","text":"<p><pre><code>Platform = Literal[\"osx-64\", \"osx-arm64\", \"win-64\", \"win-arm64\", \"linux-64\", \"linux-arm64\"]\n</code></pre> Defines supported operating systems and architectures.</p>"},{"location":"dependencies/#dependency","title":"Dependency","text":"<pre><code>class Dependency(TypedDict):\n    name: str\n    platforms: NotRequired[list[Platform]]\n    optional: NotRequired[bool]\n    dependencies: NotRequired[bool]\n</code></pre> <p>Represents an individual dependency with additional metadata:</p> <ul> <li>name (str): The name of the package (e.g., <code>\"numpy\"</code>) with an optional channel specification (for conda specification) and a version specifier. Format: <code>channel::package==version.number</code>. Supports PEP 440 version specifiers like <code>&gt;=1.20,&lt;2.0</code>, <code>~=1.5.0</code>, <code>!=1.0.0</code>, etc.</li> <li>platforms (optional): A list of platforms on which this package should be installed.</li> <li>optional (optional): Marks the dependency as optional (e.g., for extra features like enabling computation on GPU).</li> <li>dependencies (optional): Indicates whether to install sub-dependencies.</li> </ul>"},{"location":"dependencies/#dependencies","title":"Dependencies","text":"<pre><code>class Dependencies(TypedDict):\n    python: NotRequired[str]\n    conda: NotRequired[list[str | Dependency]]\n    pip: NotRequired[list[str | Dependency]]\n</code></pre> <p>Top-level dependency configuration:</p> <ul> <li>python (optional str): Specifies the Python version required (e.g., <code>\"==3.9\"</code>).</li> <li>conda (optional list): Conda dependencies (package names or <code>Dependency</code> objects).</li> <li>pip (optional list): Pip dependencies (package names or <code>Dependency</code> objects).</li> </ul>"},{"location":"dependencies/#example","title":"\ud83e\uddea Example","text":"<p>Here\u2019s an example dependency specification:</p> <pre><code>dependencies: Dependencies = {\n    \"python\": \"==3.11\",\n    \"conda\": [\n        \"numpy\",\n        {\"name\": \"nvidia::cudatoolkit=11.0.*\", \"optional\": True, \"platforms\": [\"linux-64\", \"windows-64\"]},\n        {\"name\": \"nvidia::nvidia::cudnn=8.0.*\", \"optional\": True, \"platforms\": [\"linux-64\", \"windows-64\"]},\n        {\"name\": \"pyobjc\", \"platforms\": [\"osx-64\", \"osx-arm64\"], \"optional\": True},\n    ],\n    \"pip\": [\n        \"tensorflow==2.16.1\",\n        \"csbdeep==0.8.1\", \n        \"stardist==0.9.1\",\n        {\"name\": \"some-macos-only-package\", \"platforms\": [\"osx-arm64\"]},\n        {\"name\": \"helper\", \"optional\": True, \"dependencies\": False}\n    ]\n}\n</code></pre>"},{"location":"dependencies/#explanation","title":"Explanation:","text":"<ul> <li><code>python: \"==3.11\"</code>: Requires Python version 3.11 exactly.</li> <li><code>conda</code> section:<ul> <li><code>\"numpy\"</code>: required on all platforms.</li> <li><code>\"nvidia::cudatoolkit=11.0.*\"</code>: An optional CUDA toolkit, installed only on Linux and Windows (x86_64) (so that GPU is used on x86_64 linux and windows, and CPU is used otherwise).</li> <li><code>\"nvidia::nvidia::cudnn=8.0.*\"</code>: An optional cuDNN library for deep learning acceleration on Linux and Windows (x86_64) (so that GPU is used on x86_64 linux and windows, and CPU is used otherwise).</li> <li><code>\"pyobjc\"</code>: An optional macOS-only dependency for Python\u2013Objective-C bridging, included on both Intel and Apple Silicon macOS.</li> </ul> </li> <li><code>pip</code> section:<ul> <li><code>\"tensorflow==2.16.1\"</code>: Required version of TensorFlow for all platforms.</li> <li><code>\"csbdeep==0.8.1\"</code> and <code>\"stardist==0.9.1\"</code>: Required deep learning packages for image restoration and segmentation.</li> <li><code>\"some-macos-only-package\"</code>: Only installed on macOS Apple Silicon (<code>osx-arm64</code>).</li> <li><code>helper</code>: An optional pip package which much be installed without its dependencies.</li> </ul> </li> </ul>"},{"location":"dependencies/#usage-recommendations","title":"\u2705 Usage Recommendations","text":"<ul> <li>Use <code>platforms</code> to restrict platform-specific packages (e.g., <code>pyobjc</code> for macOS).</li> <li>Use <code>optional</code> for optional feature packages.</li> <li>Use <code>dependencies=False</code> to only install the package without its dependencies.</li> </ul>"},{"location":"getting_started/","title":"Getting started","text":""},{"location":"getting_started/#simplified-execution-with-envimport_module","title":"Simplified Execution with <code>env.import_module</code>","text":"<p>To demonstrates the most straightforward way to use Wetlands, we will create an environment, install <code>cellpose</code>, and run a segmentation function defined in a separate file (<code>example_module.py</code>) within that isolated environment.</p> <p>Let's see the main script <code>getting_started.py</code> step by step. </p> <p>We will segment the image <code>img02.png</code> (available here).</p> <pre><code>from pathlib import Path\nimage_path = Path(\"img02.png\")\nsegmentation_path = image_path.parent / f\"{image_path.stem}_segmentation.png\"\n</code></pre>"},{"location":"getting_started/#1-initialize-the-environment-manager","title":"1. Initialize the Environment Manager","text":"<p>We start by initializing the EnvironmentManager. We provide: - A <code>wetlands_instance_path</code> where Wetlands stores logs and debug information (defaults to <code>\"wetlands/\"</code>). - Optionally, a <code>conda_path</code> where Wetlands should look for an existing Pixi (or Micromamba) installation or where it should download and set up a new one. If not provided, it defaults to <code>wetlands_instance_path / \"pixi\"</code>.</p> <pre><code>from wetlands.environment_manager import EnvironmentManager\n\nenvironment_manager = EnvironmentManager()\n# Or with explicit paths:\n# environment_manager = EnvironmentManager(\n#     wetlands_instance_path=\"wetlands_state\",\n#     conda_path=\"path/to/pixi/\"\n# )\n</code></pre> <p>Note</p> <p>EnvironmentManager also accepts a <code>main_conda_environment_path</code> argument, useful if Wetlands is used in a conda environment (e.g. <code>environment_manager = EnvironmentManager(main_conda_environment_path=\"/path/to/project/environment/\")</code>). Wetlands will activate this main environment and check if the installed packages satisfy the requirements when creating new environments. If the required dependencies are already installed in the main environment, EnvironmentManager.create() will return the main enviroment instead of creating a new one. The modules will be called directly, bypassing the Wetlands communication server.</p> <p>Warning</p> <p>On Windows, spaces are not allowed in the <code>conda_path</code> argument of <code>EnvironmentManager()</code>.</p>"},{"location":"getting_started/#2-create-or-get-an-environment-and-install-dependencies","title":"2. Create (or get) an Environment and Install Dependencies","text":"<p>Next, we define and create the Conda environment. We give it a name (<code>\"cellpose_env\"</code>) and specify its dependencies using a dictionary. Here, we require <code>cellpose</code> version 3.1.0, to be installed via Conda. If an environment with this name already exists, Wetlands will use it (and ignore the dependencies); otherwise, it will create it and install the specified dependencies. The <code>create</code> method returns an <code>Environment</code> object.</p> <pre><code>env = environment_manager.create(\n    \"cellpose_env\",\n    {\"conda\": [\"cellpose==3.1.0\"]}\n)\n</code></pre> <p>Note</p> <p>If a <code>main_conda_environment_path</code> was provided when instanciating the <code>EnvironmentManager</code>, Wetlands will check if <code>cellpose==3.1.0</code> is already installed in the main environment and return it if it is the case. If <code>main_conda_environment_path</code> is not provided but the required dependencies are only pip packages, Wetlands will check if the dependencies are installed in the current python environment and return it if it is the case.</p> <p>Reusing existing environments with <code>use_existing=True</code></p> <p>You can pass <code>use_existing=True</code> to <code>create()</code> to search for and reuse an existing environment that satisfies the dependencies. This includes the main environment. If no environment satisfies the requirements, a new one will be created. By default, <code>use_existing=False</code>, which always creates a new environment.</p> <pre><code># Return main or existing environment if it satisfies the dependencies\nenv = environment_manager.create(\n    \"cellpose_env\",\n    {\"conda\": [\"cellpose==3.1.0\"]},\n    use_existing=True  # Check if any existing env satisfies the dependencies\n)\n</code></pre> <p>Specifying dependencies</p> <p>See the dependencies page to learn more on specifying dependencies. Wetlands supports PEP 440 version specifiers, so you can use flexible version constraints like <code>\"numpy&gt;=1.20,&lt;2.0\"</code>, <code>\"scipy~=1.5\"</code>, or <code>\"pandas!=1.0.0\"</code>. You can also use <code>EnvironmentManager.create_from_config()</code> and provide a <code>requirements.txt</code>, <code>environment.yml</code>, <code>pyproject.toml</code> or <code>pixi.toml</code> file for your dependencies.</p> <p>Load an existing environment</p> <p>You can also load an existing environment with <code>environment.load(\"env_name\", Path(\"Path/to/existing/environment/pyproject.toml\"))</code>. See <code>EnvironmentManager.load()</code>.</p>"},{"location":"getting_started/#3-launch-the-environments-communication-server","title":"3. Launch the Environment's Communication Server","text":"<p>For Wetlands to execute code within the isolated environment (using <code>import_module</code> or <code>execute</code>), we need to launch its background communication server. This server runs as a separate process inside the <code>cellpose_env</code> and listens for commands from our main script.</p> <pre><code>env.launch()\n</code></pre>"},{"location":"getting_started/#4-import-and-execute-code-in-the-environment-via-proxy","title":"4. Import and Execute Code in the Environment via Proxy","text":"<p>This is where the core Wetlands interaction happens. We use <code>env.import_module(\"example_module.py\")</code> to gain access to the functions defined in <code>example_module.py</code>. Wetlands doesn't actually import the module into the main process; instead, it returns a proxy object. When we call a method on this proxy object (like <code>example_module.segment(...)</code>), Wetlands intercepts the call, sends the function name and arguments to the server running in the <code>cellpose_env</code>, executes the real function there, and returns the result back to the main script. File paths and other pickleable arguments are automatically transferred.</p> <pre><code>print(\"Importing module in environment...\")\nexample_module = env.import_module(\"example_module.py\")\n\nprint(f\"Running segmentation on {image_path}...\")\ndiameters = example_module.segment(str(image_path), str(segmentation_path))\n\nprint(f\"Segmentation complete. Found diameters of {diameters} pixels.\")\n</code></pre> <p>Alternatively, we could use <code>env.execute()</code> directly:</p> <pre><code>print(f\"Running segmentation on {image_path}...\")\nargs = (str(image_path), str(segmentation_path))\ndiameters = env.execute(\"example_module.py\", \"segment\", args)\n\nprint(f\"Segmentation complete. Found diameters of {diameters} pixels.\")\n</code></pre> <p>Function arguments must be serializable</p> <p>The arguments of the segment function will be send to the other process via <code>multiprocessing.connection.Connection.send()</code> so the objects must be picklable.</p>"},{"location":"getting_started/#5-clean-up","title":"5. Clean Up","text":"<p>Finally, we tell Wetlands to shut down the communication server and clean up resources associated with the launched environment.</p> <pre><code>print(\"Exiting environment...\")\nenv.exit()\n\nprint(\"Done.\")\n</code></pre> <code>getting_started.py</code> source code <pre><code>from pathlib import Path\nfrom wetlands.environment_manager import EnvironmentManager\nimport urllib.request\nimport logging\n\n\ndef initialize(pip_deps=[]):\n    # Initialize the environment manager\n    # Wetlands will store logs and state in the wetlands_instance_path (defaults to \"wetlands/\")\n    # Pixi/Micromamba will be installed in wetlands_instance_path/pixi by default\n    logging.getLogger(\"wetlands\").addHandler(logging.StreamHandler())\n    environment_manager = EnvironmentManager()\n\n    # Create and launch an isolated Conda environment named \"cellpose\"\n    env = environment_manager.create(\"cellpose\", {\"conda\": [\"cellpose==3.1.0\"], \"pip\": pip_deps})\n    env.launch()\n\n    # Download example image from cellpose\n    image_path = Path(\"cellpose_img02.png\")\n    image_url = \"https://www.cellpose.org/static/images/img02.png\"\n\n    with urllib.request.urlopen(image_url) as response:\n        image_data = response.read()\n\n    with open(image_path, \"wb\") as handler:\n        handler.write(image_data)\n\n    return image_path, env\n\n\nif __name__ == \"__main__\":\n    # Initialize: create the environment manager, the Cellpose conda environment, and download the image to segment\n    image_path, env = initialize()\n\n    # Import example_module in the environment\n    example_module = env.import_module(\"example_module.py\")\n    # exampleModule is a proxy to example_module.py in the environment,\n    # calling exampleModule.function_name(args) will run env.execute(module_name, function_name, args)\n    diameters = example_module.segment(str(image_path))\n\n    # Or use env.execute() directly to call a function in a module\n    # diameters = env.execute(\"example_module.py\", \"segment\", (image_path))\n\n    # Alternatively, use env.run_script() to run an entire Python script\n    # env.run_script(\"script.py\", args=(str(image_path)))\n\n    print(f\"Found diameters of {diameters} pixels.\")\n\n    # Clean up and exit the environment\n    env.exit()\n</code></pre> <p>Now, let's look at the <code>example_module.py</code> file. This code contains the actual segmentation logic and is executed inside the isolated <code>cellpose_env</code> when called via the proxy object.</p>"},{"location":"getting_started/#define-the-segmentation-function","title":"Define the Segmentation Function","text":"<p>The module defines a <code>segment</code> function that takes input/output paths and other parameters. It uses a global variable <code>model</code> to potentially cache the loaded Cellpose model between calls within the same environment process lifetime.</p> <pre><code># example_module.py\nfrom pathlib import Path\nfrom typing import Any, cast\n\nmodel = None\n\ndef segment(\n    input_image: Path | str,\n    segmentation: Path | str,\n    model_type=\"cyto\",\n    use_gpu=False,\n    channels=[0, 0],\n    auto_diameter=True,\n    diameter=30,\n):\n    \"\"\"Performs cell segmentation using Cellpose.\"\"\"\n    global model\n\n    input_image = Path(input_image)\n    if not input_image.exists():\n        raise FileNotFoundError(f\"Error: input image {input_image}\"\\\n                                \"does not exist.\")\n</code></pre>"},{"location":"getting_started/#import-dependencies-inside-the-environment","title":"Import Dependencies (Inside the Environment)","text":"<p>Crucially, the necessary libraries (<code>cellpose</code>, <code>numpy</code>) are imported within this function, meaning they are resolved using the packages installed inside the isolated <code>cellpose_env</code>, not the main script's environment. This is important to enable the main script to import <code>example_module.py</code> without raising a <code>ModuleNotFoundError</code>. In this way, the main script can see the functions defined in <code>example_module.py</code>. This is only necessary when using the proxy object (<code>env.import_module(\"example_module.py\")</code> then <code>example_module.function(args)</code>) but it is not required when using <code>env.execute(\"example_module.py\", \"function\", (args))</code> directly.</p> <pre><code>    print(f\"[[1/4]] Load libraries and model '{model_type}'\")\n    import cellpose.models\n    import cellpose.io\n    import numpy as np\n</code></pre> <p>Using try catch to prevent <code>ModuleNotFoundError</code></p> <p>A better approach is to use a try statement at the beginning of <code>example_module.py</code> to fail silently when importing modules which are not accessible in the main environment, like so:</p> <pre><code>try:\n    import cellpose.models\n    import cellpose.io\n    import numpy as np\nexcept ModuleNotFoundError:\n    pass\n...\n</code></pre> <p>This allows:  - to access the function definitions in the main environment (even if we won't be able to execute them in the main environment),  - to import the modules for all functions defined in <code>example_module.py</code> in the <code>cellpose_env</code>.</p>"},{"location":"getting_started/#load-model-and-process-image","title":"Load Model and Process Image","text":"<p>The code proceeds to load the Cellpose model (if not already cached) and the input image. All this happens within the context of the <code>cellpose_env</code>.</p> <pre><code>    if model is None or model.cp.model_type != model_type:\n        print(\"Loading model...\")\n        gpu_flag = str(use_gpu).lower() == 'true'\n        model = cellpose.models.Cellpose(gpu=gpu_flag, model_type=model_type)\n\n    print(f\"[[2/4]] Load image {input_image}\")\n    image = cast(np.ndarray, cellpose.io.imread(str(input_image)))\n</code></pre>"},{"location":"getting_started/#perform-segmentation","title":"Perform Segmentation","text":"<p>The core segmentation task is performed using the loaded model and image. Any exceptions raised here will be captured by Wetlands and re-raised in the main script.</p> <pre><code>    print(f\"[[3/4]] Compute segmentation for image shape {image.shape}\")\n    try:\n        kwargs: Any = dict(diameter=int(diameter)) if auto_diameter else {}\n        masks, _, _, diams = model.eval(image, channels=channels, **kwargs)\n    except Exception as e:\n        print(f\"Error during segmentation: {e}\")\n        raise e\n    print(\"Segmentation finished (inside environment).\")\n</code></pre>"},{"location":"getting_started/#save-results-and-return-value","title":"Save Results and Return Value","text":"<p>The segmentation results (masks) are saved to disk, potentially renaming the output file. The function then returns the calculated cell diameters (<code>diams</code>). This return value is serialized by Wetlands and sent back to the main script.</p> <pre><code>    if segmentation is None:                # If segmentation is None: return all results\n        return masks, flows, styles, diams\n\n    segmentation_path = Path(segmentation)\n    print(f\"[[4/4]] Save segmentation to {segmentation_path}\")\n\n    cellpose.io.save_masks(image, masks, flows, str(input_image), png=True)\n    default_output = input_image.parent / f\"{input_image.stem}_cp_masks.png\"\n\n    if default_output.exists():\n        if segmentation_path.exists():\n            segmentation_path.unlink()\n        default_output.rename(segmentation_path)\n        print(f\"Saved mask: {segmentation_path}\")\n    else:\n        print(\"Warning: Segmentation mask file was not generated by cellpose.\")\n\n    return diams\n</code></pre> <code>example_module.py</code> source code <pre><code>from pathlib import Path\nfrom typing import TYPE_CHECKING, Any\n\nmodel = None\n\nif TYPE_CHECKING:\n    import numpy\n\n\ndef segment_image(\n    image: numpy.ndarray,\n    model_type=\"cyto\",\n    use_gpu=False,\n    channels=[0, 0],\n    auto_diameter=True,\n    diameter=30,\n) -&gt; Any:\n    global model\n\n    print(\"Loading libraries...\")\n    import cellpose.models  # type: ignore\n\n    if model is None or model.cp.model_type != model_type:\n        print(f\"Loading model {model_type}...\")\n        model = cellpose.models.Cellpose(gpu=True if use_gpu == \"True\" else False, model_type=model_type)\n\n    print(\"Compute segmentation...\")\n    try:\n        kwargs: Any = dict(diameter=int(diameter)) if auto_diameter else {}\n        masks, flows, styles, diams = model.eval(image, channels=channels, **kwargs)\n    except Exception as e:\n        print(e)\n        raise e\n    print(\"Segmentation finished.\")\n    return masks, flows, styles, diams\n\n\ndef segment(\n    input_image: Path | str,\n    model_type=\"cyto\",\n    use_gpu=False,\n    channels=[0, 0],\n    auto_diameter=True,\n    diameter=30,\n    return_segmentation=False,  # return segmentation or save it in a file\n) -&gt; Any:\n    global model\n\n    import cellpose.io  # type: ignore\n\n    input_image = Path(input_image)\n    image = cellpose.io.imread(input_image)\n\n    masks, flows, styles, diams = segment_image(image, model_type, use_gpu, channels, auto_diameter, diameter)\n\n    # If return_segmentation: return masks, otherwise save them and return diams\n    if return_segmentation:\n        return masks\n\n    # save results as png\n    cellpose.io.save_masks(image, masks, flows, str(input_image), png=True)\n\n    return diams\n</code></pre>"},{"location":"getting_started/#summary-of-example-1-flow","title":"Summary of Example 1 Flow:","text":"<p>The main script uses <code>EnvironmentManager</code> to prepare an isolated environment. [<code>env.launch()</code>][wetlands.environment_manager.Environment.launch] starts a hidden server in that environment. <code>env.import_module()</code> provides a proxy, and calling functions on the proxy executes the code (like <code>example_module.segment</code>) within the isolated environment, handling data transfer automatically. <code>env.exit()</code> cleans up the server process.</p>"},{"location":"getting_started/#next-steps","title":"Next Steps","text":"<ul> <li>See Shared memory to share memory between environments</li> <li>See Advanced Examples for more complex workflows</li> <li>See Wetlands logging system</li> <li>See Debugging Guide to understand how to debug within environments</li> </ul>"},{"location":"how_it_works/","title":"How it works","text":""},{"location":"how_it_works/#step-by-step","title":"\ud83c\udf93 Step by Step","text":"<p>Wetlands leverages Pixi, a package management tool for developers, or Micromamba, a fast, native reimplementation of the Conda package manager.</p> <ol> <li>Pixi or Micromamba Setup: When <code>EnvironmentManager</code> is initialized, it checks for a <code>pixi</code> or <code>micromamba</code> executable at the specified path (e.g., <code>\"micromamba/\"</code>). If not found, it downloads a self-contained Pixi or Micromamba binary suitable for the current operating system and architecture into that directory. This means Wetlands doesn't require a pre-existing Conda/Mamba installation.</li> <li>Environment Creation: <code>create(envName, dependencies)</code> uses Pixi or Micromamba commands (<code>pixi init /path/to/envName</code> or  <code>micromamba create -n envName -c channel package ...</code>) to build a new, isolated Conda environment within the Pixi or Micromamba prefix (e.g., <code>pixi/workspaces/envName/envs/default/</code> or <code>micromamba/envs/envName</code>). When using Pixi, Wetlands also creates a workspace for the environment (e.g. <code>pixi/workspace/envName/</code>). Note that the main environemnt is returned if it already satisfies the required dependencies.</li> <li>Dependency Installation: Dependencies (Conda packages, Pip packages) are installed into the target environment using <code>pixi add ...</code> or <code>micromamba install ...</code> and <code>pip install ...</code> (executed within the activated environment).</li> <li>Execution (<code>launch</code>/<code>execute</code>/<code>import_module</code>):<ul> <li><code>launch()</code> starts a helper Python script (<code>wetlands._internal.executor_server</code>) within the activated target environment using <code>subprocess.Popen</code>.</li> <li>This server listens on a local socket using <code>multiprocessing.connection.Listener</code>.</li> <li>The main process connects to this server using <code>multiprocessing.connection.Client</code>.</li> <li><code>execute(module, func, args)</code> sends a message containing the module path, function name, and arguments to the server.</li> <li>The server imports the module (if not already imported), executes the function with the provided arguments, and sends the result (or exception) back to the main process.</li> <li><code>import_module(module)</code> creates a proxy object in the main process. When methods are called on this proxy, it triggers the <code>execute</code> mechanism described above.</li> </ul> </li> <li>Direct Execution (<code>execute_commands</code>): This method directly activates the target environment and runs the provided shell commands using <code>subprocess.Popen</code> (no communication server involved here). The user is responsible for managing the launched process and any necessary communication.</li> <li>Isolation: Each environment created by Wetlands is fully isolated, preventing dependency conflicts between different environments or with the main application's environment.</li> </ol>"},{"location":"how_it_works/#under-the-hood","title":"\u2699\ufe0f Under the Hood","text":"<p>Wetlands uses the <code>EnvironmentManager.execute_commands()</code> for different operations (to create environments, install dependencies, etc).  Behind the scenes, this method creates and executes a temporary script (a bash script on Linux and Mac, and a PowerShell script on Windows) which looks like the following:</p> <pre><code># Initialize Micromamba\ncd \"/path/to/examples/micromamba\"\nexport MAMBA_ROOT_PREFIX=\"/path/to/examples/micromamba\"\neval \"$(micromamba shell hook -s posix)\"\n\n# Create the cellpose environment\ncd \"/Users/amasson/Travail/wetlands/examples\"\nmicromamba --rc-file \"/path/to/examples/micromamba/.mambarc\" create -n cellpose python=3.12.7 -y\n\n# Activate the environment\ncd \"/path/to/examples/\"\nmicromamba activate cellpose\n\n# Install the dependencies\necho \"Installing conda dependencies...\"\nmicromamba --rc-file \"/path/to/examples/micromamba/.mambarc\" install \"cellpose==3.1.0\" -y\n\n# Execute optional custom commands\npython -u example_module.py\n</code></pre>"},{"location":"logging/","title":"Wetlands Logging Guide","text":"<p>Wetlands provides a comprehensive logging system that tracks operations across environments with rich context metadata. This guide shows you how to integrate and customize logging in your applications.</p>"},{"location":"logging/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Overview</li> <li>Log Context</li> <li>Basic Usage</li> <li>Advanced Examples</li> <li>Filtering Logs by Context</li> <li>Per-Execution Log Files</li> <li>GUI Integration</li> <li>Custom Log Processing</li> </ul>"},{"location":"logging/#overview","title":"Overview","text":"<p>Wetlands automatically logs all operations (environment creation, installation, execution) with rich context metadata:</p> <ul> <li>By default, logs are written to <code>\"wetlands/wetlands.log\"</code> file (when using <code>EnvironmentManager</code>)</li> <li>Use <code>logging.basicConfig()</code> or add handlers to enable console output</li> <li>Most logs include context fields (environment name, operation type, etc.)</li> <li>ProcessLogger reads subprocess output in background threads for real-time logging</li> </ul> <p>Note</p> <p>By default, <code>execute_commands()</code> functions read process stdout in a background thread via ProcessLogger. If you need to read stdout manually, pass <code>log=False</code> to disable automatic logging.</p>"},{"location":"logging/#log-context","title":"Log Context","text":"<p>Every log record in Wetlands includes metadata that helps track operations. This metadata is stored in the LogRecord's attributes and can be accessed via custom handlers and filters.</p> <ol> <li> <p>Global - General application operations    <pre><code>{\n    \"log_source\": \"global\",\n    \"stage\": None\n}\n</code></pre></p> </li> <li> <p>Environment - Environment creation, installation, launching    <pre><code>{\n    \"log_source\": \"environment\",\n    \"env_name\": \"cellpose\",           # Environment name\n    \"stage\": \"create\"                 # One of: \"create\", \"install\", \"launch\"\n}\n</code></pre></p> </li> <li> <p>Execution - Function/script execution within environments    <pre><code>{\n    \"log_source\": \"execution\",\n    \"env_name\": \"cellpose\",\n    \"call_target\": \"segment:detect\"   # Format: \"module:function\" or \"script.py\"\n}\n</code></pre></p> </li> </ol>"},{"location":"logging/#basic-usage","title":"Basic Usage","text":""},{"location":"logging/#default-behavior","title":"Default Behavior","text":"<p>By default, when you create an <code>EnvironmentManager</code>, it automatically enables logging to <code>\"wetlands/wetlands.log\"</code>:</p> <pre><code>from wetlands.environment_manager import EnvironmentManager\n\n\n# To enable console logging: use basicConfig (simplest)\nlogging.basicConfig(level=logging.INFO)\n\n# You can also add a console handler manually\nlogging.getLogger(\"wetlands\").addHandler(logging.StreamHandler())\nlogging.getLogger(\"wetlands\").setLevel(logging.INFO)\n\n\n# Logs are automatically written to \"wetlands/wetlands.log\"\nenv_manager = EnvironmentManager()\n# Change log path with:\n# env_manager = EnvironmentManager(log_file_path=Path(\"my_logs/operation.log\"))\n# Disable file logging with:\n# env_manager = EnvironmentManager(log_file_path=None)\nenv = env_manager.create(\"cellpose\", {\"conda\": [\"cellpose==3.1.0\"]})\nenv.launch()\n\n# All operations are now logged to wetlands/wetlands.log\n</code></pre>"},{"location":"logging/#advanced-examples","title":"Advanced Examples","text":""},{"location":"logging/#per-execution-log-files","title":"Per-Execution Log Files","text":"<p>Capture logs from individual function/script executions to separate files. Here's a simple context manager that routes all logs during execution to a file:</p> <pre><code>from pathlib import Path\nfrom contextlib import contextmanager\nfrom wetlands.environment_manager import EnvironmentManager\nimport logging\n\n@contextmanager\ndef capture_execution_logs(output_file: Path):\n    \"\"\"Context manager to capture all logs during execution to a file.\"\"\"\n    logger = logging.getLogger(\"wetlands\")\n    handler = logging.FileHandler(output_file)\n    handler.setFormatter(logging.Formatter('%(asctime)s [%(levelname)s] %(message)s'))\n    logger.addHandler(handler)\n\n    try:\n        yield\n    finally:\n        logger.removeHandler(handler)\n        handler.close()\n\n# Usage: route logs from different executions to different files\nenv_manager = EnvironmentManager()\nenv = env_manager.create(\"analysis\", {\"conda\": [\"pandas\", \"scikit-learn\"]})\nenv.launch()\n\nwith capture_execution_logs(Path(\"preprocess.log\")):\n    env.execute(\"analysis.py\", \"preprocess\", args=(\"data.csv\",))\n\nwith capture_execution_logs(Path(\"train.log\")):\n    env.execute(\"analysis.py\", \"train_model\", args=(50,))\n\nwith capture_execution_logs(Path(\"evaluate.log\")):\n    env.execute(\"analysis.py\", \"evaluate\")\n</code></pre> <p>You can also use Wetlands ProcessLogger:</p> <pre><code># Retrieve the ProcessLogger that was created by execute_commands\nprocess_logger = self.environment_manager.get_process_logger(env.process.pid)\n\n# Subscribe to the process output\ndef check_output(line: str, _context: dict) -&gt; None:\n    if \"Special message\" in line:\n        print(line)\n\n# Be aware of the include_history arg to apply the callback on the entire log history, or only the futur logs\nprocess_logger.subscribe(check_output, include_history=False)\n\n# Wait for port announcement with timeout\ndef port_predicate(line: str) -&gt; bool:\n    return line.startswith(\"Listening port \")\n\nport_line = process_logger.wait_for_line(port_predicate, timeout=30)\n\nif port_line:\n    port = int(port_line.replace(\"Listening port \", \"\"))\n    connection = Client((\"localhost\", self.port))\n</code></pre> <p>If you want to capture only logs from a specific execution (filtering by <code>call_target</code>), use a filter:</p> <pre><code>@contextmanager\ndef capture_execution_logs_filtered(env_name: str, call_target: str, output_file: Path):\n    \"\"\"Context manager that captures only logs from a specific execution.\"\"\"\n    logger = logging.getLogger(\"wetlands\")\n    handler = logging.FileHandler(output_file)\n    handler.setFormatter(logging.Formatter('%(asctime)s [%(levelname)s] %(message)s'))\n\n    def filter_execution(record):\n        return (getattr(record, \"log_source\") == \"execution\" and\n            getattr(record, \"env_name\") == env_name and\n            getattr(record, \"call_target\") == call_target\n        )\n\n    handler.addFilter(filter_execution)\n    logger.addHandler(handler)\n\n    try:\n        yield\n    finally:\n        logger.removeHandler(handler)\n        handler.close()\n\n# Usage with filtering\nwith capture_execution_logs_filtered(\"analysis\", \"preprocess:run\", Path(\"preprocess.log\")):\n    env.execute(\"preprocess.py\", \"run\", args=(\"data.csv\",))\n</code></pre>"},{"location":"logging/#filtering-logs-by-context","title":"Filtering Logs by Context","text":"<p>Route different log types to separate files:</p> <pre><code>import logging\nfrom pathlib import Path\nfrom wetlands.environment_manager import EnvironmentManager\nfrom wetlands.logger import enable_file_logging\n\n# Enable main log file\nenable_file_logging(Path(\"wetlands.log\"))\n\n# Get the wetlands logger\nlogger = logging.getLogger(\"wetlands\")\n\n# Create separate handlers for different log sources\nenv_handler = logging.FileHandler(\"environment.log\")\nexec_handler = logging.FileHandler(\"execution.log\")\n\n# Create filters\ndef filter_environment(record):\n    return getattr(record, \"log_source\", None) == \"environment\"\n\ndef filter_execution(record):\n    return getattr(record, \"log_source\", None) == \"execution\"\n\n# Add filters and attach handlers\nenv_handler.addFilter(filter_environment)\nexec_handler.addFilter(filter_execution)\n\nlogger.addHandler(env_handler)\nlogger.addHandler(exec_handler)\n\n# Now operations are routed to appropriate files\nenv_manager = EnvironmentManager()\nenv = env_manager.create(\"analysis\", {\"conda\": [\"numpy\", \"pandas\"]})  # \u2192 environment.log\nenv.launch()                                                            # \u2192 environment.log\nresult = env.execute(\"process.py\", \"analyze\", args=(\"data.csv\",))     # \u2192 execution.log\n</code></pre> <p>Result: <pre><code>wetlands.log      # All logs (environment + execution)\nenvironment.log   # Only environment operations\nexecution.log     # Only function/script executions\n</code></pre></p>"},{"location":"logging/#gui-integration","title":"GUI Integration","text":"<p>Display real-time logs in a GUI. Important: Log callbacks run in background threads, so use thread-safe mechanisms.</p> <p>Tkinter Example: <pre><code>import tkinter as tk\nfrom tkinter.scrolledtext import ScrolledText\nfrom queue import Queue\nimport threading\n\nfrom wetlands.environment_manager import EnvironmentManager\nfrom wetlands.logger import attach_log_handler\n\nclass LogViewer:\n    def __init__(self, root):\n        self.root = root\n        self.log_queue = Queue()  # Thread-safe queue\n\n        self.log_text = ScrolledText(root, height=20, width=80)\n        self.log_text.pack(fill=\"both\", expand=True, padx=5, pady=5)\n\n        # Attach logging handler - runs in background thread\n        attach_log_handler(self.on_log)\n\n        # Poll queue from main thread\n        self.poll_queue()\n\n    def on_log(self, message):\n        \"\"\"Called from ProcessLogger thread - queue the message.\"\"\"\n        self.log_queue.put(message)\n\n    def poll_queue(self):\n        \"\"\"Process queued messages on main thread.\"\"\"\n        try:\n            while True:\n                message = self.log_queue.get_nowait()\n                self.log_text.insert(\"end\", f\"{message}\\n\")\n                self.log_text.see(\"end\")\n        except:\n            pass\n        # Poll again after 100ms\n        self.root.after(100, self.poll_queue)\n\nif __name__ == \"__main__\":\n    root = tk.Tk()\n    root.title(\"Wetlands Operations\")\n    viewer = LogViewer(root)\n\n    # Run operations in background thread\n    def run_ops():\n        env_mgr = EnvironmentManager()\n        env = env_mgr.create(\"demo\", {\"conda\": [\"numpy\"]})\n        env.launch()\n        env.execute(\"script.py\", \"main\")\n\n    threading.Thread(target=run_ops, daemon=True).start()\n    root.mainloop()\n</code></pre></p> <p>PyQt6 Example: <pre><code>from PyQt6.QtWidgets import QApplication, QMainWindow, QTextEdit\nfrom PyQt6.QtCore import pyqtSignal, QObject\nimport threading\n\nfrom wetlands.environment_manager import EnvironmentManager\nfrom wetlands.logger import attach_log_handler\n\nclass LogSignals(QObject):\n    log_signal = pyqtSignal(str)  # Signal for thread-safe communication\n\nclass LogViewer(QMainWindow):\n    def __init__(self):\n        super().__init__()\n        self.signals = LogSignals()\n        self.text_edit = QTextEdit()\n        self.setCentralWidget(self.text_edit)\n        self.setWindowTitle(\"Wetlands Operations\")\n        self.setGeometry(100, 100, 800, 600)\n\n        # Connect signal to slot (main thread)\n        self.signals.log_signal.connect(self.append_log)\n\n        # Attach handler - runs in background thread\n        attach_log_handler(self.on_log)\n\n    def on_log(self, message):\n        \"\"\"Called from ProcessLogger thread - emit signal.\"\"\"\n        self.signals.log_signal.emit(message)\n\n    def append_log(self, message):\n        \"\"\"Called on main thread (slot).\"\"\"\n        self.text_edit.append(message)\n\nif __name__ == \"__main__\":\n    app = QApplication([])\n    viewer = LogViewer()\n    viewer.show()\n\n    # Run operations in background\n    def run_ops():\n        env_mgr = EnvironmentManager()\n        env = env_mgr.create(\"demo\", {\"conda\": [\"numpy\"]})\n        env.launch()\n        env.execute(\"script.py\", \"main\")\n\n    threading.Thread(target=run_ops, daemon=True).start()\n    app.exec()\n</code></pre></p>"},{"location":"logging/#tips-tricks","title":"Tips &amp; Tricks","text":"<ol> <li>Be thread-safe when updating UI from log callbacks - use queues or signals</li> </ol>"},{"location":"shared_memory/","title":"Sharing memory among processes","text":"<p>The Python <code>multiprocessing.shared_memory</code> module enables to share memory among processes. The <code>shared_memory_standalone.py</code> script below demonstrates this.</p> <p>Wetlands provides [NDArray][wetlands.ndarray.NDArray] to automatically convert numpy arrays to shared memory objects and send them between environments.  This requires to install Wetlands in the external environment. The <code>shared_memory_return_ndarray.py</code> and <code>shared_memory_provide_ndarrays.py</code> scripts below demonstrate this.</p> <p>In short: <pre><code>import numpy as np\nfrom wetlands.environment_manager import EnvironmentManager\nfrom wetlands.ndarray import NDArray\n\nenvironment_manager = EnvironmentManager()\n\nenv = environment_manager.create(\"numpy\", {\"pip\":[\"wetlands&gt;=0.4.8\", \"numpy==2.2.4\"]})\nenv.launch()\n\nminimal_module = env.import_module(\"minimal_module.py\")\n\n# Create the shared_memory.SharedMemory shm from the numpy array\narray = NDArray(np.array([1,2,3]))\nresult = minimal_module.sum(array)\n\nprint(f\"Sum of {array} is {result}.\")\n\n# Release the shared memory: calls shm.unlink(), shm.close() (optionally unregisters it)\narray.dispose()\nenv.exit()\n</code></pre></p> <p>with <code>example_module.py</code> as follow:</p> <pre><code>def sum(x):\n    import numpy as np\n    result = int(np.sum(x.array))\n    return result\n</code></pre> <p>Note</p> <p>You can find more shared memory helpers in the [<code>ndarray</code> module][wetlands.ndarray] module.</p>"},{"location":"shared_memory/#standalone-example","title":"Standalone example","text":"<p>Fist, let see the use of shared memory without the Wetlands NDArray helper. No need to install wetlands in the external environment.</p> <p>Note</p> <p>You need to install <code>numpy</code> to run this example, since it is used to save the resulting masks stored in the shared memory.</p> <p>It will use <code>shared_memory_standalone_module.py</code> to create the segmentation and the shared memory holding the resulting masks.</p> <p>This module defines two functions:</p> <ul> <li> <p>a <code>segment</code> function which uses the <code>segment</code> function of <code>example_module.py</code> and creates a NumPy array backed by a shared memory to store the resulting masks,</p> </li> <li> <p>a <code>clean</code> function to clean up, free and release the shared memory block.</p> </li> </ul> <pre><code>import numpy as np\nfrom pathlib import Path\nfrom multiprocessing import shared_memory\n\nimport example_module\n\nshm: shared_memory.SharedMemory | None = None\n\n\ndef segment(image_path: Path | str):\n    global shm\n    # Segment the image with example_module.py\n    masks = example_module.segment(image_path, return_segmentation=True)\n    # Create the shared memory\n    shm = shared_memory.SharedMemory(create=True, size=masks.nbytes)\n    # Create a NumPy array backed by shared memory\n    masks_shared = np.ndarray(masks.shape, dtype=masks.dtype, buffer=shm.buf)\n    # Copy the masks into the shared memory\n    masks_shared[:] = masks[:]\n    # Return the shape, dtype and shared memory name to recreate the numpy array on the other side\n    return masks.shape, masks.dtype, shm.name\n\n\ndef clean():\n    global shm\n    if shm is None:\n        return\n    # Clean up the shared memory in this process\n    shm.close()\n    # Free and release the shared memory block\n    shm.unlink()\n</code></pre> <p>The <code>shared_memory_standalone.py</code> script creates an environment using the initialization function from <code>getting_started.py</code>.</p> <p><code>shared_memory_standalone.py</code> <pre><code>from multiprocessing import shared_memory\nimport numpy as np\n\nimport getting_started\n\n# Create a Conda environment from getting_started.py\nimage_path, env = getting_started.initialize()\n</code></pre></p> <p>Then, it imports <code>shared_memory_standalone_module.py</code> to perform a <code>cellpose</code> segmentation, and creates a shared memory for the resulting masks.</p> <pre><code># Import shared_memory_module in the environment\nshared_memory_module = env.import_module(\"shared_memory_standalone_module.py\")\n# run env.execute(module_name, function_name, args)\nmasks_shape, masks_dtype, shm_name = shared_memory_module.segment(image_path)\n</code></pre> <p>This shared memory can now be used in the main process, for example to save the masks as a numpy binary file: Note that the created numpy array uses the shared memory buffer, so it will be freed when the shared memory will be unlinked. Accessing the array once the shared memory is unlinked will cause a segmentation fault.</p> <pre><code># Save the segmentation from the shared memory\nshm = shared_memory.SharedMemory(name=shm_name)\n# Unregister since it will be unlinked in the shm.close() call\ntry:\n    resource_tracker.unregister(shm._name, \"shared_memory\")  # type: ignore\nexcept Exception:\n    pass  # Silently ignore if unregister fails\n\n# Or use track=False with python&gt;3.13\n# shm = shared_memory.SharedMemory(name=shm_name, track=False)\n\n# This create a numpy array from the shared memory buffer (no data copy)\nmasks = np.ndarray(masks_shape, dtype=masks_dtype, buffer=shm.buf)\nsegmentation_path = image_path.parent / f\"{image_path.stem}_segmentation.bin\"\nmasks.tofile(segmentation_path)\n\n# Clean up the shared memory in this process\nshm.close()\n\n# Clean up the shared memory in the other process\nshared_memory_module.clean()\n# Warning: now masks is free, so print(masks[0]) creates a segmentation fault!\n\n# Clean up and exit the environment\nenv.exit()\n</code></pre> <p>Note</p> <p>When a process attaches to an existing SharedMemory object on Python versions before 3.13, the multiprocessing resource_tracker incorrectly registers the shared-memory name as if the process had created it. When the process exits, the tracker will then try to unlink the shared memory, even though it does not own it. This can cause premature deletion, warnings about leaked resources, and FileNotFoundError in the real owner.</p> <p>Calling: </p> <pre><code>`resource_tracker.unregister(shm._name, \"shared_memory\")`\n</code></pre> <p>removes the child\u2019s false registration so it will not attempt to unlink the shared memory at shutdown. On Python 3.13+, this is no longer necessary because you can use:</p> <pre><code>`SharedMemory(name=..., track=False)`\n</code></pre> <p>which prevents the resource from being tracked in the first place.</p> <p>Note</p> <p>Changes to the shared memory made by one process will be refelcted in the other process. You can update the memory from both processes and perform more sofisticated operations.</p>"},{"location":"shared_memory/#ndarray-examples","title":"NDArray examples","text":"<p>This requires to install Wetlands in the external environment.</p> <p>NDArray is a helper class that: - Stores a NumPy array backed by a SharedMemory block. - On pickling, becomes a small JSON-serializable dict <code>{\"name\": shm.name, \"shape\": ..., \"dtype\": ...}</code>. - On unpickling, automatically recreates the NDArray instance and re-attaches to the shared memory buffer. - It can also be initialized with a shape and a dtype, in which case the underlying numpy array will be created on demand (when accessing the <code>NDArray.array</code> property) but not initialized!</p> <p>Always initialize the values!</p> <p>When initialized with a shape and a dtype, the values of the numpy array will be UNDEFINED! you MUST set <code>array.fill(0)</code> or <code>array[:] = otherArray</code> before using it.</p> <p>Copy the array before unlinking!</p> <p>When initialized with a shape and a dtype, or when unpickled, the numpy array is made from the shared memory buffer! This means that the numpy array is freed when the shared memory is unlinked; accessing it will cause a segmentation fault!</p>"},{"location":"shared_memory/#return-the-shared-memory","title":"Return the shared memory","text":"<p>The equivalent example with the NDArray helper is pretty straight-forward:</p> <p><code>shared_memory_return_ndarray.py</code>: <pre><code>from wetlands.ndarray import NDArray\n\nimport getting_started\n\n# Create a Conda environment from getting_started.py\nimage_path, env = getting_started.initialize([\"wetlands&gt;=0.4.1\"])\n\n# Import shared_memory_module in the environment\nshared_memory_module = env.import_module(\"shared_memory_return_ndarray_module.py\")\n\n# run env.execute(module_name, function_name, args)\nmasks_ndarray: NDArray = shared_memory_module.segment(str(image_path), return_segmentation=True)\n\n# Save the segmentation from the shared memory\nsegmentation_path = image_path.parent / f\"{image_path.stem}_segmentation.bin\"\nmasks_ndarray.array.tofile(segmentation_path)\n\n# Clean up the shared memory in this process\nmasks_ndarray.close()\n\n# Clean up the shared memory in the other process\nshared_memory_module.clean()\n# Warning: masks_ndarray.array is now freed, do not access it\n# masks_ndarray.array[0] causes a segmentation fault\n\n# Clean up and exit the environment\nenv.exit()\n</code></pre></p> <p>And <code>shared_memory_return_ndarray_module.py</code>: <pre><code>from pathlib import Path\nfrom wetlands.ndarray import NDArray\n\nimport example_module\n\nndarray: NDArray | None = None\n\n\ndef segment(image_path: Path | str):\n    global ndarray\n    # Segment the image with example_module.py\n    masks = example_module.segment(image_path, return_segmentation=True)\n\n    # Create and return shared memory from masks\n    ndarray = NDArray(masks)\n    return ndarray\n\n\ndef clean():\n    global ndarray\n    if ndarray is None:\n        return\n    ndarray.dispose()\n    ndarray = None\n</code></pre></p>"},{"location":"shared_memory/#provide-the-shared-memory","title":"Provide the shared memory","text":"<p>You can also provide the shared memory objects, which can be a bit easier:</p> <p><code>shared_memory_provide_ndarrays.py</code>: <pre><code>from wetlands.ndarray import NDArray\n\nimport imageio  # type: ignore\nimport getting_started\n\n# Create a Conda environment from getting_started.py\nimage_path, env = getting_started.initialize([\"wetlands&gt;=0.4.1\"])\n\n# Import shared_memory_module in the environment\nshared_memory_module = env.import_module(\"shared_memory_provide_ndarrays_module.py\")\n\n# Open the image (requires imageio)\nimage = imageio.imread(image_path)  # type: ignore\n\n# Creates the shared memory in a context to close and unlink it automatically\nwith (\n    NDArray(image) as ndimage,\n    NDArray(shape=image.shape[:2], dtype=\"uint8\") as ndsegmentation,\n):\n    # run env.execute(module_name, function_name, args)\n    shared_memory_module.segment(ndimage, ndsegmentation)\n\n    # Save the segmentation from the shared memory\n    segmentation_path = image_path.parent / f\"{image_path.stem}_segmentation.bin\"\n    ndsegmentation.array.tofile(segmentation_path)\n\n# Clean up and exit the environment\nenv.exit()\n</code></pre></p> <p>And <code>shared_memory_provide_ndarrays_module.py</code>: <pre><code>from wetlands.ndarray import NDArray\nimport example_module\n\n\ndef segment(image: NDArray, segmentation: NDArray):\n    masks, _, _, _ = example_module.segment_image(image.array)\n    segmentation.array[:] = masks[:]\n    # Close shared memories so that they can be freed on the other side\n    image.close()\n    segmentation.close()\n</code></pre></p> <p>Note that the memory is allocated in the parent process and filled in the child process. There is no duplication of data for the segmentation.</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>Environment manager</li> <li>Environment</li> <li>Internal environment</li> <li>External environment</li> <li>internal<ul> <li>Command executor</li> <li>Command generator</li> <li>Config parser</li> <li>Dependency manager</li> <li>Exceptions</li> <li>Install</li> <li>Process logger</li> <li>Settings manager</li> </ul> </li> </ul>"},{"location":"reference/wetlands/environment/","title":"Environment","text":""},{"location":"reference/wetlands/environment/#wetlands.environment.Environment","title":"<code>Environment</code>","text":"<p>Methods:</p> Name Description <code>import_module</code> <p>Imports the given module (if necessary) and returns a fake module object</p> <code>install</code> <p>Installs dependencies.</p> <code>launch</code> <p>Launch the environment, only available in ExternalEnvironment. Do nothing when InternalEnvironment. See <code>ExternalEnvironment.launch</code></p> <code>execute_commands</code> <p>Executes the given commands in this environment.</p> <code>execute</code> <p>Execute the given function in the given module. See <code>ExternalEnvironment.execute</code> and <code>InternalEnvironment.execute</code></p> <code>launched</code> <p>Check if the environment is launched, important in ExternalEnvironment</p> <code>exit</code> <p>Exit the environment</p> <code>delete</code> <p>Delete this environment. Only available in ExternalEnvironment.</p> <code>update</code> <p>Update this environment with new dependencies. Only available in ExternalEnvironment.</p> Source code in <code>wetlands/environment.py</code> <pre><code>class Environment:\n    modules: dict[str, ModuleType] = {}\n\n    def __init__(self, name: str, path: Path | None, environment_manager: \"EnvironmentManager\") -&gt; None:\n        self.name = name\n        self.path = path.resolve() if isinstance(path, Path) else path\n        self.environment_manager = environment_manager\n\n    def _is_mod_function(self, mod, func):\n        \"\"\"Checks that func is a function defined in module mod\"\"\"\n        return inspect.isfunction(func) and inspect.getmodule(func) == mod\n\n    def _list_functions(self, mod):\n        \"\"\"Returns the list of functions defined in module mod\"\"\"\n        return [func.__name__ for func in mod.__dict__.values() if self._is_mod_function(mod, func)]\n\n    def _import_module(self, module_path: Path | str):\n        \"\"\"Imports the given module (if necessary) and adds it to the module map.\"\"\"\n        module_path = Path(module_path)\n        module = module_path.stem\n        if module not in self.modules:\n            sys.path.append(str(module_path.parent))\n            self.modules[module] = import_module(module)\n        return self.modules[module]\n\n    def import_module(self, module_path: Path | str) -&gt; Any:\n        \"\"\"Imports the given module (if necessary) and returns a fake module object\n        that contains the same methods of the module which will be executed within the environment.\"\"\"\n        module = self._import_module(module_path)\n\n        class FakeModule:\n            pass\n\n        for f in self._list_functions(module):\n\n            def fake_function(*args, _wetlands_imported_function=f, **kwargs):\n                return self.execute(module_path, _wetlands_imported_function, args, kwargs)\n\n            setattr(FakeModule, f, fake_function)\n        return FakeModule\n\n    def install(self, dependencies: Dependencies, additional_install_commands: Commands = {}) -&gt; list[str]:\n        \"\"\"Installs dependencies.\n        See [`EnvironmentManager.create`][wetlands.environment_manager.EnvironmentManager.create] for more details on the ``dependencies`` and ``additional_install_commands`` parameters.\n\n        Args:\n                dependencies: Dependencies to install.\n                additional_install_commands: Platform-specific commands during installation.\n        Returns:\n                Output lines of the installation commands.\n        \"\"\"\n        return self.environment_manager.install(self, dependencies, additional_install_commands)\n\n    def launch(self, additional_activate_commands: Commands = {}) -&gt; None:\n        \"\"\"Launch the environment, only available in [ExternalEnvironment][wetlands.external_environment.ExternalEnvironment]. Do nothing when InternalEnvironment. See [`ExternalEnvironment.launch`][wetlands.external_environment.ExternalEnvironment.launch]\"\"\"\n        return\n\n    def execute_commands(\n        self,\n        commands: Commands,\n        additional_activate_commands: Commands = {},\n        popen_kwargs: dict[str, Any] = {},\n        wait: bool = False,\n        log_context: dict[str, Any] | None = None,\n        log: bool = True,\n    ) -&gt; subprocess.Popen:\n        \"\"\"Executes the given commands in this environment.\n\n        Args:\n                commands: The commands to execute in the environment.\n                additional_activate_commands: Platform-specific activation commands.\n                popen_kwargs: Keyword arguments for subprocess.Popen(). See [`EnvironmentManager.execute_commands`][wetlands.environment_manager.EnvironmentManager.execute_commands].\n                wait: Whether to wait for the process to complete before returning.\n                log_context: Optional context dict to attach to logs via ProcessLogger.\n                log: Whether to log the process output.\n\n        Returns:\n                The launched process.\n        \"\"\"\n        return self.environment_manager.execute_commands(\n            self, commands, additional_activate_commands, popen_kwargs, wait=wait, log_context=log_context, log=log\n        )\n\n    @abstractmethod\n    def execute(self, module_path: str | Path, function: str, args: tuple = (), kwargs: dict[str, Any] = {}) -&gt; Any:\n        \"\"\"Execute the given function in the given module. See [`ExternalEnvironment.execute`][wetlands.external_environment.ExternalEnvironment.execute] and [`InternalEnvironment.execute`][wetlands.internal_environment.InternalEnvironment.execute]\"\"\"\n        pass\n\n    def _exit(self) -&gt; None:\n        \"\"\"Exit the environment, important in ExternalEnvironment\"\"\"\n        pass\n\n    def launched(self) -&gt; bool:\n        \"\"\"Check if the environment is launched, important in ExternalEnvironment\"\"\"\n        return True\n\n    def exit(self) -&gt; None:\n        \"\"\"Exit the environment\"\"\"\n        self._exit()\n        self.environment_manager._remove_environment(self)\n\n    def delete(self) -&gt; None:\n        \"\"\"Delete this environment. Only available in ExternalEnvironment.\"\"\"\n        raise NotImplementedError(\"delete() is only available in ExternalEnvironment\")\n\n    def update(\n        self,\n        dependencies: Union[Dependencies, None] = None,\n        additional_install_commands: Commands = {},\n        use_existing: bool = False,\n    ) -&gt; \"Environment\":\n        \"\"\"Update this environment with new dependencies. Only available in ExternalEnvironment.\"\"\"\n        raise NotImplementedError(\"update() in ExternalEnvironment\")\n</code></pre>"},{"location":"reference/wetlands/environment/#wetlands.environment.Environment.import_module","title":"<code>import_module(module_path)</code>","text":"<p>Imports the given module (if necessary) and returns a fake module object that contains the same methods of the module which will be executed within the environment.</p> Source code in <code>wetlands/environment.py</code> <pre><code>def import_module(self, module_path: Path | str) -&gt; Any:\n    \"\"\"Imports the given module (if necessary) and returns a fake module object\n    that contains the same methods of the module which will be executed within the environment.\"\"\"\n    module = self._import_module(module_path)\n\n    class FakeModule:\n        pass\n\n    for f in self._list_functions(module):\n\n        def fake_function(*args, _wetlands_imported_function=f, **kwargs):\n            return self.execute(module_path, _wetlands_imported_function, args, kwargs)\n\n        setattr(FakeModule, f, fake_function)\n    return FakeModule\n</code></pre>"},{"location":"reference/wetlands/environment/#wetlands.environment.Environment.install","title":"<code>install(dependencies, additional_install_commands={})</code>","text":"<p>Installs dependencies. See <code>EnvironmentManager.create</code> for more details on the <code>dependencies</code> and <code>additional_install_commands</code> parameters.</p> <p>Parameters:</p> Name Type Description Default <code>dependencies</code> <code>Dependencies</code> <p>Dependencies to install.</p> required <code>additional_install_commands</code> <code>Commands</code> <p>Platform-specific commands during installation.</p> <code>{}</code> <p>Returns:         Output lines of the installation commands.</p> Source code in <code>wetlands/environment.py</code> <pre><code>def install(self, dependencies: Dependencies, additional_install_commands: Commands = {}) -&gt; list[str]:\n    \"\"\"Installs dependencies.\n    See [`EnvironmentManager.create`][wetlands.environment_manager.EnvironmentManager.create] for more details on the ``dependencies`` and ``additional_install_commands`` parameters.\n\n    Args:\n            dependencies: Dependencies to install.\n            additional_install_commands: Platform-specific commands during installation.\n    Returns:\n            Output lines of the installation commands.\n    \"\"\"\n    return self.environment_manager.install(self, dependencies, additional_install_commands)\n</code></pre>"},{"location":"reference/wetlands/environment/#wetlands.environment.Environment.launch","title":"<code>launch(additional_activate_commands={})</code>","text":"<p>Launch the environment, only available in ExternalEnvironment. Do nothing when InternalEnvironment. See <code>ExternalEnvironment.launch</code></p> Source code in <code>wetlands/environment.py</code> <pre><code>def launch(self, additional_activate_commands: Commands = {}) -&gt; None:\n    \"\"\"Launch the environment, only available in [ExternalEnvironment][wetlands.external_environment.ExternalEnvironment]. Do nothing when InternalEnvironment. See [`ExternalEnvironment.launch`][wetlands.external_environment.ExternalEnvironment.launch]\"\"\"\n    return\n</code></pre>"},{"location":"reference/wetlands/environment/#wetlands.environment.Environment.execute_commands","title":"<code>execute_commands(commands, additional_activate_commands={}, popen_kwargs={}, wait=False, log_context=None, log=True)</code>","text":"<p>Executes the given commands in this environment.</p> <p>Parameters:</p> Name Type Description Default <code>commands</code> <code>Commands</code> <p>The commands to execute in the environment.</p> required <code>additional_activate_commands</code> <code>Commands</code> <p>Platform-specific activation commands.</p> <code>{}</code> <code>popen_kwargs</code> <code>dict[str, Any]</code> <p>Keyword arguments for subprocess.Popen(). See <code>EnvironmentManager.execute_commands</code>.</p> <code>{}</code> <code>wait</code> <code>bool</code> <p>Whether to wait for the process to complete before returning.</p> <code>False</code> <code>log_context</code> <code>dict[str, Any] | None</code> <p>Optional context dict to attach to logs via ProcessLogger.</p> <code>None</code> <code>log</code> <code>bool</code> <p>Whether to log the process output.</p> <code>True</code> <p>Returns:</p> Type Description <code>Popen</code> <p>The launched process.</p> Source code in <code>wetlands/environment.py</code> <pre><code>def execute_commands(\n    self,\n    commands: Commands,\n    additional_activate_commands: Commands = {},\n    popen_kwargs: dict[str, Any] = {},\n    wait: bool = False,\n    log_context: dict[str, Any] | None = None,\n    log: bool = True,\n) -&gt; subprocess.Popen:\n    \"\"\"Executes the given commands in this environment.\n\n    Args:\n            commands: The commands to execute in the environment.\n            additional_activate_commands: Platform-specific activation commands.\n            popen_kwargs: Keyword arguments for subprocess.Popen(). See [`EnvironmentManager.execute_commands`][wetlands.environment_manager.EnvironmentManager.execute_commands].\n            wait: Whether to wait for the process to complete before returning.\n            log_context: Optional context dict to attach to logs via ProcessLogger.\n            log: Whether to log the process output.\n\n    Returns:\n            The launched process.\n    \"\"\"\n    return self.environment_manager.execute_commands(\n        self, commands, additional_activate_commands, popen_kwargs, wait=wait, log_context=log_context, log=log\n    )\n</code></pre>"},{"location":"reference/wetlands/environment/#wetlands.environment.Environment.execute","title":"<code>execute(module_path, function, args=(), kwargs={})</code>  <code>abstractmethod</code>","text":"<p>Execute the given function in the given module. See <code>ExternalEnvironment.execute</code> and <code>InternalEnvironment.execute</code></p> Source code in <code>wetlands/environment.py</code> <pre><code>@abstractmethod\ndef execute(self, module_path: str | Path, function: str, args: tuple = (), kwargs: dict[str, Any] = {}) -&gt; Any:\n    \"\"\"Execute the given function in the given module. See [`ExternalEnvironment.execute`][wetlands.external_environment.ExternalEnvironment.execute] and [`InternalEnvironment.execute`][wetlands.internal_environment.InternalEnvironment.execute]\"\"\"\n    pass\n</code></pre>"},{"location":"reference/wetlands/environment/#wetlands.environment.Environment.launched","title":"<code>launched()</code>","text":"<p>Check if the environment is launched, important in ExternalEnvironment</p> Source code in <code>wetlands/environment.py</code> <pre><code>def launched(self) -&gt; bool:\n    \"\"\"Check if the environment is launched, important in ExternalEnvironment\"\"\"\n    return True\n</code></pre>"},{"location":"reference/wetlands/environment/#wetlands.environment.Environment.exit","title":"<code>exit()</code>","text":"<p>Exit the environment</p> Source code in <code>wetlands/environment.py</code> <pre><code>def exit(self) -&gt; None:\n    \"\"\"Exit the environment\"\"\"\n    self._exit()\n    self.environment_manager._remove_environment(self)\n</code></pre>"},{"location":"reference/wetlands/environment/#wetlands.environment.Environment.delete","title":"<code>delete()</code>","text":"<p>Delete this environment. Only available in ExternalEnvironment.</p> Source code in <code>wetlands/environment.py</code> <pre><code>def delete(self) -&gt; None:\n    \"\"\"Delete this environment. Only available in ExternalEnvironment.\"\"\"\n    raise NotImplementedError(\"delete() is only available in ExternalEnvironment\")\n</code></pre>"},{"location":"reference/wetlands/environment/#wetlands.environment.Environment.update","title":"<code>update(dependencies=None, additional_install_commands={}, use_existing=False)</code>","text":"<p>Update this environment with new dependencies. Only available in ExternalEnvironment.</p> Source code in <code>wetlands/environment.py</code> <pre><code>def update(\n    self,\n    dependencies: Union[Dependencies, None] = None,\n    additional_install_commands: Commands = {},\n    use_existing: bool = False,\n) -&gt; \"Environment\":\n    \"\"\"Update this environment with new dependencies. Only available in ExternalEnvironment.\"\"\"\n    raise NotImplementedError(\"update() in ExternalEnvironment\")\n</code></pre>"},{"location":"reference/wetlands/environment_manager/","title":"Environment manager","text":""},{"location":"reference/wetlands/environment_manager/#wetlands.environment_manager.EnvironmentManager","title":"<code>EnvironmentManager</code>","text":"<p>Manages Conda environments using micromamba for isolation and dependency management.</p> <p>Attributes:</p> Name Type Description <code>main_environment</code> <code>InternalEnvironment</code> <p>The main conda environment in which wetlands is installed.</p> <code>environments</code> <code>dict[str | Path, Environment]</code> <p>map of the environments</p> <code>settings_manager</code> <p>SettingsManager(conda_path)</p> <code>command_generator</code> <p>CommandGenerator(settings_manager)</p> <code>dependency_manager</code> <p>DependencyManager(command_generator)</p> <code>command_executor</code> <p>CommandExecutor()</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Initializes the EnvironmentManager.</p> <code>install_conda</code> <p>Install Pixi or Micromamba (depending on settings_manager.use_pixi)</p> <code>set_conda_path</code> <p>Updates the micromamba path and loads proxy settings if exists.</p> <code>set_proxies</code> <p>Configures proxy settings for Conda operations.</p> <code>get_installed_packages</code> <p>Get the list of the packages installed in the environment</p> <code>environment_exists</code> <p>Checks if a Conda environment exists.</p> <code>create</code> <p>Creates a new Conda environment with specified dependencies or returns an existing one.</p> <code>create_from_config</code> <p>Creates a new Conda environment from a config file (pixi.toml, pyproject.toml, environment.yml, or requirements.txt) or returns an existing one.</p> <code>load</code> <p>Load an existing Conda environment from disk.</p> <code>install</code> <p>Installs dependencies.</p> <code>execute_commands</code> <p>Executes the given commands in the given environment.</p> <code>get_process_logger</code> <p>Get a ProcessLogger for the given process.</p> <code>register_environment</code> <p>Register the environment (save its debug port to <code>wetlands_instance_path / debug_ports.json</code>) so that it can be debugged later.</p> <code>exit</code> <p>Exit all environments</p> Source code in <code>wetlands/environment_manager.py</code> <pre><code>class EnvironmentManager:\n    \"\"\"Manages Conda environments using micromamba for isolation and dependency management.\n\n    Attributes:\n            main_environment: The main conda environment in which wetlands is installed.\n            environments: map of the environments\n\n            settings_manager: SettingsManager(conda_path)\n            command_generator: CommandGenerator(settings_manager)\n            dependency_manager: DependencyManager(command_generator)\n            command_executor: CommandExecutor()\n    \"\"\"\n\n    main_environment: InternalEnvironment\n    wetlands_instance_path: Path\n    debug: bool\n\n    def __init__(\n        self,\n        wetlands_instance_path: Path = Path(\"wetlands\"),\n        conda_path: str | Path | None = None,\n        main_conda_environment_path: Path | None = None,\n        debug: bool = False,\n        manager=\"auto\",\n        log_file_path=Path(\"wetlands.log\"),\n    ) -&gt; None:\n        \"\"\"Initializes the EnvironmentManager.\n\n        The wetlands_instance_path directory will contain:\n        - logs (managed by logger.py)\n        - debug_ports.json (for debug port tracking)\n        - conda installation (by default at wetlands_instance_path / \"pixi\" or \"micromamba\")\n\n        Args:\n                wetlands_instance_path: Path to the folder which will contain the state of this wetlands instance (logs, debug ports stored in debug_ports.json, and conda installation). Defaults to \"wetlands\".\n                conda_path: Path to the micromamba or pixi installation path. If None, defaults to wetlands_instance_path / \"pixi\". Warning: cannot contain any space character on Windows when using micromamba.\n                main_conda_environment_path: Path of the main conda environment in which Wetlands is installed, used to check whether it is necessary to create new environments (only when dependencies are not already available in the main environment). When using Pixi, this must point to the pixi.toml or pyproject.toml file.\n                debug: When true, processes will listen to debugpy ( debugpy.listen(0) ) to enable debugging, and their ports will be sorted in  wetlands_instance_path / debug_ports.json\n                manager: Use \"pixi\" to use Pixi as the conda manager, \"micromamba\" to use Micromamba and \"auto\" to infer from conda_path (will look for \"pixi\" or \"micromamba\" in the path).\n                log_file_path: Path to the log file where logs will be stored. Use relative path to wetlands_instance_path, or absolute path. Set to None to disable file logging.\n        \"\"\"\n\n        self.environments: dict[str | Path, Environment] = {}\n        self.wetlands_instance_path = cast(Path, wetlands_instance_path).resolve()\n\n        # Set default conda_path if not provided\n        if conda_path is None:\n            conda_path = self.wetlands_instance_path / \"pixi\"\n\n        conda_path = Path(conda_path)\n\n        # Initialize logger to use the wetlands_instance_path for logs\n        if log_file_path is not None:\n            enable_file_logging(\n                log_file_path if log_file_path.is_absolute() else self.wetlands_instance_path / log_file_path\n            )\n\n        use_pixi = self._init_manager(manager, conda_path)\n\n        if platform.system() == \"Windows\" and (not use_pixi) and \" \" in str(conda_path) and not conda_path.exists():\n            raise Exception(\n                f'The Micromamba path cannot contain any space character on Windows (given path is \"{conda_path}\").'\n            )\n\n        self.main_environment = InternalEnvironment(\"wetlands_main\", main_conda_environment_path, self)\n        self.environments[\"wetlands_main\"] = self.main_environment\n        self.settings_manager = SettingsManager(conda_path, use_pixi)\n        self.debug = debug\n        self.install_conda()\n        self.command_generator = CommandGenerator(self.settings_manager)\n        self.dependency_manager = DependencyManager(self.command_generator)\n        self.command_executor = CommandExecutor(self.wetlands_instance_path / \"command_executions\" if debug else None)\n\n        if log_file_path is not None:\n            logger.info(\"Wetlands initialized at %s\", str(self.wetlands_instance_path))\n\n    def _init_manager(self, manager: str, conda_path: Path) -&gt; bool:\n        if manager not in [\"auto\", \"pixi\", \"micromamba\"]:\n            raise Exception(f'Invalid manager \"{manager}\", must be \"auto\", \"pixi\" or \"micromamba\".')\n        if manager == \"auto\":\n            if \"pixi\" in str(conda_path).lower():\n                use_pixi = True\n            elif \"micromamba\" in str(conda_path).lower():\n                use_pixi = False\n            else:\n                raise Exception(\n                    'When using manager=\"auto\", the conda_path must contain either \"pixi\" or \"micromamba\" to infer the manager to use.'\n                )\n        elif manager == \"pixi\":\n            use_pixi = True\n        else:\n            use_pixi = False\n        return use_pixi\n\n    def install_conda(self):\n        \"\"\"Install Pixi or Micromamba (depending on settings_manager.use_pixi)\"\"\"\n\n        conda_path, conda_bin_path = self.settings_manager.get_conda_paths()\n        if (conda_path / conda_bin_path).exists():\n            return []\n\n        conda_path.mkdir(exist_ok=True, parents=True)\n\n        if self.settings_manager.use_pixi:\n            installPixi(conda_path, proxies=self.settings_manager.proxies)\n        else:\n            installMicromamba(conda_path, proxies=self.settings_manager.proxies)\n        return\n\n    def set_conda_path(self, conda_path: str | Path, use_pixi: bool = True) -&gt; None:\n        \"\"\"Updates the micromamba path and loads proxy settings if exists.\n\n        Args:\n                conda_path: New path to micromamba binary.\n                use_pixi: Whether to use Pixi or Micromamba\n\n        Side Effects:\n                Updates self.settings_manager.conda_bin_config, and self.settings_manager.proxies from the .mambarc file.\n        \"\"\"\n        self.settings_manager.set_conda_path(conda_path, use_pixi)\n\n    def set_proxies(self, proxies: dict[str, str]) -&gt; None:\n        \"\"\"Configures proxy settings for Conda operations.\n\n        Args:\n                proxies: Proxy configuration dictionary (e.g., {\"http\": \"...\", \"https\": \"...\"}).\n\n        Side Effects:\n                Updates .mambarc configuration file with proxy settings.\n        \"\"\"\n        self.settings_manager.set_proxies(proxies)\n\n    def _remove_channel(self, conda_dependency: str) -&gt; str:\n        \"\"\"Removes channel prefix from a Conda dependency string (e.g., \"channel::package\" -&gt; \"package\").\"\"\"\n        return conda_dependency.split(\"::\")[1] if \"::\" in conda_dependency else conda_dependency\n\n    def get_installed_packages(self, environment: Environment) -&gt; list[dict[str, str]]:\n        \"\"\"Get the list of the packages installed in the environment\n\n        Args:\n                environment: The environment name.\n\n        Returns:\n                A list of dict containing the installed packages [{\"kind\":\"conda|pypi\", \"name\": \"numpy\", \"version\", \"2.1.3\"}, ...].\n        \"\"\"\n        if self.settings_manager.use_pixi:\n            commands = self.command_generator.get_activate_conda_commands()\n            commands += [f'{self.settings_manager.conda_bin} list --json --manifest-path \"{environment.path}\"']\n            return self.command_executor.execute_commands_and_get_json_output(commands)\n        else:\n            commands = self.command_generator.get_activate_environment_commands(environment) + [\n                f\"{self.settings_manager.conda_bin} list --json\",\n            ]\n            packages = self.command_executor.execute_commands_and_get_json_output(commands)\n            for package in packages:\n                package[\"kind\"] = \"conda\"\n\n            commands = self.command_generator.get_activate_environment_commands(environment) + [\n                f\"pip freeze --all\",\n            ]\n            output = self.command_executor.execute_commands_and_get_output(commands)\n            parsed_output = [o.split(\"==\") for o in output if \"==\" in o]\n            packages += [{\"name\": name, \"version\": version, \"kind\": \"pypi\"} for name, version in parsed_output]\n            return packages\n\n    def _check_requirement(\n        self, dependency: str, package_manager: Literal[\"pip\", \"conda\"], installed_packages: list[dict[str, str]]\n    ) -&gt; bool:\n        \"\"\"Check if dependency is installed (exists in installed_packages).\n\n        Supports PEP 440 version specifiers like:\n        - \"numpy\" (any version)\n        - \"numpy==1.20.0\" (exact version)\n        - \"numpy&gt;=1.20,&lt;2.0\" (version range)\n        - \"numpy~=2.28\" (compatible release)\n        - \"numpy!=1.5.0\" (any except specific version)\n        \"\"\"\n        if package_manager == \"conda\":\n            dependency = self._remove_channel(dependency)\n\n        package_manager_name = \"conda\" if package_manager == \"conda\" else \"pypi\"\n\n        # Parse dependency string to extract package name and version specifier\n        # Package name is followed by optional version specifier (starts with ==, &gt;=, &lt;=, &gt;, &lt;, !=, ~=)\n        match = re.match(r\"^([a-zA-Z0-9._-]+)((?:[&lt;&gt;=!~].*)?)\", dependency)\n        if not match:\n            return False\n\n        package_name = match.group(1)\n        version_spec = match.group(2).strip()\n\n        # Find matching package\n        for package in installed_packages:\n            if package_name != package[\"name\"] or package_manager_name != package[\"kind\"]:\n                continue\n\n            # If no version specified, just match on name\n            if not version_spec:\n                return True\n\n            # Check version against specifier using packaging library\n            try:\n                installed_version = Version(package[\"version\"])\n                specifier_set = SpecifierSet(version_spec)\n                if installed_version in specifier_set:\n                    return True\n            except InvalidVersion:\n                # If version parsing fails, continue to next package\n                continue\n\n        return False\n\n    def _environment_validates_requirements(self, environment: Environment, dependencies: Dependencies) -&gt; bool:\n        \"\"\"Verifies if all specified dependencies are installed in the given environment.\n\n        Applies special handling for main environment with None path (uses metadata.distributions() for pip packages).\n\n        Args:\n                environment: The environment to check.\n                dependencies: Dependencies to verify.\n\n        Returns:\n                True if all dependencies are installed, False otherwise.\n        \"\"\"\n        if not sys.version.startswith(dependencies.get(\"python\", \"\").replace(\"=\", \"\")):\n            return False\n\n        conda_dependencies, condaDependenciesNoDeps, hasCondaDependencies = self.dependency_manager.format_dependencies(\n            \"conda\", dependencies, False, False\n        )\n        pipDependencies, pipDependenciesNoDeps, hasPipDependencies = self.dependency_manager.format_dependencies(\n            \"pip\", dependencies, False, False\n        )\n        if not hasPipDependencies and not hasCondaDependencies:\n            return True\n\n        # Special handling for main environment with None path\n        is_main_environment = environment == self.main_environment\n        if is_main_environment and environment.path is None:\n            if hasCondaDependencies:\n                return False\n            if hasPipDependencies:\n                installed_packages = [\n                    {\"name\": dist.metadata[\"Name\"], \"version\": dist.version, \"kind\": \"pypi\"}\n                    for dist in metadata.distributions()\n                ]\n            else:\n                return True\n        else:\n            # Get installed packages for the environment\n            installed_packages = self.get_installed_packages(environment)\n\n        conda_satisfied = (\n            all(\n                [\n                    self._check_requirement(d, \"conda\", installed_packages)\n                    for d in conda_dependencies + condaDependenciesNoDeps\n                ]\n            )\n            if hasCondaDependencies\n            else True\n        )\n        pip_satisfied = (\n            all(\n                [self._check_requirement(d, \"pip\", installed_packages) for d in pipDependencies + pipDependenciesNoDeps]\n            )\n            if hasPipDependencies\n            else True\n        )\n\n        return conda_satisfied and pip_satisfied\n\n    def environment_exists(self, environment_path: Path) -&gt; bool:\n        \"\"\"Checks if a Conda environment exists.\n\n        Args:\n                environment_path: Environment name to check.\n\n        Returns:\n                True if environment exists, False otherwise.\n        \"\"\"\n        if self.settings_manager.use_pixi:\n            conda_meta = environment_path.parent / \".pixi\" / \"envs\" / \"default\" / \"conda-meta\"\n            return environment_path.is_file() and conda_meta.is_dir()\n        else:\n            conda_meta = environment_path / \"conda-meta\"\n            return conda_meta.is_dir()\n\n    def _add_debugpy_in_dependencies(self, dependencies: Dependencies) -&gt; None:\n        \"\"\"Add debugpy in the dependencies to be able to debug in debug mode. Does nothing when not in debug mode.\n\n        Args:\n                dependencies: Dependencies to install.\n        \"\"\"\n        if not self.debug:\n            return\n        # Check that debugpy is not already in dependencies\n        for package_manager in [\"pip\", \"conda\"]:\n            if package_manager in dependencies:\n                for dep in dependencies[package_manager]:\n                    import re\n\n                    pattern = r\"debugpy(?==|$)\"\n                    if isinstance(dep, str):\n                        if bool(re.search(pattern, dep)):\n                            return\n                    elif dep[\"name\"] == \"debugpy\":\n                        return\n        # Add debugpy without version because we need one compatible with the required python version\n        # Use conda (conda forge) since there are more versions available (especially for python 3.9 on macOS arm64)\n        debugpy = \"debugpy\"\n        if \"conda\" in dependencies:\n            dependencies[\"conda\"].append(debugpy)\n        else:\n            dependencies[\"conda\"] = [debugpy]\n        return\n\n    def _parse_dependencies_from_config(\n        self,\n        config_path: Union[str, Path],\n        environment_name: str | None = None,\n        optional_dependencies: list[str] | None = None,\n    ) -&gt; Dependencies:\n        \"\"\"Parse dependencies from a config file (pixi.toml, pyproject.toml, or environment.yml).\n\n        Args:\n                config_path: Path to configuration file\n                environment_name: Environment name for pixi/pyproject configs\n                optional_dependencies: Optional dependency groups for pyproject configs\n\n        Returns:\n                Dependencies dict\n\n        Raises:\n                FileNotFoundError: If config file doesn't exist\n                ValueError: If config format is invalid or parameters are missing\n        \"\"\"\n        config_path = Path(config_path)\n        parser = ConfigParser()\n\n        # Detect and validate config file type\n        try:\n            file_type = parser.detect_config_file_type(config_path)\n        except ValueError as e:\n            raise ValueError(f\"Unsupported config file: {e}\")\n\n        # Validate required parameters for specific file types\n        if file_type == \"pixi\" and not environment_name:\n            raise ValueError(\n                f\"environment_name is required for pixi.toml files. \"\n                f\"Please provide the environment name to extract dependencies from.\"\n            )\n\n        if file_type == \"pyproject\" and not environment_name and not optional_dependencies:\n            raise ValueError(\n                f\"For pyproject.toml, provide either environment_name (for pixi config) \"\n                f\"or optional_dependencies (for optional dependency groups).\"\n            )\n\n        # Parse the config file\n        return parser.parse(\n            config_path,\n            environment_name=environment_name,\n            optional_dependencies=optional_dependencies,\n        )\n\n    def create(\n        self,\n        name: str,\n        dependencies: Union[Dependencies, None] = None,\n        additional_install_commands: Commands = {},\n        use_existing: bool = False,\n    ) -&gt; Environment:\n        \"\"\"Creates a new Conda environment with specified dependencies or returns an existing one.\n\n        Args:\n                name: Name for the new environment.\n                dependencies: Dependencies to install. Can be one of:\n                    - A Dependencies dict: dict(python=\"3.12.7\", conda=[\"numpy\"], pip=[\"requests\"])\n                    - None (no dependencies to install)\n                additional_install_commands: Platform-specific commands during installation (e.g. {\"mac\": [\"cd ...\", \"wget https://...\", \"unzip ...\"], \"all\"=[], ...}).\n                use_existing: if True, search through existing environments and return the first one that satisfies the dependencies instead of creating a new one.\n\n        Returns:\n                The created or existing environment (ExternalEnvironment if created, or an existing environment if use_existing=True and match found).\n        \"\"\"\n        if isinstance(name, Path):\n            raise Exception(\n                \"Environment name cannot be a Path, use EnvironmentManager.load() to load an existing environment.\"\n            )\n\n        # Check if environment already exists on disk\n        path = self.settings_manager.get_environment_path_from_name(name)\n        if self.environment_exists(path) and name not in self.environments:\n            logger.log_environment(f\"Loading existing environment '{name}' from '{path}'\", name, stage=\"create\")\n            self.environments[name] = ExternalEnvironment(name, path, self)\n\n        if name in self.environments:\n            logger.debug(f\"Environment '{name}' already exists, returning existing instance.\")\n            return self.environments[name]\n\n        if dependencies is None:\n            dependencies = {}\n        elif not isinstance(dependencies, dict):\n            raise ValueError(f\"Unsupported dependencies type: {type(dependencies)}\")\n\n        self._add_debugpy_in_dependencies(dependencies)\n\n        # Try to find existing environment if use_existing=True\n        if use_existing:\n            envs = [self.main_environment] + [env for env in self.environments.values() if env != self.main_environment]\n            for env in envs:\n                try:\n                    if self._environment_validates_requirements(env, dependencies):\n                        logger.log_environment(\n                            f\"Environment '{env.name}' satisfies dependencies for '{name}', returning it.\",\n                            name,\n                            stage=\"create\",\n                        )\n                        return env\n                except Exception as e:\n                    logger.debug(f\"Error checking environment '{env.name}': {e}\")\n                    continue\n\n        # Create new environment\n        python_version = dependencies.get(\"python\", \"\").replace(\"=\", \"\")\n        match = re.search(r\"(\\d+)\\.(\\d+)\", python_version)\n        if match and (int(match.group(1)) &lt; 3 or int(match.group(2)) &lt; 9):\n            raise Exception(\"Python version must be greater than 3.8\")\n        python_requirement = \" python=\" + (python_version if len(python_version) &gt; 0 else platform.python_version())\n        create_env_commands = self.command_generator.get_activate_conda_commands()\n\n        if self.settings_manager.use_pixi:\n            manifest_path = path\n            if not manifest_path.exists():\n                platform_args = f\"--platform win-64\" if platform.system() == \"Windows\" else \"\"\n                create_env_commands += [\n                    f'{self.settings_manager.conda_bin} init --no-progress {platform_args} \"{manifest_path.parent}\"'\n                ]\n            create_env_commands += [\n                f'{self.settings_manager.conda_bin} add --no-progress --manifest-path \"{manifest_path}\" {python_requirement}'\n            ]\n        else:\n            create_env_commands += [f\"{self.settings_manager.conda_bin_config} create -n {name}{python_requirement} -y\"]\n        environment = ExternalEnvironment(name, path, self)\n        self.environments[name] = environment\n        create_env_commands += self.dependency_manager.get_install_dependencies_commands(environment, dependencies)\n        create_env_commands += self.command_generator.get_commands_for_current_platform(additional_install_commands)\n\n        logger.log_environment(f\"Creating environment '{name}'\", name, stage=\"create\")\n        log_context = {\"log_source\": LOG_SOURCE_ENVIRONMENT, \"env_name\": name, \"stage\": \"install\"}\n        self.command_executor.execute_commands(create_env_commands, wait=True, log_context=log_context)\n        logger.log_environment(f\"Environment '{name}' created successfully\", name, stage=\"create\")\n        return self.environments[name]\n\n    def create_from_config(\n        self,\n        name: str,\n        config_path: str | Path,\n        optional_dependencies: list[str] | None = None,\n        additional_install_commands: Commands = {},\n        use_existing: bool = False,\n    ) -&gt; Environment:\n        \"\"\"Creates a new Conda environment from a config file (pixi.toml, pyproject.toml, environment.yml, or requirements.txt) or returns an existing one.\n\n        Args:\n                name: Name for the new environment.\n                config_path: Path to configuration file (pixi.toml, pyproject.toml, environment.yml, or requirements.txt).\n                optional_dependencies: List of optional dependency groups to extract from pyproject.toml.\n                additional_install_commands: Platform-specific commands during installation.\n                use_existing: if True, search through existing environments and return the first one that satisfies the dependencies instead of creating a new one.\n\n        Returns:\n                The created or existing environment (ExternalEnvironment if created, or an existing environment if use_existing=True and match found).\n        \"\"\"\n\n        # Parse config file\n        dependencies = self._parse_dependencies_from_config(\n            config_path, environment_name=name, optional_dependencies=optional_dependencies\n        )\n\n        # Use create() with parsed dependencies\n        return self.create(name, dependencies, additional_install_commands, use_existing)\n\n    def load(\n        self,\n        name: str,\n        environment_path: Path,\n    ) -&gt; Environment:\n        \"\"\"Load an existing Conda environment from disk.\n\n        Args:\n                name: Name for the environment instance.\n                environment_path: Path to an existing Conda environment, or the folder containing the pixi.toml/pyproject.toml when using Pixi.\n\n        Returns:\n                The loaded environment (ExternalEnvironment if using Pixi or micromamba with a path, InternalEnvironment otherwise).\n\n        Raises:\n                Exception: If the environment does not exist.\n        \"\"\"\n        environment_path = environment_path.resolve()\n\n        if not self.environment_exists(environment_path):\n            raise Exception(f\"The environment {environment_path} was not found.\")\n\n        if name not in self.environments:\n            self.environments[name] = ExternalEnvironment(name, environment_path, self)\n        return self.environments[name]\n\n    def install(\n        self, environment: Environment, dependencies: Dependencies, additional_install_commands: Commands = {}\n    ) -&gt; list[str]:\n        \"\"\"Installs dependencies.\n        See [`EnvironmentManager.create`][wetlands.environment_manager.EnvironmentManager.create] for more details on the ``dependencies`` and ``additional_install_commands`` parameters.\n\n        Args:\n                environment_name: The environment to install dependencies.\n                dependencies: Dependencies to install.\n                additional_install_commands: Platform-specific commands during installation.\n\n        Returns:\n                Output lines of the installation commands.\n        \"\"\"\n        if environment == self.main_environment and self.settings_manager.use_pixi:\n            raise Exception(\"Cannot install packages in an InternalEnvironment when using Pixi.\")\n        if environment == self.main_environment and environment.path is None:\n            raise Exception(\"Cannot install packages in an InternalEnvironment with no conda path.\")\n\n        install_commands = self.dependency_manager.get_install_dependencies_commands(environment, dependencies)\n        install_commands += self.command_generator.get_commands_for_current_platform(additional_install_commands)\n\n        logger.log_environment(\n            f\"Installing dependencies in environment '{environment.name}'\", environment.name, stage=\"install\"\n        )\n        log_context = {\"log_source\": LOG_SOURCE_ENVIRONMENT, \"env_name\": environment.name, \"stage\": \"install\"}\n        return self.command_executor.execute_commands_and_get_output(install_commands, log_context=log_context)\n\n    def execute_commands(\n        self,\n        environment: Environment,\n        commands: Commands,\n        additional_activate_commands: Commands = {},\n        popen_kwargs: dict[str, Any] = {},\n        wait: bool = False,\n        log_context: dict[str, Any] | None = None,\n        log: bool = True,\n    ) -&gt; subprocess.Popen:\n        \"\"\"Executes the given commands in the given environment.\n\n        Args:\n                environment: The environment in which to execute commands.\n                commands: The commands to execute in the environment.\n                additional_activate_commands: Platform-specific activation commands.\n                popen_kwargs: Keyword arguments for subprocess.Popen() (see [Popen documentation](https://docs.python.org/3/library/subprocess.html#popen-constructor)). Defaults are: dict(stdout=subprocess.PIPE, stderr=subprocess.STDOUT, stdin=subprocess.DEVNULL, encoding=\"utf-8\", errors=\"replace\", bufsize=1).\n                log_context: Optional context dict to attach to logs via ProcessLogger.\n                log: Whether to log the process output.\n\n        Returns:\n                The launched process.\n        \"\"\"\n        activate_commands = self.command_generator.get_activate_environment_commands(\n            environment, additional_activate_commands\n        )\n        platform_commands = self.command_generator.get_commands_for_current_platform(commands)\n        return self.command_executor.execute_commands(\n            activate_commands + platform_commands,\n            popen_kwargs=popen_kwargs,\n            wait=wait,\n            log_context=log_context,\n            log=log,\n        )\n\n    def get_process_logger(self, process: subprocess.Popen) -&gt; ProcessLogger:\n        \"\"\"Get a ProcessLogger for the given process.\n\n        Args:\n                process: The process to create a ProcessLogger for.\n        Returns:\n                The created ProcessLogger.\n        \"\"\"\n        return self.command_executor.get_process_logger(process)\n\n    def register_environment(\n        self, environment: ExternalEnvironment, debug_port: int, module_executor_path: Path\n    ) -&gt; None:\n        \"\"\"\n        Register the environment (save its debug port to `wetlands_instance_path / debug_ports.json`) so that it can be debugged later.\n\n        Args:\n                environment: The external environment object to register\n                debug_port: The debug port to save\n        \"\"\"\n        if environment.process is None:\n            return\n        wetlands_debug_ports_path = self.wetlands_instance_path / \"debug_ports.json\"\n        wetlands_debug_ports_path.parent.mkdir(exist_ok=True, parents=True)\n        wetlands_debug_ports = {}\n        try:\n            if wetlands_debug_ports_path.exists():\n                with open(wetlands_debug_ports_path, \"r\") as f:\n                    wetlands_debug_ports = json5.load(f)\n            wetlands_debug_ports[environment.name] = dict(\n                debug_port=debug_port, module_executor_path=module_executor_path.as_posix()\n            )\n            with open(wetlands_debug_ports_path, \"w\") as f:\n                json5.dump(wetlands_debug_ports, f, indent=4, quote_keys=True)\n        except Exception as e:\n            e.add_note(f\"Error while updating the debug ports file {wetlands_debug_ports_path}.\")\n            raise e\n        return\n\n    def _remove_environment(self, environment: Environment) -&gt; None:\n        \"\"\"Remove an environment.\n\n        Args:\n                environment: instance to remove.\n        \"\"\"\n        if environment.name in self.environments:\n            del self.environments[environment.name]\n\n    def exit(self) -&gt; None:\n        \"\"\"Exit all environments\"\"\"\n        for env in list(self.environments.values()):\n            env.exit()\n</code></pre>"},{"location":"reference/wetlands/environment_manager/#wetlands.environment_manager.EnvironmentManager.__init__","title":"<code>__init__(wetlands_instance_path=Path('wetlands'), conda_path=None, main_conda_environment_path=None, debug=False, manager='auto', log_file_path=Path('wetlands.log'))</code>","text":"<p>Initializes the EnvironmentManager.</p> <p>The wetlands_instance_path directory will contain: - logs (managed by logger.py) - debug_ports.json (for debug port tracking) - conda installation (by default at wetlands_instance_path / \"pixi\" or \"micromamba\")</p> <p>Parameters:</p> Name Type Description Default <code>wetlands_instance_path</code> <code>Path</code> <p>Path to the folder which will contain the state of this wetlands instance (logs, debug ports stored in debug_ports.json, and conda installation). Defaults to \"wetlands\".</p> <code>Path('wetlands')</code> <code>conda_path</code> <code>str | Path | None</code> <p>Path to the micromamba or pixi installation path. If None, defaults to wetlands_instance_path / \"pixi\". Warning: cannot contain any space character on Windows when using micromamba.</p> <code>None</code> <code>main_conda_environment_path</code> <code>Path | None</code> <p>Path of the main conda environment in which Wetlands is installed, used to check whether it is necessary to create new environments (only when dependencies are not already available in the main environment). When using Pixi, this must point to the pixi.toml or pyproject.toml file.</p> <code>None</code> <code>debug</code> <code>bool</code> <p>When true, processes will listen to debugpy ( debugpy.listen(0) ) to enable debugging, and their ports will be sorted in  wetlands_instance_path / debug_ports.json</p> <code>False</code> <code>manager</code> <p>Use \"pixi\" to use Pixi as the conda manager, \"micromamba\" to use Micromamba and \"auto\" to infer from conda_path (will look for \"pixi\" or \"micromamba\" in the path).</p> <code>'auto'</code> <code>log_file_path</code> <p>Path to the log file where logs will be stored. Use relative path to wetlands_instance_path, or absolute path. Set to None to disable file logging.</p> <code>Path('wetlands.log')</code> Source code in <code>wetlands/environment_manager.py</code> <pre><code>def __init__(\n    self,\n    wetlands_instance_path: Path = Path(\"wetlands\"),\n    conda_path: str | Path | None = None,\n    main_conda_environment_path: Path | None = None,\n    debug: bool = False,\n    manager=\"auto\",\n    log_file_path=Path(\"wetlands.log\"),\n) -&gt; None:\n    \"\"\"Initializes the EnvironmentManager.\n\n    The wetlands_instance_path directory will contain:\n    - logs (managed by logger.py)\n    - debug_ports.json (for debug port tracking)\n    - conda installation (by default at wetlands_instance_path / \"pixi\" or \"micromamba\")\n\n    Args:\n            wetlands_instance_path: Path to the folder which will contain the state of this wetlands instance (logs, debug ports stored in debug_ports.json, and conda installation). Defaults to \"wetlands\".\n            conda_path: Path to the micromamba or pixi installation path. If None, defaults to wetlands_instance_path / \"pixi\". Warning: cannot contain any space character on Windows when using micromamba.\n            main_conda_environment_path: Path of the main conda environment in which Wetlands is installed, used to check whether it is necessary to create new environments (only when dependencies are not already available in the main environment). When using Pixi, this must point to the pixi.toml or pyproject.toml file.\n            debug: When true, processes will listen to debugpy ( debugpy.listen(0) ) to enable debugging, and their ports will be sorted in  wetlands_instance_path / debug_ports.json\n            manager: Use \"pixi\" to use Pixi as the conda manager, \"micromamba\" to use Micromamba and \"auto\" to infer from conda_path (will look for \"pixi\" or \"micromamba\" in the path).\n            log_file_path: Path to the log file where logs will be stored. Use relative path to wetlands_instance_path, or absolute path. Set to None to disable file logging.\n    \"\"\"\n\n    self.environments: dict[str | Path, Environment] = {}\n    self.wetlands_instance_path = cast(Path, wetlands_instance_path).resolve()\n\n    # Set default conda_path if not provided\n    if conda_path is None:\n        conda_path = self.wetlands_instance_path / \"pixi\"\n\n    conda_path = Path(conda_path)\n\n    # Initialize logger to use the wetlands_instance_path for logs\n    if log_file_path is not None:\n        enable_file_logging(\n            log_file_path if log_file_path.is_absolute() else self.wetlands_instance_path / log_file_path\n        )\n\n    use_pixi = self._init_manager(manager, conda_path)\n\n    if platform.system() == \"Windows\" and (not use_pixi) and \" \" in str(conda_path) and not conda_path.exists():\n        raise Exception(\n            f'The Micromamba path cannot contain any space character on Windows (given path is \"{conda_path}\").'\n        )\n\n    self.main_environment = InternalEnvironment(\"wetlands_main\", main_conda_environment_path, self)\n    self.environments[\"wetlands_main\"] = self.main_environment\n    self.settings_manager = SettingsManager(conda_path, use_pixi)\n    self.debug = debug\n    self.install_conda()\n    self.command_generator = CommandGenerator(self.settings_manager)\n    self.dependency_manager = DependencyManager(self.command_generator)\n    self.command_executor = CommandExecutor(self.wetlands_instance_path / \"command_executions\" if debug else None)\n\n    if log_file_path is not None:\n        logger.info(\"Wetlands initialized at %s\", str(self.wetlands_instance_path))\n</code></pre>"},{"location":"reference/wetlands/environment_manager/#wetlands.environment_manager.EnvironmentManager.install_conda","title":"<code>install_conda()</code>","text":"<p>Install Pixi or Micromamba (depending on settings_manager.use_pixi)</p> Source code in <code>wetlands/environment_manager.py</code> <pre><code>def install_conda(self):\n    \"\"\"Install Pixi or Micromamba (depending on settings_manager.use_pixi)\"\"\"\n\n    conda_path, conda_bin_path = self.settings_manager.get_conda_paths()\n    if (conda_path / conda_bin_path).exists():\n        return []\n\n    conda_path.mkdir(exist_ok=True, parents=True)\n\n    if self.settings_manager.use_pixi:\n        installPixi(conda_path, proxies=self.settings_manager.proxies)\n    else:\n        installMicromamba(conda_path, proxies=self.settings_manager.proxies)\n    return\n</code></pre>"},{"location":"reference/wetlands/environment_manager/#wetlands.environment_manager.EnvironmentManager.set_conda_path","title":"<code>set_conda_path(conda_path, use_pixi=True)</code>","text":"<p>Updates the micromamba path and loads proxy settings if exists.</p> <p>Parameters:</p> Name Type Description Default <code>conda_path</code> <code>str | Path</code> <p>New path to micromamba binary.</p> required <code>use_pixi</code> <code>bool</code> <p>Whether to use Pixi or Micromamba</p> <code>True</code> Side Effects <p>Updates self.settings_manager.conda_bin_config, and self.settings_manager.proxies from the .mambarc file.</p> Source code in <code>wetlands/environment_manager.py</code> <pre><code>def set_conda_path(self, conda_path: str | Path, use_pixi: bool = True) -&gt; None:\n    \"\"\"Updates the micromamba path and loads proxy settings if exists.\n\n    Args:\n            conda_path: New path to micromamba binary.\n            use_pixi: Whether to use Pixi or Micromamba\n\n    Side Effects:\n            Updates self.settings_manager.conda_bin_config, and self.settings_manager.proxies from the .mambarc file.\n    \"\"\"\n    self.settings_manager.set_conda_path(conda_path, use_pixi)\n</code></pre>"},{"location":"reference/wetlands/environment_manager/#wetlands.environment_manager.EnvironmentManager.set_proxies","title":"<code>set_proxies(proxies)</code>","text":"<p>Configures proxy settings for Conda operations.</p> <p>Parameters:</p> Name Type Description Default <code>proxies</code> <code>dict[str, str]</code> <p>Proxy configuration dictionary (e.g., {\"http\": \"...\", \"https\": \"...\"}).</p> required Side Effects <p>Updates .mambarc configuration file with proxy settings.</p> Source code in <code>wetlands/environment_manager.py</code> <pre><code>def set_proxies(self, proxies: dict[str, str]) -&gt; None:\n    \"\"\"Configures proxy settings for Conda operations.\n\n    Args:\n            proxies: Proxy configuration dictionary (e.g., {\"http\": \"...\", \"https\": \"...\"}).\n\n    Side Effects:\n            Updates .mambarc configuration file with proxy settings.\n    \"\"\"\n    self.settings_manager.set_proxies(proxies)\n</code></pre>"},{"location":"reference/wetlands/environment_manager/#wetlands.environment_manager.EnvironmentManager.get_installed_packages","title":"<code>get_installed_packages(environment)</code>","text":"<p>Get the list of the packages installed in the environment</p> <p>Parameters:</p> Name Type Description Default <code>environment</code> <code>Environment</code> <p>The environment name.</p> required <p>Returns:</p> Type Description <code>list[dict[str, str]]</code> <p>A list of dict containing the installed packages [{\"kind\":\"conda|pypi\", \"name\": \"numpy\", \"version\", \"2.1.3\"}, ...].</p> Source code in <code>wetlands/environment_manager.py</code> <pre><code>def get_installed_packages(self, environment: Environment) -&gt; list[dict[str, str]]:\n    \"\"\"Get the list of the packages installed in the environment\n\n    Args:\n            environment: The environment name.\n\n    Returns:\n            A list of dict containing the installed packages [{\"kind\":\"conda|pypi\", \"name\": \"numpy\", \"version\", \"2.1.3\"}, ...].\n    \"\"\"\n    if self.settings_manager.use_pixi:\n        commands = self.command_generator.get_activate_conda_commands()\n        commands += [f'{self.settings_manager.conda_bin} list --json --manifest-path \"{environment.path}\"']\n        return self.command_executor.execute_commands_and_get_json_output(commands)\n    else:\n        commands = self.command_generator.get_activate_environment_commands(environment) + [\n            f\"{self.settings_manager.conda_bin} list --json\",\n        ]\n        packages = self.command_executor.execute_commands_and_get_json_output(commands)\n        for package in packages:\n            package[\"kind\"] = \"conda\"\n\n        commands = self.command_generator.get_activate_environment_commands(environment) + [\n            f\"pip freeze --all\",\n        ]\n        output = self.command_executor.execute_commands_and_get_output(commands)\n        parsed_output = [o.split(\"==\") for o in output if \"==\" in o]\n        packages += [{\"name\": name, \"version\": version, \"kind\": \"pypi\"} for name, version in parsed_output]\n        return packages\n</code></pre>"},{"location":"reference/wetlands/environment_manager/#wetlands.environment_manager.EnvironmentManager.environment_exists","title":"<code>environment_exists(environment_path)</code>","text":"<p>Checks if a Conda environment exists.</p> <p>Parameters:</p> Name Type Description Default <code>environment_path</code> <code>Path</code> <p>Environment name to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if environment exists, False otherwise.</p> Source code in <code>wetlands/environment_manager.py</code> <pre><code>def environment_exists(self, environment_path: Path) -&gt; bool:\n    \"\"\"Checks if a Conda environment exists.\n\n    Args:\n            environment_path: Environment name to check.\n\n    Returns:\n            True if environment exists, False otherwise.\n    \"\"\"\n    if self.settings_manager.use_pixi:\n        conda_meta = environment_path.parent / \".pixi\" / \"envs\" / \"default\" / \"conda-meta\"\n        return environment_path.is_file() and conda_meta.is_dir()\n    else:\n        conda_meta = environment_path / \"conda-meta\"\n        return conda_meta.is_dir()\n</code></pre>"},{"location":"reference/wetlands/environment_manager/#wetlands.environment_manager.EnvironmentManager.create","title":"<code>create(name, dependencies=None, additional_install_commands={}, use_existing=False)</code>","text":"<p>Creates a new Conda environment with specified dependencies or returns an existing one.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name for the new environment.</p> required <code>dependencies</code> <code>Union[Dependencies, None]</code> <p>Dependencies to install. Can be one of: - A Dependencies dict: dict(python=\"3.12.7\", conda=[\"numpy\"], pip=[\"requests\"]) - None (no dependencies to install)</p> <code>None</code> <code>additional_install_commands</code> <code>Commands</code> <p>Platform-specific commands during installation (e.g. {\"mac\": [\"cd ...\", \"wget https://...\", \"unzip ...\"], \"all\"=[], ...}).</p> <code>{}</code> <code>use_existing</code> <code>bool</code> <p>if True, search through existing environments and return the first one that satisfies the dependencies instead of creating a new one.</p> <code>False</code> <p>Returns:</p> Type Description <code>Environment</code> <p>The created or existing environment (ExternalEnvironment if created, or an existing environment if use_existing=True and match found).</p> Source code in <code>wetlands/environment_manager.py</code> <pre><code>def create(\n    self,\n    name: str,\n    dependencies: Union[Dependencies, None] = None,\n    additional_install_commands: Commands = {},\n    use_existing: bool = False,\n) -&gt; Environment:\n    \"\"\"Creates a new Conda environment with specified dependencies or returns an existing one.\n\n    Args:\n            name: Name for the new environment.\n            dependencies: Dependencies to install. Can be one of:\n                - A Dependencies dict: dict(python=\"3.12.7\", conda=[\"numpy\"], pip=[\"requests\"])\n                - None (no dependencies to install)\n            additional_install_commands: Platform-specific commands during installation (e.g. {\"mac\": [\"cd ...\", \"wget https://...\", \"unzip ...\"], \"all\"=[], ...}).\n            use_existing: if True, search through existing environments and return the first one that satisfies the dependencies instead of creating a new one.\n\n    Returns:\n            The created or existing environment (ExternalEnvironment if created, or an existing environment if use_existing=True and match found).\n    \"\"\"\n    if isinstance(name, Path):\n        raise Exception(\n            \"Environment name cannot be a Path, use EnvironmentManager.load() to load an existing environment.\"\n        )\n\n    # Check if environment already exists on disk\n    path = self.settings_manager.get_environment_path_from_name(name)\n    if self.environment_exists(path) and name not in self.environments:\n        logger.log_environment(f\"Loading existing environment '{name}' from '{path}'\", name, stage=\"create\")\n        self.environments[name] = ExternalEnvironment(name, path, self)\n\n    if name in self.environments:\n        logger.debug(f\"Environment '{name}' already exists, returning existing instance.\")\n        return self.environments[name]\n\n    if dependencies is None:\n        dependencies = {}\n    elif not isinstance(dependencies, dict):\n        raise ValueError(f\"Unsupported dependencies type: {type(dependencies)}\")\n\n    self._add_debugpy_in_dependencies(dependencies)\n\n    # Try to find existing environment if use_existing=True\n    if use_existing:\n        envs = [self.main_environment] + [env for env in self.environments.values() if env != self.main_environment]\n        for env in envs:\n            try:\n                if self._environment_validates_requirements(env, dependencies):\n                    logger.log_environment(\n                        f\"Environment '{env.name}' satisfies dependencies for '{name}', returning it.\",\n                        name,\n                        stage=\"create\",\n                    )\n                    return env\n            except Exception as e:\n                logger.debug(f\"Error checking environment '{env.name}': {e}\")\n                continue\n\n    # Create new environment\n    python_version = dependencies.get(\"python\", \"\").replace(\"=\", \"\")\n    match = re.search(r\"(\\d+)\\.(\\d+)\", python_version)\n    if match and (int(match.group(1)) &lt; 3 or int(match.group(2)) &lt; 9):\n        raise Exception(\"Python version must be greater than 3.8\")\n    python_requirement = \" python=\" + (python_version if len(python_version) &gt; 0 else platform.python_version())\n    create_env_commands = self.command_generator.get_activate_conda_commands()\n\n    if self.settings_manager.use_pixi:\n        manifest_path = path\n        if not manifest_path.exists():\n            platform_args = f\"--platform win-64\" if platform.system() == \"Windows\" else \"\"\n            create_env_commands += [\n                f'{self.settings_manager.conda_bin} init --no-progress {platform_args} \"{manifest_path.parent}\"'\n            ]\n        create_env_commands += [\n            f'{self.settings_manager.conda_bin} add --no-progress --manifest-path \"{manifest_path}\" {python_requirement}'\n        ]\n    else:\n        create_env_commands += [f\"{self.settings_manager.conda_bin_config} create -n {name}{python_requirement} -y\"]\n    environment = ExternalEnvironment(name, path, self)\n    self.environments[name] = environment\n    create_env_commands += self.dependency_manager.get_install_dependencies_commands(environment, dependencies)\n    create_env_commands += self.command_generator.get_commands_for_current_platform(additional_install_commands)\n\n    logger.log_environment(f\"Creating environment '{name}'\", name, stage=\"create\")\n    log_context = {\"log_source\": LOG_SOURCE_ENVIRONMENT, \"env_name\": name, \"stage\": \"install\"}\n    self.command_executor.execute_commands(create_env_commands, wait=True, log_context=log_context)\n    logger.log_environment(f\"Environment '{name}' created successfully\", name, stage=\"create\")\n    return self.environments[name]\n</code></pre>"},{"location":"reference/wetlands/environment_manager/#wetlands.environment_manager.EnvironmentManager.create_from_config","title":"<code>create_from_config(name, config_path, optional_dependencies=None, additional_install_commands={}, use_existing=False)</code>","text":"<p>Creates a new Conda environment from a config file (pixi.toml, pyproject.toml, environment.yml, or requirements.txt) or returns an existing one.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name for the new environment.</p> required <code>config_path</code> <code>str | Path</code> <p>Path to configuration file (pixi.toml, pyproject.toml, environment.yml, or requirements.txt).</p> required <code>optional_dependencies</code> <code>list[str] | None</code> <p>List of optional dependency groups to extract from pyproject.toml.</p> <code>None</code> <code>additional_install_commands</code> <code>Commands</code> <p>Platform-specific commands during installation.</p> <code>{}</code> <code>use_existing</code> <code>bool</code> <p>if True, search through existing environments and return the first one that satisfies the dependencies instead of creating a new one.</p> <code>False</code> <p>Returns:</p> Type Description <code>Environment</code> <p>The created or existing environment (ExternalEnvironment if created, or an existing environment if use_existing=True and match found).</p> Source code in <code>wetlands/environment_manager.py</code> <pre><code>def create_from_config(\n    self,\n    name: str,\n    config_path: str | Path,\n    optional_dependencies: list[str] | None = None,\n    additional_install_commands: Commands = {},\n    use_existing: bool = False,\n) -&gt; Environment:\n    \"\"\"Creates a new Conda environment from a config file (pixi.toml, pyproject.toml, environment.yml, or requirements.txt) or returns an existing one.\n\n    Args:\n            name: Name for the new environment.\n            config_path: Path to configuration file (pixi.toml, pyproject.toml, environment.yml, or requirements.txt).\n            optional_dependencies: List of optional dependency groups to extract from pyproject.toml.\n            additional_install_commands: Platform-specific commands during installation.\n            use_existing: if True, search through existing environments and return the first one that satisfies the dependencies instead of creating a new one.\n\n    Returns:\n            The created or existing environment (ExternalEnvironment if created, or an existing environment if use_existing=True and match found).\n    \"\"\"\n\n    # Parse config file\n    dependencies = self._parse_dependencies_from_config(\n        config_path, environment_name=name, optional_dependencies=optional_dependencies\n    )\n\n    # Use create() with parsed dependencies\n    return self.create(name, dependencies, additional_install_commands, use_existing)\n</code></pre>"},{"location":"reference/wetlands/environment_manager/#wetlands.environment_manager.EnvironmentManager.load","title":"<code>load(name, environment_path)</code>","text":"<p>Load an existing Conda environment from disk.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name for the environment instance.</p> required <code>environment_path</code> <code>Path</code> <p>Path to an existing Conda environment, or the folder containing the pixi.toml/pyproject.toml when using Pixi.</p> required <p>Returns:</p> Type Description <code>Environment</code> <p>The loaded environment (ExternalEnvironment if using Pixi or micromamba with a path, InternalEnvironment otherwise).</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the environment does not exist.</p> Source code in <code>wetlands/environment_manager.py</code> <pre><code>def load(\n    self,\n    name: str,\n    environment_path: Path,\n) -&gt; Environment:\n    \"\"\"Load an existing Conda environment from disk.\n\n    Args:\n            name: Name for the environment instance.\n            environment_path: Path to an existing Conda environment, or the folder containing the pixi.toml/pyproject.toml when using Pixi.\n\n    Returns:\n            The loaded environment (ExternalEnvironment if using Pixi or micromamba with a path, InternalEnvironment otherwise).\n\n    Raises:\n            Exception: If the environment does not exist.\n    \"\"\"\n    environment_path = environment_path.resolve()\n\n    if not self.environment_exists(environment_path):\n        raise Exception(f\"The environment {environment_path} was not found.\")\n\n    if name not in self.environments:\n        self.environments[name] = ExternalEnvironment(name, environment_path, self)\n    return self.environments[name]\n</code></pre>"},{"location":"reference/wetlands/environment_manager/#wetlands.environment_manager.EnvironmentManager.install","title":"<code>install(environment, dependencies, additional_install_commands={})</code>","text":"<p>Installs dependencies. See <code>EnvironmentManager.create</code> for more details on the <code>dependencies</code> and <code>additional_install_commands</code> parameters.</p> <p>Parameters:</p> Name Type Description Default <code>environment_name</code> <p>The environment to install dependencies.</p> required <code>dependencies</code> <code>Dependencies</code> <p>Dependencies to install.</p> required <code>additional_install_commands</code> <code>Commands</code> <p>Platform-specific commands during installation.</p> <code>{}</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>Output lines of the installation commands.</p> Source code in <code>wetlands/environment_manager.py</code> <pre><code>def install(\n    self, environment: Environment, dependencies: Dependencies, additional_install_commands: Commands = {}\n) -&gt; list[str]:\n    \"\"\"Installs dependencies.\n    See [`EnvironmentManager.create`][wetlands.environment_manager.EnvironmentManager.create] for more details on the ``dependencies`` and ``additional_install_commands`` parameters.\n\n    Args:\n            environment_name: The environment to install dependencies.\n            dependencies: Dependencies to install.\n            additional_install_commands: Platform-specific commands during installation.\n\n    Returns:\n            Output lines of the installation commands.\n    \"\"\"\n    if environment == self.main_environment and self.settings_manager.use_pixi:\n        raise Exception(\"Cannot install packages in an InternalEnvironment when using Pixi.\")\n    if environment == self.main_environment and environment.path is None:\n        raise Exception(\"Cannot install packages in an InternalEnvironment with no conda path.\")\n\n    install_commands = self.dependency_manager.get_install_dependencies_commands(environment, dependencies)\n    install_commands += self.command_generator.get_commands_for_current_platform(additional_install_commands)\n\n    logger.log_environment(\n        f\"Installing dependencies in environment '{environment.name}'\", environment.name, stage=\"install\"\n    )\n    log_context = {\"log_source\": LOG_SOURCE_ENVIRONMENT, \"env_name\": environment.name, \"stage\": \"install\"}\n    return self.command_executor.execute_commands_and_get_output(install_commands, log_context=log_context)\n</code></pre>"},{"location":"reference/wetlands/environment_manager/#wetlands.environment_manager.EnvironmentManager.execute_commands","title":"<code>execute_commands(environment, commands, additional_activate_commands={}, popen_kwargs={}, wait=False, log_context=None, log=True)</code>","text":"<p>Executes the given commands in the given environment.</p> <p>Parameters:</p> Name Type Description Default <code>environment</code> <code>Environment</code> <p>The environment in which to execute commands.</p> required <code>commands</code> <code>Commands</code> <p>The commands to execute in the environment.</p> required <code>additional_activate_commands</code> <code>Commands</code> <p>Platform-specific activation commands.</p> <code>{}</code> <code>popen_kwargs</code> <code>dict[str, Any]</code> <p>Keyword arguments for subprocess.Popen() (see Popen documentation). Defaults are: dict(stdout=subprocess.PIPE, stderr=subprocess.STDOUT, stdin=subprocess.DEVNULL, encoding=\"utf-8\", errors=\"replace\", bufsize=1).</p> <code>{}</code> <code>log_context</code> <code>dict[str, Any] | None</code> <p>Optional context dict to attach to logs via ProcessLogger.</p> <code>None</code> <code>log</code> <code>bool</code> <p>Whether to log the process output.</p> <code>True</code> <p>Returns:</p> Type Description <code>Popen</code> <p>The launched process.</p> Source code in <code>wetlands/environment_manager.py</code> <pre><code>def execute_commands(\n    self,\n    environment: Environment,\n    commands: Commands,\n    additional_activate_commands: Commands = {},\n    popen_kwargs: dict[str, Any] = {},\n    wait: bool = False,\n    log_context: dict[str, Any] | None = None,\n    log: bool = True,\n) -&gt; subprocess.Popen:\n    \"\"\"Executes the given commands in the given environment.\n\n    Args:\n            environment: The environment in which to execute commands.\n            commands: The commands to execute in the environment.\n            additional_activate_commands: Platform-specific activation commands.\n            popen_kwargs: Keyword arguments for subprocess.Popen() (see [Popen documentation](https://docs.python.org/3/library/subprocess.html#popen-constructor)). Defaults are: dict(stdout=subprocess.PIPE, stderr=subprocess.STDOUT, stdin=subprocess.DEVNULL, encoding=\"utf-8\", errors=\"replace\", bufsize=1).\n            log_context: Optional context dict to attach to logs via ProcessLogger.\n            log: Whether to log the process output.\n\n    Returns:\n            The launched process.\n    \"\"\"\n    activate_commands = self.command_generator.get_activate_environment_commands(\n        environment, additional_activate_commands\n    )\n    platform_commands = self.command_generator.get_commands_for_current_platform(commands)\n    return self.command_executor.execute_commands(\n        activate_commands + platform_commands,\n        popen_kwargs=popen_kwargs,\n        wait=wait,\n        log_context=log_context,\n        log=log,\n    )\n</code></pre>"},{"location":"reference/wetlands/environment_manager/#wetlands.environment_manager.EnvironmentManager.get_process_logger","title":"<code>get_process_logger(process)</code>","text":"<p>Get a ProcessLogger for the given process.</p> <p>Parameters:</p> Name Type Description Default <code>process</code> <code>Popen</code> <p>The process to create a ProcessLogger for.</p> required <p>Returns:         The created ProcessLogger.</p> Source code in <code>wetlands/environment_manager.py</code> <pre><code>def get_process_logger(self, process: subprocess.Popen) -&gt; ProcessLogger:\n    \"\"\"Get a ProcessLogger for the given process.\n\n    Args:\n            process: The process to create a ProcessLogger for.\n    Returns:\n            The created ProcessLogger.\n    \"\"\"\n    return self.command_executor.get_process_logger(process)\n</code></pre>"},{"location":"reference/wetlands/environment_manager/#wetlands.environment_manager.EnvironmentManager.register_environment","title":"<code>register_environment(environment, debug_port, module_executor_path)</code>","text":"<p>Register the environment (save its debug port to <code>wetlands_instance_path / debug_ports.json</code>) so that it can be debugged later.</p> <p>Parameters:</p> Name Type Description Default <code>environment</code> <code>ExternalEnvironment</code> <p>The external environment object to register</p> required <code>debug_port</code> <code>int</code> <p>The debug port to save</p> required Source code in <code>wetlands/environment_manager.py</code> <pre><code>def register_environment(\n    self, environment: ExternalEnvironment, debug_port: int, module_executor_path: Path\n) -&gt; None:\n    \"\"\"\n    Register the environment (save its debug port to `wetlands_instance_path / debug_ports.json`) so that it can be debugged later.\n\n    Args:\n            environment: The external environment object to register\n            debug_port: The debug port to save\n    \"\"\"\n    if environment.process is None:\n        return\n    wetlands_debug_ports_path = self.wetlands_instance_path / \"debug_ports.json\"\n    wetlands_debug_ports_path.parent.mkdir(exist_ok=True, parents=True)\n    wetlands_debug_ports = {}\n    try:\n        if wetlands_debug_ports_path.exists():\n            with open(wetlands_debug_ports_path, \"r\") as f:\n                wetlands_debug_ports = json5.load(f)\n        wetlands_debug_ports[environment.name] = dict(\n            debug_port=debug_port, module_executor_path=module_executor_path.as_posix()\n        )\n        with open(wetlands_debug_ports_path, \"w\") as f:\n            json5.dump(wetlands_debug_ports, f, indent=4, quote_keys=True)\n    except Exception as e:\n        e.add_note(f\"Error while updating the debug ports file {wetlands_debug_ports_path}.\")\n        raise e\n    return\n</code></pre>"},{"location":"reference/wetlands/environment_manager/#wetlands.environment_manager.EnvironmentManager.exit","title":"<code>exit()</code>","text":"<p>Exit all environments</p> Source code in <code>wetlands/environment_manager.py</code> <pre><code>def exit(self) -&gt; None:\n    \"\"\"Exit all environments\"\"\"\n    for env in list(self.environments.values()):\n        env.exit()\n</code></pre>"},{"location":"reference/wetlands/external_environment/","title":"External environment","text":"<p>Functions:</p> Name Description <code>synchronized</code> <p>Decorator to wrap a method call with self._lock.</p>"},{"location":"reference/wetlands/external_environment/#wetlands.external_environment.ExternalEnvironment","title":"<code>ExternalEnvironment</code>","text":"<p>               Bases: <code>Environment</code></p> <p>Methods:</p> Name Description <code>launch</code> <p>Launches a server listening for orders in the environment.</p> <code>execute</code> <p>Executes a function in the given module and return the result.</p> <code>run_script</code> <p>Runs a Python script remotely using runpy.run_path(), simulating</p> <code>launched</code> <p>Return true if the environment server process is launched and the connection is open.</p> <code>delete</code> <p>Deletes this external environment and cleans up associated resources.</p> <code>update</code> <p>Updates this external environment by deleting it and recreating it with new dependencies.</p> Source code in <code>wetlands/external_environment.py</code> <pre><code>class ExternalEnvironment(Environment):\n    port: int | None = None\n    process: subprocess.Popen | None = None\n    connection: Connection | None = None\n\n    def __init__(self, name: str, path: Path, environment_manager: \"EnvironmentManager\") -&gt; None:\n        super().__init__(name, path, environment_manager)\n        self._lock = threading.RLock()\n        self._process_logger: ProcessLogger | None = None\n\n    @synchronized\n    def launch(self, additional_activate_commands: Commands = {}) -&gt; None:\n        \"\"\"Launches a server listening for orders in the environment.\n\n        Args:\n                additional_activate_commands: Platform-specific activation commands.\n        \"\"\"\n\n        if self.launched():\n            return\n\n        module_executor_path = Path(__file__).parent.resolve() / MODULE_EXECUTOR_FILE\n\n        debug_args = f\" --debug_port 0\" if self.environment_manager.debug else \"\"\n        commands = [\n            f'python -u \"{module_executor_path}\" {self.name} --wetlands_instance_path {self.environment_manager.wetlands_instance_path.resolve()}{debug_args}'\n        ]\n\n        # Create log context for the module executor process\n        log_context = {\"log_source\": LOG_SOURCE_EXECUTION, \"env_name\": self.name, \"call_target\": MODULE_EXECUTOR_FILE}\n\n        # Pass log_context to execute_commands so ProcessLogger is created with proper context\n        self.process = self.execute_commands(commands, additional_activate_commands, log_context=log_context)\n\n        # Retrieve the ProcessLogger that was already created and started by execute_commands\n        self._process_logger = self.environment_manager.get_process_logger(self.process)\n        if self._process_logger is None:\n            raise Exception(\"Failed to retrieve ProcessLogger for module executor process\")\n\n        # Handle debug port if needed\n        if self.environment_manager.debug:\n\n            def debug_predicate(line: str) -&gt; bool:\n                return line.startswith(\"Listening debug port \")\n\n            debug_line = self._process_logger.wait_for_line(debug_predicate, timeout=5)\n            if debug_line:\n                debug_port = int(debug_line.replace(\"Listening debug port \", \"\"))\n                self.environment_manager.register_environment(self, debug_port, module_executor_path)\n\n        # Wait for port announcement with timeout\n        def port_predicate(line: str) -&gt; bool:\n            return line.startswith(\"Listening port \")\n\n        port_line = self._process_logger.wait_for_line(port_predicate, timeout=30)\n        if port_line:\n            self.port = int(port_line.replace(\"Listening port \", \"\"))\n\n        if self.process.poll() is not None:\n            raise Exception(f\"Process exited with return code {self.process.returncode}.\")\n        if self.port is None:\n            raise Exception(\"Could not find the server port.\")\n\n        self.connection = Client((\"localhost\", self.port))\n\n    def _send_and_wait(self, payload: dict) -&gt; Any:\n        \"\"\"Send a payload to the remote environment and wait for its response.\"\"\"\n        connection = self.connection\n        if connection is None or connection.closed:\n            raise ExecutionException(\"Connection not ready.\")\n\n        try:\n            connection.send(payload)\n            while message := connection.recv():\n                action = message.get(\"action\")\n                if action == \"execution finished\":\n                    logger.info(f\"{payload.get('action')} finished\")\n                    return message.get(\"result\")\n                elif action == \"error\":\n                    logger.error(message[\"exception\"])\n                    logger.error(\"Traceback:\")\n                    for line in message[\"traceback\"]:\n                        logger.error(line)\n                    raise ExecutionException(message)\n                else:\n                    logger.warning(f\"Got an unexpected message: {message}\")\n\n        except EOFError:\n            logger.info(\"Connection closed gracefully by the peer.\")\n        except BrokenPipeError as e:\n            logger.error(f\"Broken pipe. The peer process might have terminated. Exception: {e}.\")\n        except OSError as e:\n            if e.errno == 9:  # Bad file descriptor\n                logger.error(\"Connection closed abruptly by the peer.\")\n            else:\n                logger.error(f\"Unexpected OSError: {e}\")\n                raise e\n        return None\n\n    @synchronized\n    def execute(self, module_path: str | Path, function: str, args: tuple = (), kwargs: dict[str, Any] = {}) -&gt; Any:\n        \"\"\"Executes a function in the given module and return the result.\n        Warning: all arguments (args and kwargs) must be picklable (since they will be send with [multiprocessing.connection.Connection.send](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.connection.Connection.send))!\n\n        Args:\n                module_path: the path to the module to import\n                function: the name of the function to execute\n                args: the argument list for the function\n                kwargs: the keyword arguments for the function\n\n        Returns:\n                The result of the function if it is defined and the connection is opened ; None otherwise.\n        Raises:\n            OSError when raised by the communication.\n        \"\"\"\n        # Update log context to reflect the function being executed\n        module_name = Path(module_path).stem\n        call_target = f\"{module_name}:{function}\"\n        if self._process_logger:\n            self._process_logger.update_log_context({\"call_target\": call_target})\n\n        try:\n            payload = dict(\n                action=\"execute\",\n                module_path=str(module_path),\n                function=function,\n                args=args,\n                kwargs=kwargs,\n            )\n            return self._send_and_wait(payload)\n        finally:\n            # Reset to module_executor after execution\n            if self._process_logger:\n                self._process_logger.update_log_context({\"call_target\": MODULE_EXECUTOR_FILE})\n\n    @synchronized\n    def run_script(self, script_path: str | Path, args: tuple = (), run_name: str = \"__main__\") -&gt; Any:\n        \"\"\"\n        Runs a Python script remotely using runpy.run_path(), simulating\n        'python script.py arg1 arg2 ...'\n\n        Args:\n            script_path: Path to the script to execute.\n            args: List of arguments to pass (becomes sys.argv[1:] remotely).\n            run_name: Value for runpy.run_path(run_name=...); defaults to \"__main__\".\n\n        Returns:\n            The resulting globals dict from the executed script, or None on failure.\n        \"\"\"\n        # Update log context to reflect the script being executed\n        script_name = Path(script_path).name\n        if self._process_logger:\n            self._process_logger.update_log_context({\"call_target\": script_name})\n\n        try:\n            payload = dict(\n                action=\"run\",\n                script_path=str(script_path),\n                args=args,\n                run_name=run_name,\n            )\n            return self._send_and_wait(payload)\n        finally:\n            # Reset to module_executor after execution\n            if self._process_logger:\n                self._process_logger.update_log_context({\"call_target\": MODULE_EXECUTOR_FILE})\n\n    @synchronized\n    def launched(self) -&gt; bool:\n        \"\"\"Return true if the environment server process is launched and the connection is open.\"\"\"\n        return (\n            self.process is not None\n            and self.process.poll() is None\n            and self.connection is not None\n            and not self.connection.closed\n            and self.connection.writable\n            and self.connection.readable\n        )\n\n    @synchronized\n    def _exit(self) -&gt; None:\n        \"\"\"Close the connection to the environment and kills the process.\"\"\"\n        if self.connection is not None:\n            try:\n                self.connection.send(dict(action=\"exit\"))\n            except OSError as e:\n                if e.args[0] == \"handle is closed\":\n                    pass\n            self.connection.close()\n\n        if self.process and self.process.stdout:\n            self.process.stdout.close()\n\n        # ProcessLogger runs in a daemon thread, so it will be cleaned up automatically\n        self._process_logger = None\n\n        CommandExecutor.kill_process(self.process)\n\n    @synchronized\n    def delete(self) -&gt; None:\n        \"\"\"Deletes this external environment and cleans up associated resources.\n\n        Raises:\n                Exception: If the environment does not exist.\n\n        Side Effects:\n                - If the environment is running, calls _exit() on it\n                - Removes environment from environment_manager.environments dict\n                - Deletes the environment directory using appropriate conda manager\n        \"\"\"\n        if self.path is None:\n            raise Exception(\"Cannot delete an environment with no path.\")\n\n        if not self.environment_manager.environment_exists(self.path):\n            raise Exception(f\"The environment {self.name} does not exist.\")\n\n        # Exit the environment if it's running\n        if self.launched():\n            self._exit()\n\n        # Generate delete commands based on conda manager type\n        if self.environment_manager.settings_manager.use_pixi:\n            send2trash(self.path.parent)\n        else:\n            send2trash(self.path)\n\n        # Remove from environments dict\n        if self.name in self.environment_manager.environments:\n            del self.environment_manager.environments[self.name]\n\n    @synchronized\n    def update(\n        self,\n        dependencies: Union[Dependencies, None] = None,\n        additional_install_commands: Commands = {},\n        use_existing: bool = False,\n    ) -&gt; \"Environment\":\n        \"\"\"Updates this external environment by deleting it and recreating it with new dependencies.\n\n        Args:\n                dependencies: New dependencies to install. Can be one of:\n                    - A Dependencies dict: dict(python=\"3.12.7\", conda=[\"numpy\"], pip=[\"requests\"])\n                    - None (no dependencies to install)\n                additional_install_commands: Platform-specific commands during installation.\n                use_existing: use existing environment if it exists instead of recreating it.\n\n        Returns:\n                The recreated environment.\n\n        Raises:\n                Exception: If the environment does not exist.\n\n        Side Effects:\n                - Deletes the existing environment\n                - Creates a new environment with the same name but new dependencies\n        \"\"\"\n        if not self.path:\n            raise Exception(\"Cannot update an environment with no path.\")\n\n        if not self.environment_manager.environment_exists(self.path):\n            raise Exception(f\"The environment {self.name} does not exist.\")\n\n        # Delete the existing environment\n        self.delete()\n\n        # Use create for direct Dependencies dict\n        return self.environment_manager.create(\n            str(self.name),\n            dependencies=dependencies,\n            additional_install_commands=additional_install_commands,\n            use_existing=use_existing,\n        )\n</code></pre>"},{"location":"reference/wetlands/external_environment/#wetlands.external_environment.ExternalEnvironment.launch","title":"<code>launch(additional_activate_commands={})</code>","text":"<p>Launches a server listening for orders in the environment.</p> <p>Parameters:</p> Name Type Description Default <code>additional_activate_commands</code> <code>Commands</code> <p>Platform-specific activation commands.</p> <code>{}</code> Source code in <code>wetlands/external_environment.py</code> <pre><code>@synchronized\ndef launch(self, additional_activate_commands: Commands = {}) -&gt; None:\n    \"\"\"Launches a server listening for orders in the environment.\n\n    Args:\n            additional_activate_commands: Platform-specific activation commands.\n    \"\"\"\n\n    if self.launched():\n        return\n\n    module_executor_path = Path(__file__).parent.resolve() / MODULE_EXECUTOR_FILE\n\n    debug_args = f\" --debug_port 0\" if self.environment_manager.debug else \"\"\n    commands = [\n        f'python -u \"{module_executor_path}\" {self.name} --wetlands_instance_path {self.environment_manager.wetlands_instance_path.resolve()}{debug_args}'\n    ]\n\n    # Create log context for the module executor process\n    log_context = {\"log_source\": LOG_SOURCE_EXECUTION, \"env_name\": self.name, \"call_target\": MODULE_EXECUTOR_FILE}\n\n    # Pass log_context to execute_commands so ProcessLogger is created with proper context\n    self.process = self.execute_commands(commands, additional_activate_commands, log_context=log_context)\n\n    # Retrieve the ProcessLogger that was already created and started by execute_commands\n    self._process_logger = self.environment_manager.get_process_logger(self.process)\n    if self._process_logger is None:\n        raise Exception(\"Failed to retrieve ProcessLogger for module executor process\")\n\n    # Handle debug port if needed\n    if self.environment_manager.debug:\n\n        def debug_predicate(line: str) -&gt; bool:\n            return line.startswith(\"Listening debug port \")\n\n        debug_line = self._process_logger.wait_for_line(debug_predicate, timeout=5)\n        if debug_line:\n            debug_port = int(debug_line.replace(\"Listening debug port \", \"\"))\n            self.environment_manager.register_environment(self, debug_port, module_executor_path)\n\n    # Wait for port announcement with timeout\n    def port_predicate(line: str) -&gt; bool:\n        return line.startswith(\"Listening port \")\n\n    port_line = self._process_logger.wait_for_line(port_predicate, timeout=30)\n    if port_line:\n        self.port = int(port_line.replace(\"Listening port \", \"\"))\n\n    if self.process.poll() is not None:\n        raise Exception(f\"Process exited with return code {self.process.returncode}.\")\n    if self.port is None:\n        raise Exception(\"Could not find the server port.\")\n\n    self.connection = Client((\"localhost\", self.port))\n</code></pre>"},{"location":"reference/wetlands/external_environment/#wetlands.external_environment.ExternalEnvironment.execute","title":"<code>execute(module_path, function, args=(), kwargs={})</code>","text":"<p>Executes a function in the given module and return the result. Warning: all arguments (args and kwargs) must be picklable (since they will be send with multiprocessing.connection.Connection.send)!</p> <p>Parameters:</p> Name Type Description Default <code>module_path</code> <code>str | Path</code> <p>the path to the module to import</p> required <code>function</code> <code>str</code> <p>the name of the function to execute</p> required <code>args</code> <code>tuple</code> <p>the argument list for the function</p> <code>()</code> <code>kwargs</code> <code>dict[str, Any]</code> <p>the keyword arguments for the function</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>The result of the function if it is defined and the connection is opened ; None otherwise.</p> <p>Raises:     OSError when raised by the communication.</p> Source code in <code>wetlands/external_environment.py</code> <pre><code>@synchronized\ndef execute(self, module_path: str | Path, function: str, args: tuple = (), kwargs: dict[str, Any] = {}) -&gt; Any:\n    \"\"\"Executes a function in the given module and return the result.\n    Warning: all arguments (args and kwargs) must be picklable (since they will be send with [multiprocessing.connection.Connection.send](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.connection.Connection.send))!\n\n    Args:\n            module_path: the path to the module to import\n            function: the name of the function to execute\n            args: the argument list for the function\n            kwargs: the keyword arguments for the function\n\n    Returns:\n            The result of the function if it is defined and the connection is opened ; None otherwise.\n    Raises:\n        OSError when raised by the communication.\n    \"\"\"\n    # Update log context to reflect the function being executed\n    module_name = Path(module_path).stem\n    call_target = f\"{module_name}:{function}\"\n    if self._process_logger:\n        self._process_logger.update_log_context({\"call_target\": call_target})\n\n    try:\n        payload = dict(\n            action=\"execute\",\n            module_path=str(module_path),\n            function=function,\n            args=args,\n            kwargs=kwargs,\n        )\n        return self._send_and_wait(payload)\n    finally:\n        # Reset to module_executor after execution\n        if self._process_logger:\n            self._process_logger.update_log_context({\"call_target\": MODULE_EXECUTOR_FILE})\n</code></pre>"},{"location":"reference/wetlands/external_environment/#wetlands.external_environment.ExternalEnvironment.run_script","title":"<code>run_script(script_path, args=(), run_name='__main__')</code>","text":"<p>Runs a Python script remotely using runpy.run_path(), simulating 'python script.py arg1 arg2 ...'</p> <p>Parameters:</p> Name Type Description Default <code>script_path</code> <code>str | Path</code> <p>Path to the script to execute.</p> required <code>args</code> <code>tuple</code> <p>List of arguments to pass (becomes sys.argv[1:] remotely).</p> <code>()</code> <code>run_name</code> <code>str</code> <p>Value for runpy.run_path(run_name=...); defaults to \"main\".</p> <code>'__main__'</code> <p>Returns:</p> Type Description <code>Any</code> <p>The resulting globals dict from the executed script, or None on failure.</p> Source code in <code>wetlands/external_environment.py</code> <pre><code>@synchronized\ndef run_script(self, script_path: str | Path, args: tuple = (), run_name: str = \"__main__\") -&gt; Any:\n    \"\"\"\n    Runs a Python script remotely using runpy.run_path(), simulating\n    'python script.py arg1 arg2 ...'\n\n    Args:\n        script_path: Path to the script to execute.\n        args: List of arguments to pass (becomes sys.argv[1:] remotely).\n        run_name: Value for runpy.run_path(run_name=...); defaults to \"__main__\".\n\n    Returns:\n        The resulting globals dict from the executed script, or None on failure.\n    \"\"\"\n    # Update log context to reflect the script being executed\n    script_name = Path(script_path).name\n    if self._process_logger:\n        self._process_logger.update_log_context({\"call_target\": script_name})\n\n    try:\n        payload = dict(\n            action=\"run\",\n            script_path=str(script_path),\n            args=args,\n            run_name=run_name,\n        )\n        return self._send_and_wait(payload)\n    finally:\n        # Reset to module_executor after execution\n        if self._process_logger:\n            self._process_logger.update_log_context({\"call_target\": MODULE_EXECUTOR_FILE})\n</code></pre>"},{"location":"reference/wetlands/external_environment/#wetlands.external_environment.ExternalEnvironment.launched","title":"<code>launched()</code>","text":"<p>Return true if the environment server process is launched and the connection is open.</p> Source code in <code>wetlands/external_environment.py</code> <pre><code>@synchronized\ndef launched(self) -&gt; bool:\n    \"\"\"Return true if the environment server process is launched and the connection is open.\"\"\"\n    return (\n        self.process is not None\n        and self.process.poll() is None\n        and self.connection is not None\n        and not self.connection.closed\n        and self.connection.writable\n        and self.connection.readable\n    )\n</code></pre>"},{"location":"reference/wetlands/external_environment/#wetlands.external_environment.ExternalEnvironment.delete","title":"<code>delete()</code>","text":"<p>Deletes this external environment and cleans up associated resources.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the environment does not exist.</p> Side Effects <ul> <li>If the environment is running, calls _exit() on it</li> <li>Removes environment from environment_manager.environments dict</li> <li>Deletes the environment directory using appropriate conda manager</li> </ul> Source code in <code>wetlands/external_environment.py</code> <pre><code>@synchronized\ndef delete(self) -&gt; None:\n    \"\"\"Deletes this external environment and cleans up associated resources.\n\n    Raises:\n            Exception: If the environment does not exist.\n\n    Side Effects:\n            - If the environment is running, calls _exit() on it\n            - Removes environment from environment_manager.environments dict\n            - Deletes the environment directory using appropriate conda manager\n    \"\"\"\n    if self.path is None:\n        raise Exception(\"Cannot delete an environment with no path.\")\n\n    if not self.environment_manager.environment_exists(self.path):\n        raise Exception(f\"The environment {self.name} does not exist.\")\n\n    # Exit the environment if it's running\n    if self.launched():\n        self._exit()\n\n    # Generate delete commands based on conda manager type\n    if self.environment_manager.settings_manager.use_pixi:\n        send2trash(self.path.parent)\n    else:\n        send2trash(self.path)\n\n    # Remove from environments dict\n    if self.name in self.environment_manager.environments:\n        del self.environment_manager.environments[self.name]\n</code></pre>"},{"location":"reference/wetlands/external_environment/#wetlands.external_environment.ExternalEnvironment.update","title":"<code>update(dependencies=None, additional_install_commands={}, use_existing=False)</code>","text":"<p>Updates this external environment by deleting it and recreating it with new dependencies.</p> <p>Parameters:</p> Name Type Description Default <code>dependencies</code> <code>Union[Dependencies, None]</code> <p>New dependencies to install. Can be one of: - A Dependencies dict: dict(python=\"3.12.7\", conda=[\"numpy\"], pip=[\"requests\"]) - None (no dependencies to install)</p> <code>None</code> <code>additional_install_commands</code> <code>Commands</code> <p>Platform-specific commands during installation.</p> <code>{}</code> <code>use_existing</code> <code>bool</code> <p>use existing environment if it exists instead of recreating it.</p> <code>False</code> <p>Returns:</p> Type Description <code>Environment</code> <p>The recreated environment.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the environment does not exist.</p> Side Effects <ul> <li>Deletes the existing environment</li> <li>Creates a new environment with the same name but new dependencies</li> </ul> Source code in <code>wetlands/external_environment.py</code> <pre><code>@synchronized\ndef update(\n    self,\n    dependencies: Union[Dependencies, None] = None,\n    additional_install_commands: Commands = {},\n    use_existing: bool = False,\n) -&gt; \"Environment\":\n    \"\"\"Updates this external environment by deleting it and recreating it with new dependencies.\n\n    Args:\n            dependencies: New dependencies to install. Can be one of:\n                - A Dependencies dict: dict(python=\"3.12.7\", conda=[\"numpy\"], pip=[\"requests\"])\n                - None (no dependencies to install)\n            additional_install_commands: Platform-specific commands during installation.\n            use_existing: use existing environment if it exists instead of recreating it.\n\n    Returns:\n            The recreated environment.\n\n    Raises:\n            Exception: If the environment does not exist.\n\n    Side Effects:\n            - Deletes the existing environment\n            - Creates a new environment with the same name but new dependencies\n    \"\"\"\n    if not self.path:\n        raise Exception(\"Cannot update an environment with no path.\")\n\n    if not self.environment_manager.environment_exists(self.path):\n        raise Exception(f\"The environment {self.name} does not exist.\")\n\n    # Delete the existing environment\n    self.delete()\n\n    # Use create for direct Dependencies dict\n    return self.environment_manager.create(\n        str(self.name),\n        dependencies=dependencies,\n        additional_install_commands=additional_install_commands,\n        use_existing=use_existing,\n    )\n</code></pre>"},{"location":"reference/wetlands/external_environment/#wetlands.external_environment.synchronized","title":"<code>synchronized(method)</code>","text":"<p>Decorator to wrap a method call with self._lock.</p> Source code in <code>wetlands/external_environment.py</code> <pre><code>def synchronized(method):\n    \"\"\"Decorator to wrap a method call with self._lock.\"\"\"\n\n    @functools.wraps(method)\n    def wrapper(self, *args, **kwargs):\n        with self._lock:\n            return method(self, *args, **kwargs)\n\n    return wrapper\n</code></pre>"},{"location":"reference/wetlands/internal_environment/","title":"Internal environment","text":""},{"location":"reference/wetlands/internal_environment/#wetlands.internal_environment.InternalEnvironment","title":"<code>InternalEnvironment</code>","text":"<p>               Bases: <code>Environment</code></p> <p>Methods:</p> Name Description <code>__init__</code> <p>Use absolute path as name for micromamba to consider the activation from a folder path, not from a name</p> <code>execute</code> <p>Executes a function in the given module</p> <code>run_script</code> <p>Runs a Python script locally using runpy.run_path(), simulating</p> Source code in <code>wetlands/internal_environment.py</code> <pre><code>class InternalEnvironment(Environment):\n    def __init__(self, name: str, path: Path | None, environment_manager: \"EnvironmentManager\") -&gt; None:\n        \"\"\"Use absolute path as name for micromamba to consider the activation from a folder path, not from a name\"\"\"\n        super().__init__(name, path, environment_manager)\n\n    def execute(self, module_path: str | Path, function: str, args: tuple = (), kwargs: dict[str, Any] = {}) -&gt; Any:\n        \"\"\"Executes a function in the given module\n\n        Args:\n                module_path: the path to the module to import\n                function: the name of the function to execute\n                args: the argument list for the function\n                kwargs: the keyword arguments for the function\n\n        Returns:\n                The result of the function\n        \"\"\"\n        module = self._import_module(module_path)\n        if not self._is_mod_function(module, function):\n            raise Exception(f\"Module {module_path} has no function {function}.\")\n        return getattr(module, function)(*args)\n\n    def run_script(self, script_path: str | Path, args: tuple = (), run_name: str = \"__main__\") -&gt; Any:\n        \"\"\"\n        Runs a Python script locally using runpy.run_path(), simulating\n        'python script.py arg1 arg2 ...'\n\n        Args:\n            script_path: Path to the script to execute.\n            args: List of arguments to pass (becomes sys.argv[1:] locally).\n            run_name: Value for runpy.run_path(run_name=...); defaults to \"__main__\".\n\n        Returns:\n            The resulting globals dict from the executed script, or None on failure.\n        \"\"\"\n        script_path = str(script_path)\n        sys.argv = [script_path] + list(args)\n        runpy.run_path(script_path, run_name=run_name)\n        return None\n</code></pre>"},{"location":"reference/wetlands/internal_environment/#wetlands.internal_environment.InternalEnvironment.__init__","title":"<code>__init__(name, path, environment_manager)</code>","text":"<p>Use absolute path as name for micromamba to consider the activation from a folder path, not from a name</p> Source code in <code>wetlands/internal_environment.py</code> <pre><code>def __init__(self, name: str, path: Path | None, environment_manager: \"EnvironmentManager\") -&gt; None:\n    \"\"\"Use absolute path as name for micromamba to consider the activation from a folder path, not from a name\"\"\"\n    super().__init__(name, path, environment_manager)\n</code></pre>"},{"location":"reference/wetlands/internal_environment/#wetlands.internal_environment.InternalEnvironment.execute","title":"<code>execute(module_path, function, args=(), kwargs={})</code>","text":"<p>Executes a function in the given module</p> <p>Parameters:</p> Name Type Description Default <code>module_path</code> <code>str | Path</code> <p>the path to the module to import</p> required <code>function</code> <code>str</code> <p>the name of the function to execute</p> required <code>args</code> <code>tuple</code> <p>the argument list for the function</p> <code>()</code> <code>kwargs</code> <code>dict[str, Any]</code> <p>the keyword arguments for the function</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>The result of the function</p> Source code in <code>wetlands/internal_environment.py</code> <pre><code>def execute(self, module_path: str | Path, function: str, args: tuple = (), kwargs: dict[str, Any] = {}) -&gt; Any:\n    \"\"\"Executes a function in the given module\n\n    Args:\n            module_path: the path to the module to import\n            function: the name of the function to execute\n            args: the argument list for the function\n            kwargs: the keyword arguments for the function\n\n    Returns:\n            The result of the function\n    \"\"\"\n    module = self._import_module(module_path)\n    if not self._is_mod_function(module, function):\n        raise Exception(f\"Module {module_path} has no function {function}.\")\n    return getattr(module, function)(*args)\n</code></pre>"},{"location":"reference/wetlands/internal_environment/#wetlands.internal_environment.InternalEnvironment.run_script","title":"<code>run_script(script_path, args=(), run_name='__main__')</code>","text":"<p>Runs a Python script locally using runpy.run_path(), simulating 'python script.py arg1 arg2 ...'</p> <p>Parameters:</p> Name Type Description Default <code>script_path</code> <code>str | Path</code> <p>Path to the script to execute.</p> required <code>args</code> <code>tuple</code> <p>List of arguments to pass (becomes sys.argv[1:] locally).</p> <code>()</code> <code>run_name</code> <code>str</code> <p>Value for runpy.run_path(run_name=...); defaults to \"main\".</p> <code>'__main__'</code> <p>Returns:</p> Type Description <code>Any</code> <p>The resulting globals dict from the executed script, or None on failure.</p> Source code in <code>wetlands/internal_environment.py</code> <pre><code>def run_script(self, script_path: str | Path, args: tuple = (), run_name: str = \"__main__\") -&gt; Any:\n    \"\"\"\n    Runs a Python script locally using runpy.run_path(), simulating\n    'python script.py arg1 arg2 ...'\n\n    Args:\n        script_path: Path to the script to execute.\n        args: List of arguments to pass (becomes sys.argv[1:] locally).\n        run_name: Value for runpy.run_path(run_name=...); defaults to \"__main__\".\n\n    Returns:\n        The resulting globals dict from the executed script, or None on failure.\n    \"\"\"\n    script_path = str(script_path)\n    sys.argv = [script_path] + list(args)\n    runpy.run_path(script_path, run_name=run_name)\n    return None\n</code></pre>"},{"location":"reference/wetlands/_internal/command_executor/","title":"Command executor","text":""},{"location":"reference/wetlands/_internal/command_executor/#wetlands._internal.command_executor.CommandExecutor","title":"<code>CommandExecutor</code>","text":"<p>Handles execution of shell commands with error checking and logging.</p> <p>Methods:</p> Name Description <code>__init__</code> <p>scripts_path: Path where to create temporary script files for command execution (useful for debugging). If None, use the system default temp directory.</p> <code>kill_process</code> <p>Terminates the process and its children</p> <code>get_process_logger</code> <p>Get the ProcessLogger for a subprocess.</p> <code>execute_commands</code> <p>Executes shell commands in a subprocess with automatic logging via ProcessLogger.</p> <code>execute_commands_and_get_output</code> <p>Executes commands and captures their output. See <code>CommandExecutor.execute_commands</code> for more details on the arguments.</p> <code>execute_commands_and_get_json_output</code> <p>Execute commands and parse the json output.</p> Source code in <code>wetlands/_internal/command_executor.py</code> <pre><code>class CommandExecutor:\n    \"\"\"Handles execution of shell commands with error checking and logging.\"\"\"\n\n    def __init__(self, scripts_path: Path | None = None) -&gt; None:\n        \"\"\"scripts_path: Path where to create temporary script files for command execution (useful for debugging). If None, use the system default temp directory.\"\"\"\n        self.scripts_path = scripts_path\n        if scripts_path is not None:\n            scripts_path.mkdir(parents=True, exist_ok=True)\n        self._process_loggers: dict[int, ProcessLogger] = {}  # Map process PID to ProcessLogger\n\n    @staticmethod\n    def kill_process(process) -&gt; None:\n        \"\"\"Terminates the process and its children\"\"\"\n        if process is None:\n            return\n        try:\n            parent = psutil.Process(process.pid)\n        except psutil.NoSuchProcess:\n            return\n        try:\n            for child in parent.children(recursive=True):  # Get all child processes\n                if child.is_running():\n                    child.kill()\n            if parent.is_running():\n                parent.kill()\n        except (psutil.NoSuchProcess, psutil.AccessDenied):\n            pass\n\n    def _is_windows(self) -&gt; bool:\n        \"\"\"Checks if the current OS is Windows.\"\"\"\n        return platform.system() == \"Windows\"\n\n    def _insert_command_error_checks(self, commands: list[str]) -&gt; list[str]:\n        \"\"\"Inserts error checking commands after each shell command.\n        Note: could also use [`set -e`](https://stackoverflow.com/questions/3474526/stop-on-first-error),\n        and [`$ErrorActionPreference = \"Stop\"`](https://stackoverflow.com/questions/9948517/how-to-stop-a-powershell-script-on-the-first-error).\n\n        Args:\n                commands: List of original shell commands.\n\n        Returns:\n                Augmented command list with error checking logic.\n        \"\"\"\n        commands_with_checks = []\n        error_message = \"Errors encountered during execution. Exited with status:\"\n        windows_checks = [\"\", \"if (! $?) { exit 1 } \"]\n        posix_checks = [\n            \"\",\n            \"return_status=$?\",\n            \"if [ $return_status -ne 0 ]\",\n            \"then\",\n            f'    echo \"{error_message} $return_status\"',\n            \"    exit 1\",\n            \"fi\",\n            \"\",\n        ]\n        checks = windows_checks if self._is_windows() else posix_checks\n        for command in commands:\n            commands_with_checks.append(command)\n            commands_with_checks += checks\n        return commands_with_checks\n\n    def _commands_excerpt(self, commands: list[str]) -&gt; str:\n        \"\"\"Returns the command list as a string but cap the length at 150 characters\n        (for example to be able to display it in a dialog window).\"\"\"\n        if commands is None or len(commands) == 0:\n            return \"\"\n        prefix: str = \"[...] \" if len(str(commands)) &gt; 150 else \"\"\n        return prefix + str(commands)[-150:]\n\n    def _create_process_logger(\n        self,\n        process: subprocess.Popen,\n        log_context: dict[str, Any] | None = None,\n    ) -&gt; ProcessLogger:\n        \"\"\"Create and start a ProcessLogger for a subprocess.\n\n        This enables non-blocking, real-time logging with context metadata.\n\n        Args:\n                process: Subprocess to monitor.\n                log_context: Dictionary of context to attach to all logs.\n\n        Returns:\n                ProcessLogger instance (already started).\n        \"\"\"\n        if log_context is None:\n            log_context = {}\n\n        process_logger = ProcessLogger(process, log_context, logger)\n        process_logger.start_reading()\n        # Store reference for later retrieval\n        self._process_loggers[process.pid] = process_logger\n        return process_logger\n\n    def get_process_logger(\n        self,\n        process: subprocess.Popen,\n    ) -&gt; ProcessLogger:\n        \"\"\"Get the ProcessLogger for a subprocess.\n\n        Args:\n                process: Subprocess whose logger to retrieve.\n\n        Returns:\n                ProcessLogger instance if found, raise exception if not found.\n        \"\"\"\n        return self._process_loggers[process.pid]\n\n    def _get_complete_process_logger(self, process: subprocess.Popen) -&gt; ProcessLogger | None:\n        \"\"\"Get the process logger and wait for the reader thread to finish processing all output.\n\n        Args:\n                process: The completed subprocess.\n\n        Returns:\n                ProcessLogger instance with all output read, or None if not found.\n        \"\"\"\n        if process.pid not in self._process_loggers:\n            return None\n\n        process_logger = self._process_loggers[process.pid]\n        # Wait for reader thread to finish processing all output\n        if process_logger._reader_thread is not None and process_logger._reader_thread.is_alive():\n            process_logger._reader_thread.join(timeout=5.0)\n\n        return process_logger\n\n    def execute_commands(\n        self,\n        commands: list[str],\n        exit_if_command_error: bool = True,\n        popen_kwargs: dict[str, Any] = {},\n        wait: bool = False,\n        remove_python_env_vars: bool = True,\n        log_context: dict[str, Any] | None = None,\n        log: bool = True,\n    ) -&gt; subprocess.Popen:\n        \"\"\"Executes shell commands in a subprocess with automatic logging via ProcessLogger.\n\n        Warning: does not wait for completion unless ``wait`` is True. Output is logged in real-time via a background thread.\n\n        Args:\n                commands: List of shell commands to execute.\n                exit_if_command_error: Whether to insert error checking after each command to make sure the whole command chain stops if an error occurs (otherwise the script will be executed entirely even when one command fails at the beginning).\n                popen_kwargs: Keyword arguments for subprocess.Popen() (see [Popen documentation](https://docs.python.org/3/library/subprocess.html#popen-constructor)). Defaults are: dict(stdout=subprocess.PIPE, stderr=subprocess.STDOUT, stdin=subprocess.DEVNULL, encoding=\"utf-8\", errors=\"replace\", bufsize=1).\n                wait: Whether to wait for the process to complete before returning.\n                remove_python_env_vars: Whether to remove PYTHONEXECUTABLE, PYTHONHOME and PYTHONPATH from the environment variables to avoid interference with conda/pixi environment activation.\n                log_context: Optional context dict to attach to logs. If provided, ProcessLogger will emit logs with this context.\n                log: Whether to enable logging of command output. Defaults to True.\n\n        Returns:\n                Subprocess handle for the executed commands. Output is logged in real-time via ProcessLogger.\n        \"\"\"\n        import os\n\n        commands_string = \"\\n\\t\\t\".join(commands)\n        logger.debug(f\"Execute commands:\\n\\n\\t\\t{commands_string}\\n\")\n        with tempfile.NamedTemporaryFile(\n            dir=self.scripts_path, suffix=\".ps1\" if self._is_windows() else \".sh\", mode=\"w\", delete=False\n        ) as tmp:\n            if exit_if_command_error:\n                commands = self._insert_command_error_checks(commands)\n            tmp.write(\"\\n\".join(commands))\n            tmp.flush()\n            tmp.close()\n            execute_file = (\n                [\n                    \"powershell\",\n                    \"-WindowStyle\",\n                    \"Hidden\",\n                    \"-NoProfile\",\n                    \"-ExecutionPolicy\",\n                    \"ByPass\",\n                    \"-File\",\n                    tmp.name,\n                ]\n                if self._is_windows()\n                else [\"/bin/bash\", tmp.name]\n            )\n            if not self._is_windows():\n                subprocess.run([\"chmod\", \"u+x\", tmp.name])\n            logger.debug(f\"Script file: {tmp.name}\")\n\n            if remove_python_env_vars:\n                # Remove environment variables that can interfere with conda/pixi activation\n                # These are typically set by the parent application (e.g., napari) and can cause\n                # Python to use the wrong interpreter or libraries instead of the isolated environment\n                env = popen_kwargs.get(\"env\")\n                vars_to_remove = [\"PYTHONEXECUTABLE\", \"PYTHONHOME\", \"PYTHONPATH\"]\n                # warn if mergedKwargs had an env variable which can cause issues with env activation\n                if env is not None and any(var in vars_to_remove for var in env):\n                    logger.warning(f\"Removing variables {vars_to_remove} from env.\")\n\n                if env is None:\n                    env = os.environ.copy()\n\n                for var in vars_to_remove:\n                    env.pop(var, None)\n                popen_kwargs[\"env\"] = env\n\n            default_popen_kwargs = {\n                \"stdout\": subprocess.PIPE,\n                \"stderr\": subprocess.STDOUT,  # Merge stderr and stdout to handle all them with a single loop\n                \"stdin\": subprocess.DEVNULL,  # Prevent the command to wait for input: instead we want to stop if this happens\n                \"encoding\": \"utf-8\",\n                \"errors\": \"replace\",  # Determines how encoding and decoding errors should be handled: replaces invalid characters with a placeholder (e.g., ? in ASCII).\n                \"bufsize\": 1,  # 1 means line buffered\n            }\n            process = subprocess.Popen(execute_file, **(default_popen_kwargs | popen_kwargs))\n\n            # Create ProcessLogger to handle stdout in background if logging is enabled\n            if log:\n                process_logger = self._create_process_logger(process, log_context)\n\n                # Subscribe to detect CondaSystemExit in real-time during execution\n                def conda_exit_detector(line: str, _context: dict) -&gt; None:\n                    if \"CondaSystemExit\" in line:\n                        # Kill process immediately and mark it\n                        self.kill_process(process)\n                        process._conda_exit_detected = True  # type: ignore[attr-defined]\n\n                process_logger.subscribe(conda_exit_detector)\n\n            if wait:\n                process.wait()\n            return process\n\n    def execute_commands_and_get_output(\n        self,\n        commands: list[str],\n        exit_if_command_error: bool = True,\n        popen_kwargs: dict[str, Any] = {},\n        log_context: dict[str, Any] | None = None,\n    ) -&gt; list[str]:\n        \"\"\"Executes commands and captures their output. See [`CommandExecutor.execute_commands`][wetlands._internal.command_executor.CommandExecutor.execute_commands] for more details on the arguments.\n\n        Args:\n                commands: Shell commands to execute.\n                exit_if_command_error: Whether to insert error checking.\n                popen_kwargs: Keyword arguments for subprocess.Popen().\n                log_context: Optional context dict to attach to logs via ProcessLogger.\n\n        Returns:\n                Output lines (stripped of whitespace).\n\n        Raises:\n                Exception: If CondaSystemExit detected or non-zero exit code.\n        \"\"\"\n        # Always create ProcessLogger to capture output (set log=True internally)\n        process = self.execute_commands(\n            commands,\n            exit_if_command_error=exit_if_command_error,\n            popen_kwargs=popen_kwargs,\n            wait=True,\n            log=True,\n            log_context=log_context,\n        )\n\n        # Get output from ProcessLogger (always created above)\n        process_logger = self._get_complete_process_logger(process)\n        if process_logger is None:\n            return []\n\n        # Check if CondaSystemExit was detected during execution\n        if getattr(process, \"_conda_exit_detected\", False):\n            raise Exception(f'The execution of the commands \"{self._commands_excerpt(commands)}\" failed.')\n\n        output = process_logger.get_output()\n        # Strip whitespace from each line\n        stripped_output = [line.strip() for line in output]\n\n        # Check exit code\n        if process.returncode != 0:\n            raise Exception(f'The execution of the commands \"{self._commands_excerpt(commands)}\" failed.')\n\n        return stripped_output\n\n    def execute_commands_and_get_json_output(\n        self, commands: list[str], exit_if_command_error: bool = True, popen_kwargs: dict[str, Any] = {}\n    ) -&gt; list[dict[str, str]]:\n        \"\"\"Execute commands and parse the json output.\n\n        Args:\n                commands: Shell commands to execute.\n                exit_if_command_error: Whether to insert error checking.\n                popen_kwargs: Keyword arguments for subprocess.Popen().\n\n        Returns:\n                Output json.\n        \"\"\"\n        # Execute with wait=True to block until completion\n        process = self.execute_commands(\n            commands, exit_if_command_error=exit_if_command_error, popen_kwargs=popen_kwargs, wait=True, log=True\n        )\n\n        # Get output from ProcessLogger\n        process_logger = self._get_complete_process_logger(process)\n        if process_logger is None:\n            return []\n\n        output = process_logger.get_output()\n        return json.loads(\"\".join(output))\n</code></pre>"},{"location":"reference/wetlands/_internal/command_executor/#wetlands._internal.command_executor.CommandExecutor.__init__","title":"<code>__init__(scripts_path=None)</code>","text":"<p>scripts_path: Path where to create temporary script files for command execution (useful for debugging). If None, use the system default temp directory.</p> Source code in <code>wetlands/_internal/command_executor.py</code> <pre><code>def __init__(self, scripts_path: Path | None = None) -&gt; None:\n    \"\"\"scripts_path: Path where to create temporary script files for command execution (useful for debugging). If None, use the system default temp directory.\"\"\"\n    self.scripts_path = scripts_path\n    if scripts_path is not None:\n        scripts_path.mkdir(parents=True, exist_ok=True)\n    self._process_loggers: dict[int, ProcessLogger] = {}  # Map process PID to ProcessLogger\n</code></pre>"},{"location":"reference/wetlands/_internal/command_executor/#wetlands._internal.command_executor.CommandExecutor.kill_process","title":"<code>kill_process(process)</code>  <code>staticmethod</code>","text":"<p>Terminates the process and its children</p> Source code in <code>wetlands/_internal/command_executor.py</code> <pre><code>@staticmethod\ndef kill_process(process) -&gt; None:\n    \"\"\"Terminates the process and its children\"\"\"\n    if process is None:\n        return\n    try:\n        parent = psutil.Process(process.pid)\n    except psutil.NoSuchProcess:\n        return\n    try:\n        for child in parent.children(recursive=True):  # Get all child processes\n            if child.is_running():\n                child.kill()\n        if parent.is_running():\n            parent.kill()\n    except (psutil.NoSuchProcess, psutil.AccessDenied):\n        pass\n</code></pre>"},{"location":"reference/wetlands/_internal/command_executor/#wetlands._internal.command_executor.CommandExecutor.get_process_logger","title":"<code>get_process_logger(process)</code>","text":"<p>Get the ProcessLogger for a subprocess.</p> <p>Parameters:</p> Name Type Description Default <code>process</code> <code>Popen</code> <p>Subprocess whose logger to retrieve.</p> required <p>Returns:</p> Type Description <code>ProcessLogger</code> <p>ProcessLogger instance if found, raise exception if not found.</p> Source code in <code>wetlands/_internal/command_executor.py</code> <pre><code>def get_process_logger(\n    self,\n    process: subprocess.Popen,\n) -&gt; ProcessLogger:\n    \"\"\"Get the ProcessLogger for a subprocess.\n\n    Args:\n            process: Subprocess whose logger to retrieve.\n\n    Returns:\n            ProcessLogger instance if found, raise exception if not found.\n    \"\"\"\n    return self._process_loggers[process.pid]\n</code></pre>"},{"location":"reference/wetlands/_internal/command_executor/#wetlands._internal.command_executor.CommandExecutor.execute_commands","title":"<code>execute_commands(commands, exit_if_command_error=True, popen_kwargs={}, wait=False, remove_python_env_vars=True, log_context=None, log=True)</code>","text":"<p>Executes shell commands in a subprocess with automatic logging via ProcessLogger.</p> <p>Warning: does not wait for completion unless <code>wait</code> is True. Output is logged in real-time via a background thread.</p> <p>Parameters:</p> Name Type Description Default <code>commands</code> <code>list[str]</code> <p>List of shell commands to execute.</p> required <code>exit_if_command_error</code> <code>bool</code> <p>Whether to insert error checking after each command to make sure the whole command chain stops if an error occurs (otherwise the script will be executed entirely even when one command fails at the beginning).</p> <code>True</code> <code>popen_kwargs</code> <code>dict[str, Any]</code> <p>Keyword arguments for subprocess.Popen() (see Popen documentation). Defaults are: dict(stdout=subprocess.PIPE, stderr=subprocess.STDOUT, stdin=subprocess.DEVNULL, encoding=\"utf-8\", errors=\"replace\", bufsize=1).</p> <code>{}</code> <code>wait</code> <code>bool</code> <p>Whether to wait for the process to complete before returning.</p> <code>False</code> <code>remove_python_env_vars</code> <code>bool</code> <p>Whether to remove PYTHONEXECUTABLE, PYTHONHOME and PYTHONPATH from the environment variables to avoid interference with conda/pixi environment activation.</p> <code>True</code> <code>log_context</code> <code>dict[str, Any] | None</code> <p>Optional context dict to attach to logs. If provided, ProcessLogger will emit logs with this context.</p> <code>None</code> <code>log</code> <code>bool</code> <p>Whether to enable logging of command output. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>Popen</code> <p>Subprocess handle for the executed commands. Output is logged in real-time via ProcessLogger.</p> Source code in <code>wetlands/_internal/command_executor.py</code> <pre><code>def execute_commands(\n    self,\n    commands: list[str],\n    exit_if_command_error: bool = True,\n    popen_kwargs: dict[str, Any] = {},\n    wait: bool = False,\n    remove_python_env_vars: bool = True,\n    log_context: dict[str, Any] | None = None,\n    log: bool = True,\n) -&gt; subprocess.Popen:\n    \"\"\"Executes shell commands in a subprocess with automatic logging via ProcessLogger.\n\n    Warning: does not wait for completion unless ``wait`` is True. Output is logged in real-time via a background thread.\n\n    Args:\n            commands: List of shell commands to execute.\n            exit_if_command_error: Whether to insert error checking after each command to make sure the whole command chain stops if an error occurs (otherwise the script will be executed entirely even when one command fails at the beginning).\n            popen_kwargs: Keyword arguments for subprocess.Popen() (see [Popen documentation](https://docs.python.org/3/library/subprocess.html#popen-constructor)). Defaults are: dict(stdout=subprocess.PIPE, stderr=subprocess.STDOUT, stdin=subprocess.DEVNULL, encoding=\"utf-8\", errors=\"replace\", bufsize=1).\n            wait: Whether to wait for the process to complete before returning.\n            remove_python_env_vars: Whether to remove PYTHONEXECUTABLE, PYTHONHOME and PYTHONPATH from the environment variables to avoid interference with conda/pixi environment activation.\n            log_context: Optional context dict to attach to logs. If provided, ProcessLogger will emit logs with this context.\n            log: Whether to enable logging of command output. Defaults to True.\n\n    Returns:\n            Subprocess handle for the executed commands. Output is logged in real-time via ProcessLogger.\n    \"\"\"\n    import os\n\n    commands_string = \"\\n\\t\\t\".join(commands)\n    logger.debug(f\"Execute commands:\\n\\n\\t\\t{commands_string}\\n\")\n    with tempfile.NamedTemporaryFile(\n        dir=self.scripts_path, suffix=\".ps1\" if self._is_windows() else \".sh\", mode=\"w\", delete=False\n    ) as tmp:\n        if exit_if_command_error:\n            commands = self._insert_command_error_checks(commands)\n        tmp.write(\"\\n\".join(commands))\n        tmp.flush()\n        tmp.close()\n        execute_file = (\n            [\n                \"powershell\",\n                \"-WindowStyle\",\n                \"Hidden\",\n                \"-NoProfile\",\n                \"-ExecutionPolicy\",\n                \"ByPass\",\n                \"-File\",\n                tmp.name,\n            ]\n            if self._is_windows()\n            else [\"/bin/bash\", tmp.name]\n        )\n        if not self._is_windows():\n            subprocess.run([\"chmod\", \"u+x\", tmp.name])\n        logger.debug(f\"Script file: {tmp.name}\")\n\n        if remove_python_env_vars:\n            # Remove environment variables that can interfere with conda/pixi activation\n            # These are typically set by the parent application (e.g., napari) and can cause\n            # Python to use the wrong interpreter or libraries instead of the isolated environment\n            env = popen_kwargs.get(\"env\")\n            vars_to_remove = [\"PYTHONEXECUTABLE\", \"PYTHONHOME\", \"PYTHONPATH\"]\n            # warn if mergedKwargs had an env variable which can cause issues with env activation\n            if env is not None and any(var in vars_to_remove for var in env):\n                logger.warning(f\"Removing variables {vars_to_remove} from env.\")\n\n            if env is None:\n                env = os.environ.copy()\n\n            for var in vars_to_remove:\n                env.pop(var, None)\n            popen_kwargs[\"env\"] = env\n\n        default_popen_kwargs = {\n            \"stdout\": subprocess.PIPE,\n            \"stderr\": subprocess.STDOUT,  # Merge stderr and stdout to handle all them with a single loop\n            \"stdin\": subprocess.DEVNULL,  # Prevent the command to wait for input: instead we want to stop if this happens\n            \"encoding\": \"utf-8\",\n            \"errors\": \"replace\",  # Determines how encoding and decoding errors should be handled: replaces invalid characters with a placeholder (e.g., ? in ASCII).\n            \"bufsize\": 1,  # 1 means line buffered\n        }\n        process = subprocess.Popen(execute_file, **(default_popen_kwargs | popen_kwargs))\n\n        # Create ProcessLogger to handle stdout in background if logging is enabled\n        if log:\n            process_logger = self._create_process_logger(process, log_context)\n\n            # Subscribe to detect CondaSystemExit in real-time during execution\n            def conda_exit_detector(line: str, _context: dict) -&gt; None:\n                if \"CondaSystemExit\" in line:\n                    # Kill process immediately and mark it\n                    self.kill_process(process)\n                    process._conda_exit_detected = True  # type: ignore[attr-defined]\n\n            process_logger.subscribe(conda_exit_detector)\n\n        if wait:\n            process.wait()\n        return process\n</code></pre>"},{"location":"reference/wetlands/_internal/command_executor/#wetlands._internal.command_executor.CommandExecutor.execute_commands_and_get_output","title":"<code>execute_commands_and_get_output(commands, exit_if_command_error=True, popen_kwargs={}, log_context=None)</code>","text":"<p>Executes commands and captures their output. See <code>CommandExecutor.execute_commands</code> for more details on the arguments.</p> <p>Parameters:</p> Name Type Description Default <code>commands</code> <code>list[str]</code> <p>Shell commands to execute.</p> required <code>exit_if_command_error</code> <code>bool</code> <p>Whether to insert error checking.</p> <code>True</code> <code>popen_kwargs</code> <code>dict[str, Any]</code> <p>Keyword arguments for subprocess.Popen().</p> <code>{}</code> <code>log_context</code> <code>dict[str, Any] | None</code> <p>Optional context dict to attach to logs via ProcessLogger.</p> <code>None</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>Output lines (stripped of whitespace).</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If CondaSystemExit detected or non-zero exit code.</p> Source code in <code>wetlands/_internal/command_executor.py</code> <pre><code>def execute_commands_and_get_output(\n    self,\n    commands: list[str],\n    exit_if_command_error: bool = True,\n    popen_kwargs: dict[str, Any] = {},\n    log_context: dict[str, Any] | None = None,\n) -&gt; list[str]:\n    \"\"\"Executes commands and captures their output. See [`CommandExecutor.execute_commands`][wetlands._internal.command_executor.CommandExecutor.execute_commands] for more details on the arguments.\n\n    Args:\n            commands: Shell commands to execute.\n            exit_if_command_error: Whether to insert error checking.\n            popen_kwargs: Keyword arguments for subprocess.Popen().\n            log_context: Optional context dict to attach to logs via ProcessLogger.\n\n    Returns:\n            Output lines (stripped of whitespace).\n\n    Raises:\n            Exception: If CondaSystemExit detected or non-zero exit code.\n    \"\"\"\n    # Always create ProcessLogger to capture output (set log=True internally)\n    process = self.execute_commands(\n        commands,\n        exit_if_command_error=exit_if_command_error,\n        popen_kwargs=popen_kwargs,\n        wait=True,\n        log=True,\n        log_context=log_context,\n    )\n\n    # Get output from ProcessLogger (always created above)\n    process_logger = self._get_complete_process_logger(process)\n    if process_logger is None:\n        return []\n\n    # Check if CondaSystemExit was detected during execution\n    if getattr(process, \"_conda_exit_detected\", False):\n        raise Exception(f'The execution of the commands \"{self._commands_excerpt(commands)}\" failed.')\n\n    output = process_logger.get_output()\n    # Strip whitespace from each line\n    stripped_output = [line.strip() for line in output]\n\n    # Check exit code\n    if process.returncode != 0:\n        raise Exception(f'The execution of the commands \"{self._commands_excerpt(commands)}\" failed.')\n\n    return stripped_output\n</code></pre>"},{"location":"reference/wetlands/_internal/command_executor/#wetlands._internal.command_executor.CommandExecutor.execute_commands_and_get_json_output","title":"<code>execute_commands_and_get_json_output(commands, exit_if_command_error=True, popen_kwargs={})</code>","text":"<p>Execute commands and parse the json output.</p> <p>Parameters:</p> Name Type Description Default <code>commands</code> <code>list[str]</code> <p>Shell commands to execute.</p> required <code>exit_if_command_error</code> <code>bool</code> <p>Whether to insert error checking.</p> <code>True</code> <code>popen_kwargs</code> <code>dict[str, Any]</code> <p>Keyword arguments for subprocess.Popen().</p> <code>{}</code> <p>Returns:</p> Type Description <code>list[dict[str, str]]</code> <p>Output json.</p> Source code in <code>wetlands/_internal/command_executor.py</code> <pre><code>def execute_commands_and_get_json_output(\n    self, commands: list[str], exit_if_command_error: bool = True, popen_kwargs: dict[str, Any] = {}\n) -&gt; list[dict[str, str]]:\n    \"\"\"Execute commands and parse the json output.\n\n    Args:\n            commands: Shell commands to execute.\n            exit_if_command_error: Whether to insert error checking.\n            popen_kwargs: Keyword arguments for subprocess.Popen().\n\n    Returns:\n            Output json.\n    \"\"\"\n    # Execute with wait=True to block until completion\n    process = self.execute_commands(\n        commands, exit_if_command_error=exit_if_command_error, popen_kwargs=popen_kwargs, wait=True, log=True\n    )\n\n    # Get output from ProcessLogger\n    process_logger = self._get_complete_process_logger(process)\n    if process_logger is None:\n        return []\n\n    output = process_logger.get_output()\n    return json.loads(\"\".join(output))\n</code></pre>"},{"location":"reference/wetlands/_internal/command_generator/","title":"Command generator","text":""},{"location":"reference/wetlands/_internal/command_generator/#wetlands._internal.command_generator.CommandGenerator","title":"<code>CommandGenerator</code>","text":"<p>Generate Conda commands.</p> <p>Methods:</p> Name Description <code>get_shell_hook_commands</code> <p>Generates shell commands for Conda initialization.</p> <code>create_mamba_config_file</code> <p>Create Mamba config file .mambarc in conda_path, with nodefaults and conda-forge channels.</p> <code>get_platform_common_name</code> <p>Gets common platform name (mac/linux/windows).</p> <code>get_commands_for_current_platform</code> <p>Selects platform-specific commands from a dictionary.</p> <code>get_activate_conda_commands</code> <p>Generates commands to activate Conda</p> <code>get_activate_environment_commands</code> <p>Generates commands to activate the given environment</p> <code>get_add_channels_commands</code> <p>Add Conda channels in manifest file when using Pixi (<code>pixi add channelName::packageName</code> is not enough, channelName must be in manifest file).</p> Source code in <code>wetlands/_internal/command_generator.py</code> <pre><code>class CommandGenerator:\n    \"\"\"Generate Conda commands.\"\"\"\n\n    def __init__(self, settings_manager: SettingsManager):\n        self.settings_manager = settings_manager\n\n    def get_shell_hook_commands(self) -&gt; list[str]:\n        \"\"\"Generates shell commands for Conda initialization.\n\n        Returns:\n                OS-specific commands to activate Conda shell hooks.\n        \"\"\"\n        current_path = Path.cwd().resolve()\n        conda_path, conda_bin_path = self.settings_manager.get_conda_paths()\n        if self.settings_manager.use_pixi:\n            if platform.system() == \"Windows\":\n                return [f'$env:PATH = \"{conda_path / conda_bin_path.parent};\" + $env:PATH']\n            else:\n                return [f'export PATH=\"{conda_path / conda_bin_path.parent}:$PATH\"']\n        if platform.system() == \"Windows\":\n            return [\n                f'Set-Location -Path \"{conda_path}\"',\n                f'$Env:MAMBA_ROOT_PREFIX=\"{conda_path}\"',\n                f\".\\\\{conda_bin_path} shell hook -s powershell | Out-String | Invoke-Expression\",\n                f'Set-Location -Path \"{current_path}\"',\n            ]\n        else:\n            return [\n                f'cd \"{conda_path}\"',\n                f'export MAMBA_ROOT_PREFIX=\"{conda_path}\"',\n                f'eval \"$({conda_bin_path} shell hook -s posix)\"',\n                f'cd \"{current_path}\"',\n            ]\n\n    def create_mamba_config_file(self, conda_path):\n        \"\"\"Create Mamba config file .mambarc in conda_path, with nodefaults and conda-forge channels.\"\"\"\n        if self.settings_manager.use_pixi:\n            return\n        with open(conda_path / \".mambarc\", \"w\") as f:\n            mamba_settings = dict(\n                channel_priority=\"flexible\",\n                channels=[\"conda-forge\", \"nodefaults\"],\n                default_channels=[\"conda-forge\"],\n            )\n            yaml.safe_dump(mamba_settings, f)\n\n    def get_platform_common_name(self) -&gt; str:\n        \"\"\"Gets common platform name (mac/linux/windows).\"\"\"\n        return \"mac\" if platform.system() == \"Darwin\" else platform.system().lower()\n\n    def to_commands_dict(self, commands: Commands) -&gt; CommandsDict:\n        return {\"all\": commands} if isinstance(commands, list) else commands\n\n    def get_commands_for_current_platform(self, additional_commands: Commands = {}) -&gt; list[str]:\n        \"\"\"Selects platform-specific commands from a dictionary.\n\n        Args:\n                additional_commands: Dictionary mapping platforms to command lists (e.g. dict(all=[], linux=['wget \"http://something.cool\"']) ).\n\n        Returns:\n                Merged list of commands for 'all' and current platform.\n        \"\"\"\n        commands = []\n        if additional_commands is None:\n            return commands\n        additional_commands_dict = self.to_commands_dict(additional_commands)\n        for name in [\"all\", self.get_platform_common_name()]:\n            commands += additional_commands_dict.get(name, [])\n        return commands\n\n    def get_activate_conda_commands(self) -&gt; list[str]:\n        \"\"\"Generates commands to activate Conda\"\"\"\n        # Previouly, this function was also installing Conda if necessary\n        return self.get_shell_hook_commands()\n\n    def get_activate_environment_commands(\n        self, environment: \"Environment\", additional_activate_commands: Commands = {}, activate_conda: bool = True\n    ) -&gt; list[str]:\n        \"\"\"Generates commands to activate the given environment\n\n        Args:\n                environment: Environment name to launch. If none, the resulting command list will be empty.\n                additional_activate_commands: Platform-specific activation commands.\n                activate_conda: Whether to activate Conda or not.\n\n        Returns:\n                List of commands to activate the environment\n        \"\"\"\n        if environment is None:\n            return []\n        commands = self.get_activate_conda_commands() if activate_conda else []\n        if self.settings_manager.use_pixi:\n            # Warning: Use `pixi shell-hook` instead of `pixi shell` since `pixi shell` creates a new shell (and we want to keep the same shell)\n            if platform.system() != \"Windows\":\n                commands += [\n                    f'eval \"$({self.settings_manager.conda_bin} shell-hook --manifest-path \"{environment.path}\")\"'\n                ]\n            else:\n                commands += [\n                    f'{self.settings_manager.conda_bin} shell-hook --manifest-path \"{environment.path}\" | Out-String | Invoke-Expression'\n                ]\n        else:\n            commands += [f\"{self.settings_manager.conda_bin} activate {environment.path}\"]\n        return commands + self.get_commands_for_current_platform(additional_activate_commands)\n\n    def get_add_channels_commands(\n        self,\n        environment: \"Environment\",\n        channels: list[str],\n        conda_dependencies: list[str],\n        activate_conda: bool = True,\n    ) -&gt; list[str]:\n        \"\"\"Add Conda channels in manifest file when using Pixi (`pixi add channelName::packageName` is not enough, channelName must be in manifest file).\n        The returned command will be something like `pixi project add --manifest-path \"/path/to/pixi.toml\" --prepend channel1 channel2`.\n\n        Args:\n                environment: Environment name.\n                condaChannels: The channels to add.\n                conda_dependencies: The conda dependecies to install (e.g. [\"bioimageit::atlas\", \"openjdk\"]).\n                activate_conda: Whether to activate conda or not.\n\n        Returns:\n                List of commands to add required channels\n        \"\"\"\n        if not self.settings_manager.use_pixi:\n            if len(channels) &gt; 0:\n                return [f\"{self.settings_manager.conda_bin_config} config --add channels \" + \" \".join(channels)]\n            else:\n                return []\n        channels += set([dep.split(\"::\")[0].replace('\"', \"\") for dep in conda_dependencies if \"::\" in dep])\n        if len(channels) == 0:\n            return []\n        commands = self.get_activate_conda_commands() if activate_conda else []\n        commands += [\n            f'{self.settings_manager.conda_bin} project channel add --manifest-path \"{environment.path}\" --no-progress --prepend '\n            + \" \".join(channels)\n        ]\n        return commands\n</code></pre>"},{"location":"reference/wetlands/_internal/command_generator/#wetlands._internal.command_generator.CommandGenerator.get_shell_hook_commands","title":"<code>get_shell_hook_commands()</code>","text":"<p>Generates shell commands for Conda initialization.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>OS-specific commands to activate Conda shell hooks.</p> Source code in <code>wetlands/_internal/command_generator.py</code> <pre><code>def get_shell_hook_commands(self) -&gt; list[str]:\n    \"\"\"Generates shell commands for Conda initialization.\n\n    Returns:\n            OS-specific commands to activate Conda shell hooks.\n    \"\"\"\n    current_path = Path.cwd().resolve()\n    conda_path, conda_bin_path = self.settings_manager.get_conda_paths()\n    if self.settings_manager.use_pixi:\n        if platform.system() == \"Windows\":\n            return [f'$env:PATH = \"{conda_path / conda_bin_path.parent};\" + $env:PATH']\n        else:\n            return [f'export PATH=\"{conda_path / conda_bin_path.parent}:$PATH\"']\n    if platform.system() == \"Windows\":\n        return [\n            f'Set-Location -Path \"{conda_path}\"',\n            f'$Env:MAMBA_ROOT_PREFIX=\"{conda_path}\"',\n            f\".\\\\{conda_bin_path} shell hook -s powershell | Out-String | Invoke-Expression\",\n            f'Set-Location -Path \"{current_path}\"',\n        ]\n    else:\n        return [\n            f'cd \"{conda_path}\"',\n            f'export MAMBA_ROOT_PREFIX=\"{conda_path}\"',\n            f'eval \"$({conda_bin_path} shell hook -s posix)\"',\n            f'cd \"{current_path}\"',\n        ]\n</code></pre>"},{"location":"reference/wetlands/_internal/command_generator/#wetlands._internal.command_generator.CommandGenerator.create_mamba_config_file","title":"<code>create_mamba_config_file(conda_path)</code>","text":"<p>Create Mamba config file .mambarc in conda_path, with nodefaults and conda-forge channels.</p> Source code in <code>wetlands/_internal/command_generator.py</code> <pre><code>def create_mamba_config_file(self, conda_path):\n    \"\"\"Create Mamba config file .mambarc in conda_path, with nodefaults and conda-forge channels.\"\"\"\n    if self.settings_manager.use_pixi:\n        return\n    with open(conda_path / \".mambarc\", \"w\") as f:\n        mamba_settings = dict(\n            channel_priority=\"flexible\",\n            channels=[\"conda-forge\", \"nodefaults\"],\n            default_channels=[\"conda-forge\"],\n        )\n        yaml.safe_dump(mamba_settings, f)\n</code></pre>"},{"location":"reference/wetlands/_internal/command_generator/#wetlands._internal.command_generator.CommandGenerator.get_platform_common_name","title":"<code>get_platform_common_name()</code>","text":"<p>Gets common platform name (mac/linux/windows).</p> Source code in <code>wetlands/_internal/command_generator.py</code> <pre><code>def get_platform_common_name(self) -&gt; str:\n    \"\"\"Gets common platform name (mac/linux/windows).\"\"\"\n    return \"mac\" if platform.system() == \"Darwin\" else platform.system().lower()\n</code></pre>"},{"location":"reference/wetlands/_internal/command_generator/#wetlands._internal.command_generator.CommandGenerator.get_commands_for_current_platform","title":"<code>get_commands_for_current_platform(additional_commands={})</code>","text":"<p>Selects platform-specific commands from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>additional_commands</code> <code>Commands</code> <p>Dictionary mapping platforms to command lists (e.g. dict(all=[], linux=['wget \"http://something.cool\"']) ).</p> <code>{}</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>Merged list of commands for 'all' and current platform.</p> Source code in <code>wetlands/_internal/command_generator.py</code> <pre><code>def get_commands_for_current_platform(self, additional_commands: Commands = {}) -&gt; list[str]:\n    \"\"\"Selects platform-specific commands from a dictionary.\n\n    Args:\n            additional_commands: Dictionary mapping platforms to command lists (e.g. dict(all=[], linux=['wget \"http://something.cool\"']) ).\n\n    Returns:\n            Merged list of commands for 'all' and current platform.\n    \"\"\"\n    commands = []\n    if additional_commands is None:\n        return commands\n    additional_commands_dict = self.to_commands_dict(additional_commands)\n    for name in [\"all\", self.get_platform_common_name()]:\n        commands += additional_commands_dict.get(name, [])\n    return commands\n</code></pre>"},{"location":"reference/wetlands/_internal/command_generator/#wetlands._internal.command_generator.CommandGenerator.get_activate_conda_commands","title":"<code>get_activate_conda_commands()</code>","text":"<p>Generates commands to activate Conda</p> Source code in <code>wetlands/_internal/command_generator.py</code> <pre><code>def get_activate_conda_commands(self) -&gt; list[str]:\n    \"\"\"Generates commands to activate Conda\"\"\"\n    # Previouly, this function was also installing Conda if necessary\n    return self.get_shell_hook_commands()\n</code></pre>"},{"location":"reference/wetlands/_internal/command_generator/#wetlands._internal.command_generator.CommandGenerator.get_activate_environment_commands","title":"<code>get_activate_environment_commands(environment, additional_activate_commands={}, activate_conda=True)</code>","text":"<p>Generates commands to activate the given environment</p> <p>Parameters:</p> Name Type Description Default <code>environment</code> <code>Environment</code> <p>Environment name to launch. If none, the resulting command list will be empty.</p> required <code>additional_activate_commands</code> <code>Commands</code> <p>Platform-specific activation commands.</p> <code>{}</code> <code>activate_conda</code> <code>bool</code> <p>Whether to activate Conda or not.</p> <code>True</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of commands to activate the environment</p> Source code in <code>wetlands/_internal/command_generator.py</code> <pre><code>def get_activate_environment_commands(\n    self, environment: \"Environment\", additional_activate_commands: Commands = {}, activate_conda: bool = True\n) -&gt; list[str]:\n    \"\"\"Generates commands to activate the given environment\n\n    Args:\n            environment: Environment name to launch. If none, the resulting command list will be empty.\n            additional_activate_commands: Platform-specific activation commands.\n            activate_conda: Whether to activate Conda or not.\n\n    Returns:\n            List of commands to activate the environment\n    \"\"\"\n    if environment is None:\n        return []\n    commands = self.get_activate_conda_commands() if activate_conda else []\n    if self.settings_manager.use_pixi:\n        # Warning: Use `pixi shell-hook` instead of `pixi shell` since `pixi shell` creates a new shell (and we want to keep the same shell)\n        if platform.system() != \"Windows\":\n            commands += [\n                f'eval \"$({self.settings_manager.conda_bin} shell-hook --manifest-path \"{environment.path}\")\"'\n            ]\n        else:\n            commands += [\n                f'{self.settings_manager.conda_bin} shell-hook --manifest-path \"{environment.path}\" | Out-String | Invoke-Expression'\n            ]\n    else:\n        commands += [f\"{self.settings_manager.conda_bin} activate {environment.path}\"]\n    return commands + self.get_commands_for_current_platform(additional_activate_commands)\n</code></pre>"},{"location":"reference/wetlands/_internal/command_generator/#wetlands._internal.command_generator.CommandGenerator.get_add_channels_commands","title":"<code>get_add_channels_commands(environment, channels, conda_dependencies, activate_conda=True)</code>","text":"<p>Add Conda channels in manifest file when using Pixi (<code>pixi add channelName::packageName</code> is not enough, channelName must be in manifest file). The returned command will be something like <code>pixi project add --manifest-path \"/path/to/pixi.toml\" --prepend channel1 channel2</code>.</p> <p>Parameters:</p> Name Type Description Default <code>environment</code> <code>Environment</code> <p>Environment name.</p> required <code>condaChannels</code> <p>The channels to add.</p> required <code>conda_dependencies</code> <code>list[str]</code> <p>The conda dependecies to install (e.g. [\"bioimageit::atlas\", \"openjdk\"]).</p> required <code>activate_conda</code> <code>bool</code> <p>Whether to activate conda or not.</p> <code>True</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of commands to add required channels</p> Source code in <code>wetlands/_internal/command_generator.py</code> <pre><code>def get_add_channels_commands(\n    self,\n    environment: \"Environment\",\n    channels: list[str],\n    conda_dependencies: list[str],\n    activate_conda: bool = True,\n) -&gt; list[str]:\n    \"\"\"Add Conda channels in manifest file when using Pixi (`pixi add channelName::packageName` is not enough, channelName must be in manifest file).\n    The returned command will be something like `pixi project add --manifest-path \"/path/to/pixi.toml\" --prepend channel1 channel2`.\n\n    Args:\n            environment: Environment name.\n            condaChannels: The channels to add.\n            conda_dependencies: The conda dependecies to install (e.g. [\"bioimageit::atlas\", \"openjdk\"]).\n            activate_conda: Whether to activate conda or not.\n\n    Returns:\n            List of commands to add required channels\n    \"\"\"\n    if not self.settings_manager.use_pixi:\n        if len(channels) &gt; 0:\n            return [f\"{self.settings_manager.conda_bin_config} config --add channels \" + \" \".join(channels)]\n        else:\n            return []\n    channels += set([dep.split(\"::\")[0].replace('\"', \"\") for dep in conda_dependencies if \"::\" in dep])\n    if len(channels) == 0:\n        return []\n    commands = self.get_activate_conda_commands() if activate_conda else []\n    commands += [\n        f'{self.settings_manager.conda_bin} project channel add --manifest-path \"{environment.path}\" --no-progress --prepend '\n        + \" \".join(channels)\n    ]\n    return commands\n</code></pre>"},{"location":"reference/wetlands/_internal/config_parser/","title":"Config parser","text":"<p>Parser for configuration files (pixi.toml, pyproject.toml, environment.yml).</p>"},{"location":"reference/wetlands/_internal/config_parser/#wetlands._internal.config_parser.ConfigParser","title":"<code>ConfigParser</code>","text":"<p>Parse dependency configurations from various file formats.</p> <p>Methods:</p> Name Description <code>parse</code> <p>Parse configuration file and extract dependencies.</p> <code>detect_config_file_type</code> <p>Detect the type of configuration file.</p> <code>parse_pixi_toml</code> <p>Parse pixi.toml file and extract dependencies.</p> <code>parse_pyproject_toml</code> <p>Parse pyproject.toml file and extract dependencies.</p> <code>parse_environment_yml</code> <p>Parse environment.yml file and extract dependencies.</p> <code>parse_requirements_txt</code> <p>Parse requirements.txt file and extract dependencies.</p> Source code in <code>wetlands/_internal/config_parser.py</code> <pre><code>class ConfigParser:\n    \"\"\"Parse dependency configurations from various file formats.\"\"\"\n\n    def _format_dependency(self, name: str, version: str) -&gt; str:\n        \"\"\"Format a dependency with its version spec.\n\n        Args:\n            name: Package name\n            version: Version spec (e.g., \"&gt;=2.25\", \"*\", \"1.0.0\")\n\n        Returns:\n            Formatted dependency string (e.g., \"requests&gt;=2.25\", \"requests\")\n        \"\"\"\n        if version == \"*\" or not version:\n            return name\n        # If version already starts with a comparison operator, just concatenate\n        if version.startswith((\"&gt;=\", \"&lt;=\", \"==\", \"!=\", \"&gt;\", \"&lt;\", \"~=\", \"^\")):\n            return f\"{name}{version}\"\n        # Otherwise assume it's an exact version\n        return f\"{name}=={version}\"\n\n    def parse(\n        self,\n        config_path: Union[str, Path],\n        environment_name: Optional[str] = None,\n        optional_dependencies: Optional[list[str]] = None,\n    ) -&gt; Dependencies:\n        \"\"\"Parse configuration file and extract dependencies.\n\n        Args:\n            config_path: Path to configuration file (pixi.toml, pyproject.toml, environment.yml, or requirements.txt)\n            environment_name: Environment name to use (for pixi.toml and pyproject.toml)\n            optional_dependencies: Optional dependency groups to include (for pyproject.toml)\n\n        Returns:\n            Dependencies dict with conda, pip, and python keys\n\n        Raises:\n            FileNotFoundError: If config file doesn't exist\n            ValueError: If config format is unsupported or parameters invalid\n            Exception: If file parsing fails\n        \"\"\"\n        config_path = Path(config_path)\n\n        if not config_path.exists():\n            raise FileNotFoundError(f\"Config file not found: {config_path}\")\n\n        file_type = self.detect_config_file_type(config_path)\n\n        if file_type == \"pixi\":\n            return self.parse_pixi_toml(config_path, environment_name)\n        elif file_type == \"pyproject\":\n            return self.parse_pyproject_toml(\n                config_path,\n                environment_name=environment_name,\n                optional_dependencies=optional_dependencies,\n            )\n        elif file_type == \"environment\":\n            return self.parse_environment_yml(config_path)\n        elif file_type == \"requirements\":\n            return self.parse_requirements_txt(config_path)\n        else:\n            raise ValueError(f\"Unsupported config file type: {file_type}\")\n\n    def detect_config_file_type(self, config_path: Union[str, Path]) -&gt; str:\n        \"\"\"Detect the type of configuration file.\n\n        Args:\n            config_path: Path to configuration file\n\n        Returns:\n            \"pixi\", \"pyproject\", \"environment\", or \"requirements\"\n\n        Raises:\n            ValueError: If file type is not supported\n        \"\"\"\n        config_path = Path(config_path)\n        name = config_path.name.lower()\n\n        if name == \"pixi.toml\":\n            return \"pixi\"\n        elif name == \"pyproject.toml\":\n            return \"pyproject\"\n        elif name in [\"environment.yml\", \"environment.yaml\"]:\n            return \"environment\"\n        elif name == \"requirements.txt\":\n            return \"requirements\"\n        else:\n            raise ValueError(\n                f\"Unsupported config file type: {name}. \"\n                \"Expected pixi.toml, pyproject.toml, environment.yml, or requirements.txt\"\n            )\n\n    def parse_pixi_toml(\n        self,\n        pixi_path: Union[str, Path],\n        environment_name: Optional[str] = None,\n    ) -&gt; Dependencies:\n        \"\"\"Parse pixi.toml file and extract dependencies.\n\n        Supports both native pixi.toml format (with top-level [workspace], [dependencies])\n        and embedded format (with [tool.pixi.*] sections).\n\n        Args:\n            pixi_path: Path to pixi.toml file\n            environment_name: Name of environment to extract (optional - falls back to default)\n\n        Returns:\n            Dependencies dict\n\n        Raises:\n            FileNotFoundError: If file doesn't exist\n            ValueError: If no valid environment found\n            Exception: If TOML parsing fails\n        \"\"\"\n        pixi_path = Path(pixi_path)\n\n        if not pixi_path.exists():\n            raise FileNotFoundError(f\"pixi.toml not found: {pixi_path}\")\n\n        with open(pixi_path, \"rb\") as f:\n            config = tomllib.load(f)\n\n        # Detect if this is native pixi.toml format or embedded in [tool.pixi]\n        # Native format has [workspace] or [dependencies] at top level\n        # Embedded format has [tool.pixi.workspace] or [tool.pixi.dependencies]\n        is_native_format = \"workspace\" in config or \"dependencies\" in config or \"pypi-dependencies\" in config\n\n        if is_native_format:\n            return self._parse_native_pixi_toml(config, environment_name)\n        else:\n            return self._parse_embedded_pixi_toml(config, environment_name)\n\n    def _parse_native_pixi_toml(\n        self,\n        config: dict,\n        environment_name: Optional[str] = None,\n    ) -&gt; Dependencies:\n        \"\"\"Parse native pixi.toml format with top-level sections.\"\"\"\n        dependencies: Dependencies = {}\n\n        # Get environments if defined\n        environments = config.get(\"environments\", {})\n\n        # Determine which environment to use\n        env_to_use = environment_name\n        if env_to_use and env_to_use not in environments:\n            env_to_use = \"default\"\n\n        if not env_to_use:\n            env_to_use = \"default\"\n\n        # Get features for this environment (empty list if no environments defined)\n        features: list[str] = []\n        if environments and env_to_use in environments:\n            env_config = environments[env_to_use]\n            if isinstance(env_config, dict):\n                features = env_config.get(\"features\", [])\n            elif isinstance(env_config, list):\n                features = env_config\n\n        # Extract python version from dependencies\n        base_deps = config.get(\"dependencies\", {})\n        if \"python\" in base_deps:\n            dependencies[\"python\"] = base_deps[\"python\"]\n\n        # Collect dependencies with version specs\n        conda_deps = []\n        pip_deps = []\n\n        # Base dependencies (combine name with version spec)\n        for name, version in base_deps.items():\n            if name != \"python\":\n                conda_deps.append(self._format_dependency(name, version))\n\n        for name, version in config.get(\"pypi-dependencies\", {}).items():\n            pip_deps.append(self._format_dependency(name, version))\n\n        # Feature dependencies\n        features_config = config.get(\"feature\", {})\n        for feature_name in features:\n            if feature_name in features_config:\n                feature = features_config[feature_name]\n                for name, version in feature.get(\"dependencies\", {}).items():\n                    if name != \"python\":\n                        conda_deps.append(self._format_dependency(name, version))\n                for name, version in feature.get(\"pypi-dependencies\", {}).items():\n                    pip_deps.append(self._format_dependency(name, version))\n\n        # Remove duplicates\n        conda_deps = list(set(conda_deps))\n        pip_deps = list(set(pip_deps))\n\n        if conda_deps:\n            dependencies[\"conda\"] = conda_deps\n        if pip_deps:\n            dependencies[\"pip\"] = pip_deps\n\n        return dependencies\n\n    def _parse_embedded_pixi_toml(\n        self,\n        config: dict,\n        environment_name: Optional[str] = None,\n    ) -&gt; Dependencies:\n        \"\"\"Parse embedded pixi.toml format with [tool.pixi.*] sections.\"\"\"\n        pixi_config = config.get(\"tool\", {}).get(\"pixi\", {})\n\n        # Get environment configuration\n        environments = pixi_config.get(\"environments\", {})\n\n        # Determine which environment to use\n        env_to_use = environment_name\n        if env_to_use and env_to_use not in environments:\n            env_to_use = \"default\"\n\n        if not env_to_use:\n            env_to_use = \"default\"\n\n        if env_to_use not in environments:\n            available = list(environments.keys())\n            raise ValueError(f\"Environment '{env_to_use}' not found in pixi.toml. Available environments: {available}\")\n\n        env_config = environments[env_to_use]\n        features = env_config.get(\"features\", [])\n\n        # Start with base dependencies\n        dependencies: Dependencies = {}\n\n        # Extract python version\n        if \"python\" in pixi_config.get(\"dependencies\", {}):\n            dependencies[\"python\"] = pixi_config[\"dependencies\"][\"python\"]\n\n        # Collect dependencies from features and base\n        conda_deps = []\n        pip_deps = []\n\n        # Base dependencies (combine name with version spec)\n        for name, version in pixi_config.get(\"dependencies\", {}).items():\n            if name != \"python\":\n                conda_deps.append(self._format_dependency(name, version))\n\n        for name, version in pixi_config.get(\"pypi-dependencies\", {}).items():\n            pip_deps.append(self._format_dependency(name, version))\n\n        # Feature dependencies\n        features_config = pixi_config.get(\"feature\", {})\n        for feature_name in features:\n            if feature_name in features_config:\n                feature = features_config[feature_name]\n                for name, version in feature.get(\"dependencies\", {}).items():\n                    if name != \"python\":\n                        conda_deps.append(self._format_dependency(name, version))\n                for name, version in feature.get(\"pypi-dependencies\", {}).items():\n                    pip_deps.append(self._format_dependency(name, version))\n\n        # Remove duplicates\n        conda_deps = list(set(conda_deps))\n        pip_deps = list(set(pip_deps))\n\n        if conda_deps:\n            dependencies[\"conda\"] = conda_deps\n        if pip_deps:\n            dependencies[\"pip\"] = pip_deps\n\n        return dependencies\n\n    def parse_pyproject_toml(\n        self,\n        pyproject_path: Union[str, Path],\n        environment_name: Optional[str] = None,\n        optional_dependencies: Optional[list[str]] = None,\n    ) -&gt; Dependencies:\n        \"\"\"Parse pyproject.toml file and extract dependencies.\n\n        Args:\n            pyproject_path: Path to pyproject.toml file\n            environment_name: Name of pixi environment to extract\n            optional_dependencies: List of optional dependency groups to include\n\n        Returns:\n            Dependencies dict\n\n        Raises:\n            FileNotFoundError: If file doesn't exist\n            ValueError: If required parameters missing or not found\n            Exception: If TOML parsing fails\n        \"\"\"\n        pyproject_path = Path(pyproject_path)\n\n        if not pyproject_path.exists():\n            raise FileNotFoundError(f\"pyproject.toml not found: {pyproject_path}\")\n\n        with open(pyproject_path, \"rb\") as f:\n            config = tomllib.load(f)\n\n        dependencies: Dependencies = {}\n        pixi_config = config.get(\"tool\", {}).get(\"pixi\", {})\n\n        # If pixi config exists, use it (like pixi.toml)\n        if pixi_config:\n            if environment_name or not optional_dependencies:\n                # Use pixi environment if environment_name provided, or if no optional_dependencies\n                environments = pixi_config.get(\"environments\", {})\n\n                # Determine which environment to use\n                env_to_use = environment_name\n                if env_to_use and env_to_use not in environments:\n                    # Fall back to default if requested environment doesn't exist\n                    env_to_use = \"default\"\n\n                if not env_to_use:\n                    # No environment_name provided, use default\n                    env_to_use = \"default\"\n\n                # Get features for this environment (empty list if no environments defined)\n                features: list[str] = []\n                if environments and env_to_use in environments:\n                    env_config = environments[env_to_use]\n                    if isinstance(env_config, dict):\n                        features = env_config.get(\"features\", [])\n                    elif isinstance(env_config, list):\n                        features = env_config\n\n                # Extract python version\n                if \"python\" in pixi_config.get(\"dependencies\", {}):\n                    dependencies[\"python\"] = pixi_config[\"dependencies\"][\"python\"]\n\n                # Collect dependencies from features and base\n                conda_deps = []\n                pip_deps = []\n\n                # Base dependencies (combine name with version spec)\n                for name, version in pixi_config.get(\"dependencies\", {}).items():\n                    if name != \"python\":\n                        conda_deps.append(self._format_dependency(name, version))\n\n                for name, version in pixi_config.get(\"pypi-dependencies\", {}).items():\n                    pip_deps.append(self._format_dependency(name, version))\n\n                # Feature dependencies\n                features_config = pixi_config.get(\"feature\", {})\n                for feature_name in features:\n                    if feature_name in features_config:\n                        feature = features_config[feature_name]\n                        for name, version in feature.get(\"dependencies\", {}).items():\n                            if name != \"python\":\n                                conda_deps.append(self._format_dependency(name, version))\n                        for name, version in feature.get(\"pypi-dependencies\", {}).items():\n                            pip_deps.append(self._format_dependency(name, version))\n\n                # Remove duplicates\n                conda_deps = list(set(conda_deps))\n                pip_deps = list(set(pip_deps))\n\n                if conda_deps:\n                    dependencies[\"conda\"] = conda_deps\n                if pip_deps:\n                    dependencies[\"pip\"] = pip_deps\n\n            elif optional_dependencies:\n                # Use pixi features as optional dependencies\n                features_config = pixi_config.get(\"feature\", {})\n                conda_deps = []\n                pip_deps = []\n\n                for feature_name in optional_dependencies:\n                    if feature_name not in features_config:\n                        available = list(features_config.keys())\n                        raise ValueError(\n                            f\"Feature '{feature_name}' not found in pyproject.toml. Available features: {available}\"\n                        )\n\n                    feature = features_config[feature_name]\n                    for name, version in feature.get(\"dependencies\", {}).items():\n                        if name != \"python\":\n                            conda_deps.append(self._format_dependency(name, version))\n                    for name, version in feature.get(\"pypi-dependencies\", {}).items():\n                        pip_deps.append(self._format_dependency(name, version))\n\n                # Remove duplicates\n                conda_deps = list(set(conda_deps))\n                pip_deps = list(set(pip_deps))\n\n                if conda_deps:\n                    dependencies[\"conda\"] = conda_deps\n                if pip_deps:\n                    dependencies[\"pip\"] = pip_deps\n            else:\n                raise ValueError(\n                    \"For pyproject.toml with pixi config, provide either environment_name or optional_dependencies\"\n                )\n        else:\n            # Standard PEP 621 pyproject.toml (no pixi config)\n            project_config = config.get(\"project\", {})\n\n            # Main dependencies go to pip\n            main_deps = project_config.get(\"dependencies\", [])\n            if main_deps:\n                dependencies[\"pip\"] = main_deps\n\n            # Optional dependencies\n            if optional_dependencies:\n                optional_deps = project_config.get(\"optional-dependencies\", {})\n                pip_deps = dependencies.get(\"pip\", [])\n\n                for group_name in optional_dependencies:\n                    if group_name not in optional_deps:\n                        available = list(optional_deps.keys())\n                        raise ValueError(\n                            f\"Optional dependency group '{group_name}' not found. Available groups: {available}\"\n                        )\n\n                    pip_deps.extend(optional_deps[group_name])\n\n                if pip_deps:\n                    dependencies[\"pip\"] = list(set(pip_deps))\n\n        return dependencies\n\n    def parse_environment_yml(\n        self,\n        env_path: Union[str, Path],\n    ) -&gt; Dependencies:\n        \"\"\"Parse environment.yml file and extract dependencies.\n\n        Args:\n            env_path: Path to environment.yml file\n\n        Returns:\n            Dependencies dict with conda and pip keys\n\n        Raises:\n            FileNotFoundError: If file doesn't exist\n            Exception: If YAML parsing fails\n        \"\"\"\n        env_path = Path(env_path)\n\n        if not env_path.exists():\n            raise FileNotFoundError(f\"environment.yml not found: {env_path}\")\n\n        with open(env_path, \"r\") as f:\n            config = yaml.safe_load(f)\n\n        dependencies: Dependencies = {}\n\n        if not config or not isinstance(config, dict):\n            return dependencies\n\n        # Process dependencies list\n        deps_list = config.get(\"dependencies\", [])\n        conda_deps = []\n        pip_deps = []\n\n        for dep in deps_list:\n            if isinstance(dep, str):\n                if dep == \"pip\":\n                    # Skip the 'pip' marker itself\n                    continue\n                else:\n                    # Regular conda dependency\n                    conda_deps.append(dep)\n            elif isinstance(dep, dict):\n                # Nested pip dependencies\n                for key, value in dep.items():\n                    if key == \"pip\" and isinstance(value, list):\n                        pip_deps.extend(value)\n\n        if conda_deps:\n            dependencies[\"conda\"] = conda_deps\n        if pip_deps:\n            dependencies[\"pip\"] = pip_deps\n\n        return dependencies\n\n    def parse_requirements_txt(\n        self,\n        requirements_path: Union[str, Path],\n    ) -&gt; Dependencies:\n        \"\"\"Parse requirements.txt file and extract dependencies.\n\n        Args:\n            requirements_path: Path to requirements.txt file\n\n        Returns:\n            Dependencies dict with pip key containing all dependencies\n\n        Raises:\n            FileNotFoundError: If file doesn't exist\n            Exception: If file reading fails\n        \"\"\"\n        requirements_path = Path(requirements_path)\n\n        if not requirements_path.exists():\n            raise FileNotFoundError(f\"requirements.txt not found: {requirements_path}\")\n\n        pip_deps = []\n\n        with open(requirements_path, \"r\") as f:\n            for line in f:\n                line = line.strip()\n\n                # Skip empty lines and comments\n                if not line or line.startswith(\"#\"):\n                    continue\n\n                # Skip environment markers (e.g., lines with ; python_version)\n                if \";\" in line:\n                    line = line.split(\";\")[0].strip()\n\n                if line:\n                    pip_deps.append(line)\n\n        dependencies: Dependencies = {}\n        if pip_deps:\n            dependencies[\"pip\"] = pip_deps\n\n        return dependencies\n</code></pre>"},{"location":"reference/wetlands/_internal/config_parser/#wetlands._internal.config_parser.ConfigParser.parse","title":"<code>parse(config_path, environment_name=None, optional_dependencies=None)</code>","text":"<p>Parse configuration file and extract dependencies.</p> <p>Parameters:</p> Name Type Description Default <code>config_path</code> <code>Union[str, Path]</code> <p>Path to configuration file (pixi.toml, pyproject.toml, environment.yml, or requirements.txt)</p> required <code>environment_name</code> <code>Optional[str]</code> <p>Environment name to use (for pixi.toml and pyproject.toml)</p> <code>None</code> <code>optional_dependencies</code> <code>Optional[list[str]]</code> <p>Optional dependency groups to include (for pyproject.toml)</p> <code>None</code> <p>Returns:</p> Type Description <code>Dependencies</code> <p>Dependencies dict with conda, pip, and python keys</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If config file doesn't exist</p> <code>ValueError</code> <p>If config format is unsupported or parameters invalid</p> <code>Exception</code> <p>If file parsing fails</p> Source code in <code>wetlands/_internal/config_parser.py</code> <pre><code>def parse(\n    self,\n    config_path: Union[str, Path],\n    environment_name: Optional[str] = None,\n    optional_dependencies: Optional[list[str]] = None,\n) -&gt; Dependencies:\n    \"\"\"Parse configuration file and extract dependencies.\n\n    Args:\n        config_path: Path to configuration file (pixi.toml, pyproject.toml, environment.yml, or requirements.txt)\n        environment_name: Environment name to use (for pixi.toml and pyproject.toml)\n        optional_dependencies: Optional dependency groups to include (for pyproject.toml)\n\n    Returns:\n        Dependencies dict with conda, pip, and python keys\n\n    Raises:\n        FileNotFoundError: If config file doesn't exist\n        ValueError: If config format is unsupported or parameters invalid\n        Exception: If file parsing fails\n    \"\"\"\n    config_path = Path(config_path)\n\n    if not config_path.exists():\n        raise FileNotFoundError(f\"Config file not found: {config_path}\")\n\n    file_type = self.detect_config_file_type(config_path)\n\n    if file_type == \"pixi\":\n        return self.parse_pixi_toml(config_path, environment_name)\n    elif file_type == \"pyproject\":\n        return self.parse_pyproject_toml(\n            config_path,\n            environment_name=environment_name,\n            optional_dependencies=optional_dependencies,\n        )\n    elif file_type == \"environment\":\n        return self.parse_environment_yml(config_path)\n    elif file_type == \"requirements\":\n        return self.parse_requirements_txt(config_path)\n    else:\n        raise ValueError(f\"Unsupported config file type: {file_type}\")\n</code></pre>"},{"location":"reference/wetlands/_internal/config_parser/#wetlands._internal.config_parser.ConfigParser.detect_config_file_type","title":"<code>detect_config_file_type(config_path)</code>","text":"<p>Detect the type of configuration file.</p> <p>Parameters:</p> Name Type Description Default <code>config_path</code> <code>Union[str, Path]</code> <p>Path to configuration file</p> required <p>Returns:</p> Type Description <code>str</code> <p>\"pixi\", \"pyproject\", \"environment\", or \"requirements\"</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If file type is not supported</p> Source code in <code>wetlands/_internal/config_parser.py</code> <pre><code>def detect_config_file_type(self, config_path: Union[str, Path]) -&gt; str:\n    \"\"\"Detect the type of configuration file.\n\n    Args:\n        config_path: Path to configuration file\n\n    Returns:\n        \"pixi\", \"pyproject\", \"environment\", or \"requirements\"\n\n    Raises:\n        ValueError: If file type is not supported\n    \"\"\"\n    config_path = Path(config_path)\n    name = config_path.name.lower()\n\n    if name == \"pixi.toml\":\n        return \"pixi\"\n    elif name == \"pyproject.toml\":\n        return \"pyproject\"\n    elif name in [\"environment.yml\", \"environment.yaml\"]:\n        return \"environment\"\n    elif name == \"requirements.txt\":\n        return \"requirements\"\n    else:\n        raise ValueError(\n            f\"Unsupported config file type: {name}. \"\n            \"Expected pixi.toml, pyproject.toml, environment.yml, or requirements.txt\"\n        )\n</code></pre>"},{"location":"reference/wetlands/_internal/config_parser/#wetlands._internal.config_parser.ConfigParser.parse_pixi_toml","title":"<code>parse_pixi_toml(pixi_path, environment_name=None)</code>","text":"<p>Parse pixi.toml file and extract dependencies.</p> <p>Supports both native pixi.toml format (with top-level [workspace], [dependencies]) and embedded format (with [tool.pixi.*] sections).</p> <p>Parameters:</p> Name Type Description Default <code>pixi_path</code> <code>Union[str, Path]</code> <p>Path to pixi.toml file</p> required <code>environment_name</code> <code>Optional[str]</code> <p>Name of environment to extract (optional - falls back to default)</p> <code>None</code> <p>Returns:</p> Type Description <code>Dependencies</code> <p>Dependencies dict</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If file doesn't exist</p> <code>ValueError</code> <p>If no valid environment found</p> <code>Exception</code> <p>If TOML parsing fails</p> Source code in <code>wetlands/_internal/config_parser.py</code> <pre><code>def parse_pixi_toml(\n    self,\n    pixi_path: Union[str, Path],\n    environment_name: Optional[str] = None,\n) -&gt; Dependencies:\n    \"\"\"Parse pixi.toml file and extract dependencies.\n\n    Supports both native pixi.toml format (with top-level [workspace], [dependencies])\n    and embedded format (with [tool.pixi.*] sections).\n\n    Args:\n        pixi_path: Path to pixi.toml file\n        environment_name: Name of environment to extract (optional - falls back to default)\n\n    Returns:\n        Dependencies dict\n\n    Raises:\n        FileNotFoundError: If file doesn't exist\n        ValueError: If no valid environment found\n        Exception: If TOML parsing fails\n    \"\"\"\n    pixi_path = Path(pixi_path)\n\n    if not pixi_path.exists():\n        raise FileNotFoundError(f\"pixi.toml not found: {pixi_path}\")\n\n    with open(pixi_path, \"rb\") as f:\n        config = tomllib.load(f)\n\n    # Detect if this is native pixi.toml format or embedded in [tool.pixi]\n    # Native format has [workspace] or [dependencies] at top level\n    # Embedded format has [tool.pixi.workspace] or [tool.pixi.dependencies]\n    is_native_format = \"workspace\" in config or \"dependencies\" in config or \"pypi-dependencies\" in config\n\n    if is_native_format:\n        return self._parse_native_pixi_toml(config, environment_name)\n    else:\n        return self._parse_embedded_pixi_toml(config, environment_name)\n</code></pre>"},{"location":"reference/wetlands/_internal/config_parser/#wetlands._internal.config_parser.ConfigParser.parse_pyproject_toml","title":"<code>parse_pyproject_toml(pyproject_path, environment_name=None, optional_dependencies=None)</code>","text":"<p>Parse pyproject.toml file and extract dependencies.</p> <p>Parameters:</p> Name Type Description Default <code>pyproject_path</code> <code>Union[str, Path]</code> <p>Path to pyproject.toml file</p> required <code>environment_name</code> <code>Optional[str]</code> <p>Name of pixi environment to extract</p> <code>None</code> <code>optional_dependencies</code> <code>Optional[list[str]]</code> <p>List of optional dependency groups to include</p> <code>None</code> <p>Returns:</p> Type Description <code>Dependencies</code> <p>Dependencies dict</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If file doesn't exist</p> <code>ValueError</code> <p>If required parameters missing or not found</p> <code>Exception</code> <p>If TOML parsing fails</p> Source code in <code>wetlands/_internal/config_parser.py</code> <pre><code>def parse_pyproject_toml(\n    self,\n    pyproject_path: Union[str, Path],\n    environment_name: Optional[str] = None,\n    optional_dependencies: Optional[list[str]] = None,\n) -&gt; Dependencies:\n    \"\"\"Parse pyproject.toml file and extract dependencies.\n\n    Args:\n        pyproject_path: Path to pyproject.toml file\n        environment_name: Name of pixi environment to extract\n        optional_dependencies: List of optional dependency groups to include\n\n    Returns:\n        Dependencies dict\n\n    Raises:\n        FileNotFoundError: If file doesn't exist\n        ValueError: If required parameters missing or not found\n        Exception: If TOML parsing fails\n    \"\"\"\n    pyproject_path = Path(pyproject_path)\n\n    if not pyproject_path.exists():\n        raise FileNotFoundError(f\"pyproject.toml not found: {pyproject_path}\")\n\n    with open(pyproject_path, \"rb\") as f:\n        config = tomllib.load(f)\n\n    dependencies: Dependencies = {}\n    pixi_config = config.get(\"tool\", {}).get(\"pixi\", {})\n\n    # If pixi config exists, use it (like pixi.toml)\n    if pixi_config:\n        if environment_name or not optional_dependencies:\n            # Use pixi environment if environment_name provided, or if no optional_dependencies\n            environments = pixi_config.get(\"environments\", {})\n\n            # Determine which environment to use\n            env_to_use = environment_name\n            if env_to_use and env_to_use not in environments:\n                # Fall back to default if requested environment doesn't exist\n                env_to_use = \"default\"\n\n            if not env_to_use:\n                # No environment_name provided, use default\n                env_to_use = \"default\"\n\n            # Get features for this environment (empty list if no environments defined)\n            features: list[str] = []\n            if environments and env_to_use in environments:\n                env_config = environments[env_to_use]\n                if isinstance(env_config, dict):\n                    features = env_config.get(\"features\", [])\n                elif isinstance(env_config, list):\n                    features = env_config\n\n            # Extract python version\n            if \"python\" in pixi_config.get(\"dependencies\", {}):\n                dependencies[\"python\"] = pixi_config[\"dependencies\"][\"python\"]\n\n            # Collect dependencies from features and base\n            conda_deps = []\n            pip_deps = []\n\n            # Base dependencies (combine name with version spec)\n            for name, version in pixi_config.get(\"dependencies\", {}).items():\n                if name != \"python\":\n                    conda_deps.append(self._format_dependency(name, version))\n\n            for name, version in pixi_config.get(\"pypi-dependencies\", {}).items():\n                pip_deps.append(self._format_dependency(name, version))\n\n            # Feature dependencies\n            features_config = pixi_config.get(\"feature\", {})\n            for feature_name in features:\n                if feature_name in features_config:\n                    feature = features_config[feature_name]\n                    for name, version in feature.get(\"dependencies\", {}).items():\n                        if name != \"python\":\n                            conda_deps.append(self._format_dependency(name, version))\n                    for name, version in feature.get(\"pypi-dependencies\", {}).items():\n                        pip_deps.append(self._format_dependency(name, version))\n\n            # Remove duplicates\n            conda_deps = list(set(conda_deps))\n            pip_deps = list(set(pip_deps))\n\n            if conda_deps:\n                dependencies[\"conda\"] = conda_deps\n            if pip_deps:\n                dependencies[\"pip\"] = pip_deps\n\n        elif optional_dependencies:\n            # Use pixi features as optional dependencies\n            features_config = pixi_config.get(\"feature\", {})\n            conda_deps = []\n            pip_deps = []\n\n            for feature_name in optional_dependencies:\n                if feature_name not in features_config:\n                    available = list(features_config.keys())\n                    raise ValueError(\n                        f\"Feature '{feature_name}' not found in pyproject.toml. Available features: {available}\"\n                    )\n\n                feature = features_config[feature_name]\n                for name, version in feature.get(\"dependencies\", {}).items():\n                    if name != \"python\":\n                        conda_deps.append(self._format_dependency(name, version))\n                for name, version in feature.get(\"pypi-dependencies\", {}).items():\n                    pip_deps.append(self._format_dependency(name, version))\n\n            # Remove duplicates\n            conda_deps = list(set(conda_deps))\n            pip_deps = list(set(pip_deps))\n\n            if conda_deps:\n                dependencies[\"conda\"] = conda_deps\n            if pip_deps:\n                dependencies[\"pip\"] = pip_deps\n        else:\n            raise ValueError(\n                \"For pyproject.toml with pixi config, provide either environment_name or optional_dependencies\"\n            )\n    else:\n        # Standard PEP 621 pyproject.toml (no pixi config)\n        project_config = config.get(\"project\", {})\n\n        # Main dependencies go to pip\n        main_deps = project_config.get(\"dependencies\", [])\n        if main_deps:\n            dependencies[\"pip\"] = main_deps\n\n        # Optional dependencies\n        if optional_dependencies:\n            optional_deps = project_config.get(\"optional-dependencies\", {})\n            pip_deps = dependencies.get(\"pip\", [])\n\n            for group_name in optional_dependencies:\n                if group_name not in optional_deps:\n                    available = list(optional_deps.keys())\n                    raise ValueError(\n                        f\"Optional dependency group '{group_name}' not found. Available groups: {available}\"\n                    )\n\n                pip_deps.extend(optional_deps[group_name])\n\n            if pip_deps:\n                dependencies[\"pip\"] = list(set(pip_deps))\n\n    return dependencies\n</code></pre>"},{"location":"reference/wetlands/_internal/config_parser/#wetlands._internal.config_parser.ConfigParser.parse_environment_yml","title":"<code>parse_environment_yml(env_path)</code>","text":"<p>Parse environment.yml file and extract dependencies.</p> <p>Parameters:</p> Name Type Description Default <code>env_path</code> <code>Union[str, Path]</code> <p>Path to environment.yml file</p> required <p>Returns:</p> Type Description <code>Dependencies</code> <p>Dependencies dict with conda and pip keys</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If file doesn't exist</p> <code>Exception</code> <p>If YAML parsing fails</p> Source code in <code>wetlands/_internal/config_parser.py</code> <pre><code>def parse_environment_yml(\n    self,\n    env_path: Union[str, Path],\n) -&gt; Dependencies:\n    \"\"\"Parse environment.yml file and extract dependencies.\n\n    Args:\n        env_path: Path to environment.yml file\n\n    Returns:\n        Dependencies dict with conda and pip keys\n\n    Raises:\n        FileNotFoundError: If file doesn't exist\n        Exception: If YAML parsing fails\n    \"\"\"\n    env_path = Path(env_path)\n\n    if not env_path.exists():\n        raise FileNotFoundError(f\"environment.yml not found: {env_path}\")\n\n    with open(env_path, \"r\") as f:\n        config = yaml.safe_load(f)\n\n    dependencies: Dependencies = {}\n\n    if not config or not isinstance(config, dict):\n        return dependencies\n\n    # Process dependencies list\n    deps_list = config.get(\"dependencies\", [])\n    conda_deps = []\n    pip_deps = []\n\n    for dep in deps_list:\n        if isinstance(dep, str):\n            if dep == \"pip\":\n                # Skip the 'pip' marker itself\n                continue\n            else:\n                # Regular conda dependency\n                conda_deps.append(dep)\n        elif isinstance(dep, dict):\n            # Nested pip dependencies\n            for key, value in dep.items():\n                if key == \"pip\" and isinstance(value, list):\n                    pip_deps.extend(value)\n\n    if conda_deps:\n        dependencies[\"conda\"] = conda_deps\n    if pip_deps:\n        dependencies[\"pip\"] = pip_deps\n\n    return dependencies\n</code></pre>"},{"location":"reference/wetlands/_internal/config_parser/#wetlands._internal.config_parser.ConfigParser.parse_requirements_txt","title":"<code>parse_requirements_txt(requirements_path)</code>","text":"<p>Parse requirements.txt file and extract dependencies.</p> <p>Parameters:</p> Name Type Description Default <code>requirements_path</code> <code>Union[str, Path]</code> <p>Path to requirements.txt file</p> required <p>Returns:</p> Type Description <code>Dependencies</code> <p>Dependencies dict with pip key containing all dependencies</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If file doesn't exist</p> <code>Exception</code> <p>If file reading fails</p> Source code in <code>wetlands/_internal/config_parser.py</code> <pre><code>def parse_requirements_txt(\n    self,\n    requirements_path: Union[str, Path],\n) -&gt; Dependencies:\n    \"\"\"Parse requirements.txt file and extract dependencies.\n\n    Args:\n        requirements_path: Path to requirements.txt file\n\n    Returns:\n        Dependencies dict with pip key containing all dependencies\n\n    Raises:\n        FileNotFoundError: If file doesn't exist\n        Exception: If file reading fails\n    \"\"\"\n    requirements_path = Path(requirements_path)\n\n    if not requirements_path.exists():\n        raise FileNotFoundError(f\"requirements.txt not found: {requirements_path}\")\n\n    pip_deps = []\n\n    with open(requirements_path, \"r\") as f:\n        for line in f:\n            line = line.strip()\n\n            # Skip empty lines and comments\n            if not line or line.startswith(\"#\"):\n                continue\n\n            # Skip environment markers (e.g., lines with ; python_version)\n            if \";\" in line:\n                line = line.split(\";\")[0].strip()\n\n            if line:\n                pip_deps.append(line)\n\n    dependencies: Dependencies = {}\n    if pip_deps:\n        dependencies[\"pip\"] = pip_deps\n\n    return dependencies\n</code></pre>"},{"location":"reference/wetlands/_internal/dependency_manager/","title":"Dependency manager","text":""},{"location":"reference/wetlands/_internal/dependency_manager/#wetlands._internal.dependency_manager.DependencyManager","title":"<code>DependencyManager</code>","text":"<p>Manage pip and conda dependencies.</p> <p>Methods:</p> Name Description <code>format_dependencies</code> <p>Formats dependencies for installation with platform checks.</p> <code>get_install_dependencies_commands</code> <p>Generates commands to install dependencies in the given environment. Note: this does not activate conda, use self.get_activate_conda_commands() first.</p> Source code in <code>wetlands/_internal/dependency_manager.py</code> <pre><code>class DependencyManager:\n    \"\"\"Manage pip and conda dependencies.\"\"\"\n\n    def __init__(self, command_generator: CommandGenerator):\n        self.installed_packages: dict[str, dict[str, str]] = {}\n        self.settings_manager = command_generator.settings_manager\n        self.command_generator = command_generator\n\n    def _platform_conda_format(self) -&gt; str:\n        \"\"\"Get conda-compatible platform string (e.g., 'linux-64', 'osx-arm64', 'win-64').\"\"\"\n        machine = platform.machine()\n        machine = \"64\" if machine == \"x86_64\" or machine == \"AMD64\" else machine\n        system = dict(Darwin=\"osx\", Windows=\"win\", Linux=\"linux\")[platform.system()]\n        return f\"{system}-{machine}\"\n\n    def format_dependencies(\n        self,\n        package_manager: str,\n        dependencies: Dependencies,\n        raise_incompatibility_error: bool = True,\n        quotes: bool = True,\n    ) -&gt; tuple[list[str], list[str], bool]:\n        \"\"\"Formats dependencies for installation with platform checks.\n\n        Args:\n                package_manager: 'conda' or 'pip'.\n                dependencies: Dependencies to process.\n                raise_incompatibility_error: Whether to raise on incompatible platforms.\n                quotes: Whether to put dependencies in quotes (required when installing extras on mac, e.g. `pip install \"napari[pyqt5]\"`)\n\n        Returns:\n                Tuple of (dependencies, no-deps dependencies, has_dependencies).\n\n        Raises:\n                IncompatibilityException: For non-optional incompatible dependencies.\n        \"\"\"\n        dependency_list: list[str | Dependency] = dependencies.get(package_manager, [])  # type: ignore\n        final_dependencies: list[str] = []\n        final_dependencies_no_deps: list[str] = []\n        for dependency in dependency_list:\n            if isinstance(dependency, str):\n                final_dependencies.append(dependency)\n            else:\n                current_platform = self._platform_conda_format()\n                platforms = dependency.get(\"platforms\", \"all\")\n                if (\n                    current_platform in platforms\n                    or platforms == \"all\"\n                    or len(platforms) == 0\n                    or not raise_incompatibility_error\n                ):\n                    if \"dependencies\" not in dependency or dependency[\"dependencies\"]:\n                        final_dependencies.append(dependency[\"name\"])\n                    else:\n                        final_dependencies_no_deps.append(dependency[\"name\"])\n                elif not dependency.get(\"optional\", False):\n                    platforms_string = \", \".join(platforms)\n                    raise IncompatibilityException(\n                        f\"Error: the library {dependency['name']} is not available on this platform ({current_platform}). It is only available on the following platforms: {platforms_string}.\"\n                    )\n        if quotes:\n            final_dependencies = [f'\"{d}\"' for d in final_dependencies]\n            final_dependencies_no_deps = [f'\"{d}\"' for d in final_dependencies_no_deps]\n        return (\n            final_dependencies,\n            final_dependencies_no_deps,\n            len(final_dependencies) + len(final_dependencies_no_deps) &gt; 0,\n        )\n\n    def get_install_dependencies_commands(self, environment: \"Environment\", dependencies: Dependencies) -&gt; list[str]:\n        \"\"\"Generates commands to install dependencies in the given environment. Note: this does not activate conda, use self.get_activate_conda_commands() first.\n\n        Args:\n                environment: Target environment name. If none, no conda environment will be activated, only pip dependencies will be installed in the current python environemnt ; conda dependencies will be ignored.\n                dependencies: Dependencies to install.\n\n        Returns:\n                list of installation commands.\n\n        Raises:\n                Exception: If pip dependencies contain Conda channel syntax.\n        \"\"\"\n        conda_dependencies, condaDependenciesNoDeps, hasCondaDependencies = self.format_dependencies(\n            \"conda\", dependencies\n        )\n        pipDependencies, pipDependenciesNoDeps, hasPipDependencies = self.format_dependencies(\"pip\", dependencies)\n\n        if hasCondaDependencies and not environment:\n            raise Exception(\n                \"Conda dependencies can only be installed in a Conda environment. Please provide an existing conda environment to install dependencies.\"\n            )\n        if any(\"::\" in d for d in pipDependencies + pipDependenciesNoDeps):\n            raise Exception(\n                f'One pip dependency has a channel specifier \"::\". Is it a conda dependency?\\n\\n({dependencies.get(\"pip\")})'\n            )\n        install_deps_commands = self.settings_manager.get_proxy_environment_variables_commands()\n\n        install_deps_commands += self.command_generator.get_activate_conda_commands()\n\n        if environment:\n            install_deps_commands += self.command_generator.get_activate_environment_commands(\n                environment, activate_conda=False\n            )\n            install_deps_commands += self.command_generator.get_add_channels_commands(\n                environment, dependencies.get(\"channels\", []), conda_dependencies, activate_conda=False\n            )\n\n        proxy_string = self.settings_manager.get_proxy_string()\n        proxy_args = f\"--proxy {proxy_string}\" if proxy_string is not None else \"\"\n        if self.settings_manager.use_pixi:\n            if environment is None:\n                raise Exception(\n                    \"Use micromamba if you want to install a pip dependency without specifying a conda environment.\"\n                )\n            if hasPipDependencies:\n                install_deps_commands += [\n                    f'echo \"Installing pip dependencies...\"',\n                    f'{self.settings_manager.conda_bin} add --manifest-path \"{environment.path}\" --pypi {\" \".join(pipDependencies)}',\n                ]\n            if hasCondaDependencies:\n                install_deps_commands += [\n                    f'echo \"Installing conda dependencies...\"',\n                    f'{self.settings_manager.conda_bin} add --manifest-path \"{environment.path}\" {\" \".join(conda_dependencies)}',\n                ]\n            if len(condaDependenciesNoDeps) &gt; 0:\n                raise Exception(f\"Use micromamba to be able to install conda packages without their dependencies.\")\n            if len(pipDependenciesNoDeps) &gt; 0:\n                install_deps_commands += [\n                    f'echo \"Installing pip dependencies without their dependencies...\"',\n                    f\"pip install {proxy_args} --no-deps {' '.join(pipDependenciesNoDeps)}\",\n                ]\n            return install_deps_commands\n\n        if len(conda_dependencies) &gt; 0:\n            install_deps_commands += [\n                f'echo \"Installing conda dependencies...\"',\n                f\"{self.settings_manager.conda_bin_config} install {' '.join(conda_dependencies)} -y\",\n            ]\n        if len(condaDependenciesNoDeps) &gt; 0:\n            install_deps_commands += [\n                f'echo \"Installing conda dependencies without their dependencies...\"',\n                f\"{self.settings_manager.conda_bin_config} install --no-deps {' '.join(condaDependenciesNoDeps)} -y\",\n            ]\n\n        if len(pipDependencies) &gt; 0:\n            install_deps_commands += [\n                f'echo \"Installing pip dependencies...\"',\n                f\"pip install {proxy_args} {' '.join(pipDependencies)}\",\n            ]\n        if len(pipDependenciesNoDeps) &gt; 0:\n            install_deps_commands += [\n                f'echo \"Installing pip dependencies without their dependencies...\"',\n                f\"pip install {proxy_args} --no-deps {' '.join(pipDependenciesNoDeps)}\",\n            ]\n        return install_deps_commands\n</code></pre>"},{"location":"reference/wetlands/_internal/dependency_manager/#wetlands._internal.dependency_manager.DependencyManager.format_dependencies","title":"<code>format_dependencies(package_manager, dependencies, raise_incompatibility_error=True, quotes=True)</code>","text":"<p>Formats dependencies for installation with platform checks.</p> <p>Parameters:</p> Name Type Description Default <code>package_manager</code> <code>str</code> <p>'conda' or 'pip'.</p> required <code>dependencies</code> <code>Dependencies</code> <p>Dependencies to process.</p> required <code>raise_incompatibility_error</code> <code>bool</code> <p>Whether to raise on incompatible platforms.</p> <code>True</code> <code>quotes</code> <code>bool</code> <p>Whether to put dependencies in quotes (required when installing extras on mac, e.g. <code>pip install \"napari[pyqt5]\"</code>)</p> <code>True</code> <p>Returns:</p> Type Description <code>tuple[list[str], list[str], bool]</code> <p>Tuple of (dependencies, no-deps dependencies, has_dependencies).</p> <p>Raises:</p> Type Description <code>IncompatibilityException</code> <p>For non-optional incompatible dependencies.</p> Source code in <code>wetlands/_internal/dependency_manager.py</code> <pre><code>def format_dependencies(\n    self,\n    package_manager: str,\n    dependencies: Dependencies,\n    raise_incompatibility_error: bool = True,\n    quotes: bool = True,\n) -&gt; tuple[list[str], list[str], bool]:\n    \"\"\"Formats dependencies for installation with platform checks.\n\n    Args:\n            package_manager: 'conda' or 'pip'.\n            dependencies: Dependencies to process.\n            raise_incompatibility_error: Whether to raise on incompatible platforms.\n            quotes: Whether to put dependencies in quotes (required when installing extras on mac, e.g. `pip install \"napari[pyqt5]\"`)\n\n    Returns:\n            Tuple of (dependencies, no-deps dependencies, has_dependencies).\n\n    Raises:\n            IncompatibilityException: For non-optional incompatible dependencies.\n    \"\"\"\n    dependency_list: list[str | Dependency] = dependencies.get(package_manager, [])  # type: ignore\n    final_dependencies: list[str] = []\n    final_dependencies_no_deps: list[str] = []\n    for dependency in dependency_list:\n        if isinstance(dependency, str):\n            final_dependencies.append(dependency)\n        else:\n            current_platform = self._platform_conda_format()\n            platforms = dependency.get(\"platforms\", \"all\")\n            if (\n                current_platform in platforms\n                or platforms == \"all\"\n                or len(platforms) == 0\n                or not raise_incompatibility_error\n            ):\n                if \"dependencies\" not in dependency or dependency[\"dependencies\"]:\n                    final_dependencies.append(dependency[\"name\"])\n                else:\n                    final_dependencies_no_deps.append(dependency[\"name\"])\n            elif not dependency.get(\"optional\", False):\n                platforms_string = \", \".join(platforms)\n                raise IncompatibilityException(\n                    f\"Error: the library {dependency['name']} is not available on this platform ({current_platform}). It is only available on the following platforms: {platforms_string}.\"\n                )\n    if quotes:\n        final_dependencies = [f'\"{d}\"' for d in final_dependencies]\n        final_dependencies_no_deps = [f'\"{d}\"' for d in final_dependencies_no_deps]\n    return (\n        final_dependencies,\n        final_dependencies_no_deps,\n        len(final_dependencies) + len(final_dependencies_no_deps) &gt; 0,\n    )\n</code></pre>"},{"location":"reference/wetlands/_internal/dependency_manager/#wetlands._internal.dependency_manager.DependencyManager.get_install_dependencies_commands","title":"<code>get_install_dependencies_commands(environment, dependencies)</code>","text":"<p>Generates commands to install dependencies in the given environment. Note: this does not activate conda, use self.get_activate_conda_commands() first.</p> <p>Parameters:</p> Name Type Description Default <code>environment</code> <code>Environment</code> <p>Target environment name. If none, no conda environment will be activated, only pip dependencies will be installed in the current python environemnt ; conda dependencies will be ignored.</p> required <code>dependencies</code> <code>Dependencies</code> <p>Dependencies to install.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>list of installation commands.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If pip dependencies contain Conda channel syntax.</p> Source code in <code>wetlands/_internal/dependency_manager.py</code> <pre><code>def get_install_dependencies_commands(self, environment: \"Environment\", dependencies: Dependencies) -&gt; list[str]:\n    \"\"\"Generates commands to install dependencies in the given environment. Note: this does not activate conda, use self.get_activate_conda_commands() first.\n\n    Args:\n            environment: Target environment name. If none, no conda environment will be activated, only pip dependencies will be installed in the current python environemnt ; conda dependencies will be ignored.\n            dependencies: Dependencies to install.\n\n    Returns:\n            list of installation commands.\n\n    Raises:\n            Exception: If pip dependencies contain Conda channel syntax.\n    \"\"\"\n    conda_dependencies, condaDependenciesNoDeps, hasCondaDependencies = self.format_dependencies(\n        \"conda\", dependencies\n    )\n    pipDependencies, pipDependenciesNoDeps, hasPipDependencies = self.format_dependencies(\"pip\", dependencies)\n\n    if hasCondaDependencies and not environment:\n        raise Exception(\n            \"Conda dependencies can only be installed in a Conda environment. Please provide an existing conda environment to install dependencies.\"\n        )\n    if any(\"::\" in d for d in pipDependencies + pipDependenciesNoDeps):\n        raise Exception(\n            f'One pip dependency has a channel specifier \"::\". Is it a conda dependency?\\n\\n({dependencies.get(\"pip\")})'\n        )\n    install_deps_commands = self.settings_manager.get_proxy_environment_variables_commands()\n\n    install_deps_commands += self.command_generator.get_activate_conda_commands()\n\n    if environment:\n        install_deps_commands += self.command_generator.get_activate_environment_commands(\n            environment, activate_conda=False\n        )\n        install_deps_commands += self.command_generator.get_add_channels_commands(\n            environment, dependencies.get(\"channels\", []), conda_dependencies, activate_conda=False\n        )\n\n    proxy_string = self.settings_manager.get_proxy_string()\n    proxy_args = f\"--proxy {proxy_string}\" if proxy_string is not None else \"\"\n    if self.settings_manager.use_pixi:\n        if environment is None:\n            raise Exception(\n                \"Use micromamba if you want to install a pip dependency without specifying a conda environment.\"\n            )\n        if hasPipDependencies:\n            install_deps_commands += [\n                f'echo \"Installing pip dependencies...\"',\n                f'{self.settings_manager.conda_bin} add --manifest-path \"{environment.path}\" --pypi {\" \".join(pipDependencies)}',\n            ]\n        if hasCondaDependencies:\n            install_deps_commands += [\n                f'echo \"Installing conda dependencies...\"',\n                f'{self.settings_manager.conda_bin} add --manifest-path \"{environment.path}\" {\" \".join(conda_dependencies)}',\n            ]\n        if len(condaDependenciesNoDeps) &gt; 0:\n            raise Exception(f\"Use micromamba to be able to install conda packages without their dependencies.\")\n        if len(pipDependenciesNoDeps) &gt; 0:\n            install_deps_commands += [\n                f'echo \"Installing pip dependencies without their dependencies...\"',\n                f\"pip install {proxy_args} --no-deps {' '.join(pipDependenciesNoDeps)}\",\n            ]\n        return install_deps_commands\n\n    if len(conda_dependencies) &gt; 0:\n        install_deps_commands += [\n            f'echo \"Installing conda dependencies...\"',\n            f\"{self.settings_manager.conda_bin_config} install {' '.join(conda_dependencies)} -y\",\n        ]\n    if len(condaDependenciesNoDeps) &gt; 0:\n        install_deps_commands += [\n            f'echo \"Installing conda dependencies without their dependencies...\"',\n            f\"{self.settings_manager.conda_bin_config} install --no-deps {' '.join(condaDependenciesNoDeps)} -y\",\n        ]\n\n    if len(pipDependencies) &gt; 0:\n        install_deps_commands += [\n            f'echo \"Installing pip dependencies...\"',\n            f\"pip install {proxy_args} {' '.join(pipDependencies)}\",\n        ]\n    if len(pipDependenciesNoDeps) &gt; 0:\n        install_deps_commands += [\n            f'echo \"Installing pip dependencies without their dependencies...\"',\n            f\"pip install {proxy_args} --no-deps {' '.join(pipDependenciesNoDeps)}\",\n        ]\n    return install_deps_commands\n</code></pre>"},{"location":"reference/wetlands/_internal/exceptions/","title":"Exceptions","text":""},{"location":"reference/wetlands/_internal/exceptions/#wetlands._internal.exceptions.ExecutionException","title":"<code>ExecutionException</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised when the environment raises an error when executing the requested function.</p> <p>Attributes:</p> Name Type Description <code>message</code> <p>explanation of the error</p> Source code in <code>wetlands/_internal/exceptions.py</code> <pre><code>class ExecutionException(Exception):\n    \"\"\"Exception raised when the environment raises an error when executing the requested function.\n\n    Attributes:\n            message: explanation of the error\n    \"\"\"\n\n    def __init__(self, message):\n        super().__init__(message)\n        self.exception = message[\"exception\"] if \"exception\" in message else None\n        self.traceback = message[\"traceback\"] if \"traceback\" in message else None\n</code></pre>"},{"location":"reference/wetlands/_internal/install/","title":"Install","text":"<p>Functions:</p> Name Description <code>downloadFile</code> <p>Downloads a file from a URL to a destination path using urllib.</p> <code>calculate_sha256</code> <p>Calculates the SHA256 checksum of a file.</p> <code>verify_checksum</code> <p>Verifies the SHA256 checksum of a file against an expected value from a file.</p> <code>downloadAndVerify</code> <p>A helper to chain download and verification, with cleanup on failure.</p> <code>get_micromamba_platform_info</code> <p>Determines the OS platform and architecture for micromamba URLs.</p> <code>get_micromamba_url</code> <p>Constructs the micromamba download URL.</p> <code>install_vc_redist_windows</code> <p>Downloads, verifies, and silently installs VC Redistributable on Windows.</p> <code>create_mamba_config_file</code> <p>Create Mamba config file .mambarc in conda_path, with nodefaults and conda-forge channels.</p> <code>installMicromamba</code> <p>High-level function to orchestrate Micromamba installation.</p> <code>get_pixi_target</code> <p>Determines the target triple for Pixi downloads.</p> <code>installPixi</code> <p>Downloads, verifies, and installs a specific version of Pixi.</p> <code>main</code> <p>Main function to demonstrate script usage.</p>"},{"location":"reference/wetlands/_internal/install/#wetlands._internal.install.downloadFile","title":"<code>downloadFile(url, dest_path, proxies=None)</code>","text":"<p>Downloads a file from a URL to a destination path using urllib.</p> <p>Note: For more complex scenarios, consider using the 'requests' library.</p> Source code in <code>wetlands/_internal/install.py</code> <pre><code>def downloadFile(url: str, dest_path: Path, proxies: Optional[Dict[str, str]] = None) -&gt; None:\n    \"\"\"\n    Downloads a file from a URL to a destination path using urllib.\n\n    Note: For more complex scenarios, consider using the 'requests' library.\n    \"\"\"\n    print(f\"Downloading {url} to {dest_path}...\")\n    dest_path.parent.mkdir(parents=True, exist_ok=True)\n\n    proxy_handler = urllib.request.ProxyHandler(proxies)\n    opener = urllib.request.build_opener(proxy_handler)\n    urllib.request.install_opener(opener)\n\n    try:\n        with urllib.request.urlopen(url, timeout=120) as response, open(dest_path, \"wb\") as outFile:\n            shutil.copyfileobj(response, outFile)\n        print(f\"Successfully downloaded {dest_path.name}.\")\n    except urllib.error.URLError as e:\n        raise RuntimeError(f\"Failed to download {url}. Reason: {e.reason}\") from e\n</code></pre>"},{"location":"reference/wetlands/_internal/install/#wetlands._internal.install.calculate_sha256","title":"<code>calculate_sha256(file_path)</code>","text":"<p>Calculates the SHA256 checksum of a file.</p> Source code in <code>wetlands/_internal/install.py</code> <pre><code>def calculate_sha256(file_path: Path) -&gt; str:\n    \"\"\"Calculates the SHA256 checksum of a file.\"\"\"\n    sha256_hash = hashlib.sha256()\n    try:\n        with open(file_path, \"rb\") as f:\n            # Read in chunks to handle large files efficiently.\n            for byteBlock in iter(lambda: f.read(4096), b\"\"):\n                sha256_hash.update(byteBlock)\n        return sha256_hash.hexdigest()\n    except FileNotFoundError as e:\n        raise FileNotFoundError(f\"Cannot calculate checksum, file not found: {file_path}\") from e\n</code></pre>"},{"location":"reference/wetlands/_internal/install/#wetlands._internal.install.verify_checksum","title":"<code>verify_checksum(file_path, checksum_file_path)</code>","text":"<p>Verifies the SHA256 checksum of a file against an expected value from a file.</p> Source code in <code>wetlands/_internal/install.py</code> <pre><code>def verify_checksum(file_path: Path, checksum_file_path: Path) -&gt; None:\n    \"\"\"Verifies the SHA256 checksum of a file against an expected value from a file.\"\"\"\n    print(f\"Verifying checksum for {file_path.name} using {checksum_file_path}...\")\n\n    try:\n        with open(checksum_file_path, \"r\") as f:\n            expected_checksum = f.read().strip().split()[0].lower()\n    except (FileNotFoundError, IndexError) as e:\n        raise ValueError(f\"Could not read expected checksum from {checksum_file_path}\") from e\n\n    actual_checksum = calculate_sha256(file_path)\n\n    if actual_checksum == expected_checksum:\n        print(f\"Checksum OK for {file_path.name}.\")\n    else:\n        raise ValueError(\n            f\"Checksum MISMATCH for {file_path.name}!\\n  Expected: {expected_checksum}\\n  Actual:   {actual_checksum}\"\n        )\n</code></pre>"},{"location":"reference/wetlands/_internal/install/#wetlands._internal.install.downloadAndVerify","title":"<code>downloadAndVerify(url, download_path, checksum_path, proxies)</code>","text":"<p>A helper to chain download and verification, with cleanup on failure.</p> Source code in <code>wetlands/_internal/install.py</code> <pre><code>def downloadAndVerify(url: str, download_path: Path, checksum_path: Path, proxies: Optional[Dict[str, str]]) -&gt; None:\n    \"\"\"A helper to chain download and verification, with cleanup on failure.\"\"\"\n    try:\n        downloadFile(url, download_path, proxies)\n        verify_checksum(download_path, checksum_path)\n    except (RuntimeError, ValueError) as e:\n        print(f\"Error during download or verification: {e}\", file=sys.stderr)\n        # Clean up partially downloaded file on failure\n        if download_path.exists():\n            download_path.unlink()\n        raise\n</code></pre>"},{"location":"reference/wetlands/_internal/install/#wetlands._internal.install.get_micromamba_platform_info","title":"<code>get_micromamba_platform_info()</code>","text":"<p>Determines the OS platform and architecture for micromamba URLs.</p> Source code in <code>wetlands/_internal/install.py</code> <pre><code>def get_micromamba_platform_info() -&gt; Tuple[str, str]:\n    \"\"\"Determines the OS platform and architecture for micromamba URLs.\"\"\"\n    system = platform.system()\n    arch = platform.machine().lower()\n\n    system_map = {\"Linux\": \"linux\", \"Darwin\": \"osx\", \"Windows\": \"win\"}\n    platform_os = system_map.get(system)\n    if not platform_os:\n        raise ValueError(f\"Unsupported operating system: {system}\")\n\n    arch_map = {\n        \"aarch64\": \"aarch64\",\n        \"ppc64le\": \"ppc64le\",\n        \"arm64\": \"arm64\",  # For macOS\n        \"x86_64\": \"64\",\n        \"amd64\": \"64\",\n    }\n    platform_arch = arch_map.get(arch)\n    if (not platform_arch) or (platform_os == \"win\" and platform_arch != \"64\"):\n        print(f\"Warning: Detected architecture '{arch}', defaulting to '64'.\")\n        platform_arch = \"64\"\n\n    # Validate the final combination\n    valid_combinations = {\"linux-aarch64\", \"linux-ppc64le\", \"linux-64\", \"osx-arm64\", \"osx-64\", \"win-64\"}\n    if f\"{platform_os}-{platform_arch}\" not in valid_combinations:\n        raise ValueError(f\"Unsupported OS-Architecture combination: {platform_os}-{platform_arch}\")\n\n    return platform_os, platform_arch\n</code></pre>"},{"location":"reference/wetlands/_internal/install/#wetlands._internal.install.get_micromamba_url","title":"<code>get_micromamba_url(platform_os, platform_arch, version)</code>","text":"<p>Constructs the micromamba download URL.</p> Source code in <code>wetlands/_internal/install.py</code> <pre><code>def get_micromamba_url(platform_os: str, platform_arch: str, version: str) -&gt; Tuple[str, str]:\n    \"\"\"Constructs the micromamba download URL.\"\"\"\n    base_name = f\"micromamba-{platform_os}-{platform_arch}\"\n    base_url = \"https://github.com/mamba-org/micromamba-releases/releases\"\n\n    if version:\n        return f\"{base_url}/download/{version}/{base_name}\", base_name\n    return f\"{base_url}/latest/download/{base_name}\", base_name\n</code></pre>"},{"location":"reference/wetlands/_internal/install/#wetlands._internal.install.install_vc_redist_windows","title":"<code>install_vc_redist_windows(proxies)</code>","text":"<p>Downloads, verifies, and silently installs VC Redistributable on Windows.</p> Source code in <code>wetlands/_internal/install.py</code> <pre><code>def install_vc_redist_windows(proxies: Optional[Dict[str, str]]) -&gt; None:\n    \"\"\"Downloads, verifies, and silently installs VC Redistributable on Windows.\"\"\"\n    print(\"\\n--- Starting VC Redistributable Setup ---\")\n\n    with tempfile.TemporaryDirectory() as tmpDir:\n        vc_redist_path = Path(tmpDir) / VC_REDIST_ARTIFACT_NAME\n\n        downloadAndVerify(VC_REDIST_URL_DEFAULT, vc_redist_path, VC_REDIST_CHECKSUM_PATH, proxies)\n\n        print(f\"Installing {VC_REDIST_ARTIFACT_NAME}...\")\n        try:\n            # Prepare the PowerShell command to launch the installer with -Wait\n            ps_command = [\n                \"powershell\",\n                \"-Command\",\n                f\"Start-Process -FilePath '{vc_redist_path}' -ArgumentList '/install','/passive','/norestart' -Wait -NoNewWindow\",\n            ]\n\n            result = subprocess.run(\n                ps_command,\n                check=False,  # We check returncode manually for success codes\n                capture_output=True,\n                text=True,\n            )\n\n            # Successful exit codes for vc_redist are 0 (success) or 3010 (reboot required)\n            if result.returncode in [0, 3010]:\n                print(f\"{VC_REDIST_ARTIFACT_NAME} installation successful. Code: {result.returncode}\")\n            else:\n                raise subprocess.CalledProcessError(result.returncode, result.args, result.stdout, result.stderr)\n        except subprocess.CalledProcessError as e:\n            error_message = (\n                f\"Error: {VC_REDIST_ARTIFACT_NAME} installation failed with code {e.returncode}.\\n\"\n                f\"  Stdout: {e.stdout}\\n\"\n                f\"  Stderr: {e.stderr}\"\n            )\n            raise RuntimeError(error_message) from e\n</code></pre>"},{"location":"reference/wetlands/_internal/install/#wetlands._internal.install.create_mamba_config_file","title":"<code>create_mamba_config_file(mamba_path)</code>","text":"<p>Create Mamba config file .mambarc in conda_path, with nodefaults and conda-forge channels.</p> Source code in <code>wetlands/_internal/install.py</code> <pre><code>def create_mamba_config_file(mamba_path):\n    \"\"\"Create Mamba config file .mambarc in conda_path, with nodefaults and conda-forge channels.\"\"\"\n    with open(mamba_path / \".mambarc\", \"w\") as f:\n        mamba_settings = dict(\n            channel_priority=\"flexible\",\n            channels=[\"conda-forge\", \"nodefaults\"],\n            default_channels=[\"conda-forge\"],\n        )\n        yaml.safe_dump(mamba_settings, f)\n</code></pre>"},{"location":"reference/wetlands/_internal/install/#wetlands._internal.install.installMicromamba","title":"<code>installMicromamba(install_path, version=MICROMAMBA_VERSION, proxies=None)</code>","text":"<p>High-level function to orchestrate Micromamba installation.</p> Source code in <code>wetlands/_internal/install.py</code> <pre><code>def installMicromamba(\n    install_path: Path, version: str = MICROMAMBA_VERSION, proxies: Optional[Dict[str, str]] = None\n) -&gt; Path:\n    \"\"\"High-level function to orchestrate Micromamba installation.\"\"\"\n    currentOs, currentArch = get_micromamba_platform_info()\n\n    if currentOs == \"win\":\n        install_vc_redist_windows(proxies)\n\n    print(f\"\\n--- Starting Micromamba Setup for {currentOs}-{currentArch} ---\")\n    micromambaUrl, micromambaBaseName = get_micromamba_url(currentOs, currentArch, version)\n    print(f\"Target Micromamba URL: {micromambaUrl}\")\n\n    suffix = \".exe\" if currentOs == \"win\" else \"\"\n    micromamba_full_path = install_path / \"bin\" / f\"micromamba{suffix}\"\n    micromamba_full_path.parent.mkdir(exist_ok=True, parents=True)\n\n    # Use the combined helper to download and verify\n    downloadAndVerify(micromambaUrl, micromamba_full_path, CHECKSUMS_BASE_DIR / f\"{micromambaBaseName}.sha256\", proxies)\n\n    # Ensure the file is executable and properly named on Windows\n    if currentOs == \"win\":\n        # On Windows, verify the file exists and has the correct extension\n        if not micromamba_full_path.exists():\n            raise Exception(f\"Micromamba executable not found at {micromamba_full_path}\")\n        # Make sure it's readable and not locked\n        try:\n            micromamba_full_path.stat()\n        except Exception as e:\n            raise Exception(f\"Failed to access micromamba executable at {micromamba_full_path}: {e}\") from e\n    else:\n        micromamba_full_path.chmod(0o755)  # rwxr-xr-x\n        print(f\"Made {micromamba_full_path} executable.\")\n\n    print(f\"Micromamba successfully set up at {micromamba_full_path}\")\n\n    create_mamba_config_file(install_path)\n    return micromamba_full_path\n</code></pre>"},{"location":"reference/wetlands/_internal/install/#wetlands._internal.install.get_pixi_target","title":"<code>get_pixi_target(architecture=None)</code>","text":"<p>Determines the target triple for Pixi downloads.</p> Source code in <code>wetlands/_internal/install.py</code> <pre><code>def get_pixi_target(architecture=None) -&gt; str:\n    \"\"\"\n    Determines the target triple for Pixi downloads.\n    \"\"\"\n    platform_system = platform.system()\n    platform_machine = platform.machine().lower()\n\n    if architecture is None:\n        architecture = \"x86_64\"\n        if platform_machine in (\"aarch64\", \"arm64\"):\n            architecture = \"aarch64\"\n\n    platform_name = \"unknown-linux-musl\"\n    archive_extension = \".tar.gz\"\n    if platform_system == \"Windows\":\n        platform_name = \"pc-windows-msvc\"\n        archive_extension = \".zip\"\n    elif platform_system == \"Darwin\":\n        platform_name = \"apple-darwin\"\n\n    return f\"pixi-{architecture}-{platform_name}{archive_extension}\"\n</code></pre>"},{"location":"reference/wetlands/_internal/install/#wetlands._internal.install.installPixi","title":"<code>installPixi(install_path, version=PIXI_VERSION, proxies=None)</code>","text":"<p>Downloads, verifies, and installs a specific version of Pixi.</p> Source code in <code>wetlands/_internal/install.py</code> <pre><code>def installPixi(install_path: Path, version: str = PIXI_VERSION, proxies: Optional[Dict[str, str]] = None) -&gt; Path:\n    \"\"\"Downloads, verifies, and installs a specific version of Pixi.\"\"\"\n\n    binary_filename = get_pixi_target()\n\n    pixi_repo_url = \"https://github.com/prefix-dev/pixi\"\n\n    if version == \"latest\":\n        download_url = f\"{pixi_repo_url}/releases/latest/download/{binary_filename}\"\n    else:\n        download_url = f\"{pixi_repo_url}/releases/download/{version}/{binary_filename}\"\n\n    bin_dir = install_path / \"bin\"\n\n    print(f\"Preparing to install Pixi ({version}, {binary_filename}).\")\n    print(f\"  URL: {download_url}\")\n    print(f\"  Destination: {bin_dir}\")\n\n    checksum_path = CHECKSUMS_BASE_DIR / f\"{binary_filename}.sha256\"\n    if not checksum_path.exists():\n        raise Exception(f\"Error: Checksum file not found at {checksum_path}\")\n\n    try:\n        with tempfile.TemporaryDirectory() as tmpDir:\n            archive_path = Path(tmpDir) / binary_filename\n            downloadAndVerify(download_url, archive_path, checksum_path, proxies)\n\n            print(f\"Extracting {archive_path.name} to {bin_dir}...\")\n            bin_dir.mkdir(parents=True, exist_ok=True)\n\n            if binary_filename.endswith(\".zip\"):\n                with zipfile.ZipFile(archive_path, \"r\") as zip_ref:\n                    zip_ref.extractall(bin_dir)\n            else:  # .tar.gz\n                with tarfile.open(archive_path, \"r:gz\") as tar_ref:\n                    if sys.version_info &gt;= (3, 12):\n                        tar_ref.extractall(bin_dir, filter=\"data\")\n                    else:\n                        # Emulate 'filter=\"data\"' for 3.10\u20133.11\n                        for member in tar_ref.getmembers():\n                            if member.isfile():  # Only extract files, not symlinks/devices/etc\n                                tar_ref.extract(member, path=bin_dir)\n\n            print(\"Pixi installed successfully.\")\n\n    except (RuntimeError, ValueError, FileNotFoundError) as e:\n        raise Exception(\"Pixi installation failed\") from e\n\n    # Find the actual executable - it may be named 'pixi' or 'pixi.exe' depending on the zip contents\n    # and the platform\n    is_windows = platform.system() == \"Windows\"\n\n    # On Windows, the executable might be named just 'pixi' in the zip, so we need to rename it to 'pixi.exe'\n    # to ensure it can be executed properly\n    pixi_without_ext = bin_dir / \"pixi\"\n    pixi_with_ext = bin_dir / \"pixi.exe\"\n\n    if pixi_without_ext.is_file():\n        if is_windows:\n            # Rename to add .exe extension if it doesn't have one\n            if not pixi_with_ext.exists():\n                pixi_without_ext.rename(pixi_with_ext)\n            else:\n                pixi_without_ext.unlink()  # Remove the non-.exe version\n            return pixi_with_ext\n        else:\n            pixi_without_ext.chmod(0o755)  # Make executable on Unix-like systems\n            return pixi_without_ext\n\n    if pixi_with_ext.is_file():\n        return pixi_with_ext\n\n    raise Exception(f\"Pixi executable not found. Checked locations: {pixi_without_ext}, {pixi_with_ext}\")\n</code></pre>"},{"location":"reference/wetlands/_internal/install/#wetlands._internal.install.main","title":"<code>main()</code>","text":"<p>Main function to demonstrate script usage.</p> Source code in <code>wetlands/_internal/install.py</code> <pre><code>def main():\n    \"\"\"\n    Main function to demonstrate script usage.\n    \"\"\"\n    # Example: Install Micromamba\n    micromamba_install_dir = SCRIPT_DIR / \"micromamba_install\"\n    print(f\"--- Example: Installing Micromamba to {micromamba_install_dir} ---\")\n    try:\n        installMicromamba(micromamba_install_dir)\n    except (RuntimeError, ValueError, FileNotFoundError) as e:\n        print(f\"\\nFATAL ERROR during Micromamba setup: {e}\", file=sys.stderr)\n        sys.exit(1)\n\n    print(\"\\n\" + \"=\" * 50 + \"\\n\")\n\n    # Example: Install Pixi\n    pixi_install_dir = SCRIPT_DIR / \"pixi_install\"\n    print(f\"--- Example: Installing Pixi to {pixi_install_dir} ---\")\n    try:\n        installPixi(pixi_install_dir, version=\"0.21.0\")  # Use a specific version\n    except (RuntimeError, ValueError, FileNotFoundError) as e:\n        print(f\"\\nFATAL ERROR during Pixi setup: {e}\", file=sys.stderr)\n        sys.exit(1)\n</code></pre>"},{"location":"reference/wetlands/_internal/process_logger/","title":"Process logger","text":"<p>ProcessLogger handles non-blocking stdout reading from subprocesses with log context tracking.</p>"},{"location":"reference/wetlands/_internal/process_logger/#wetlands._internal.process_logger.ProcessLogger","title":"<code>ProcessLogger</code>","text":"<p>Reads subprocess stdout in a background thread and emits logs with context metadata.</p> <p>This solves the problem of multiple threads competing for process.stdout and enables real-time log emission with attached context (log_source, env_name, etc.).</p> Usage <p>process = subprocess.Popen([...], stdout=subprocess.PIPE, text=True) logger = ProcessLogger(process, log_context={\"log_source\": \"environment\", \"env_name\": \"cellpose\"}) logger.subscribe(my_callback) logger.start_reading()</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Initialize ProcessLogger.</p> <code>subscribe</code> <p>Register a callback to be notified of each log line.</p> <code>update_log_context</code> <p>Update log context with thread safety.</p> <code>start_reading</code> <p>Start reading process stdout in a background daemon thread.</p> <code>get_output</code> <p>Get all accumulated output lines read so far.</p> <code>wait_for_line</code> <p>Wait for a line matching predicate and return it.</p> Source code in <code>wetlands/_internal/process_logger.py</code> <pre><code>class ProcessLogger:\n    \"\"\"Reads subprocess stdout in a background thread and emits logs with context metadata.\n\n    This solves the problem of multiple threads competing for process.stdout and enables\n    real-time log emission with attached context (log_source, env_name, etc.).\n\n    Usage:\n        process = subprocess.Popen([...], stdout=subprocess.PIPE, text=True)\n        logger = ProcessLogger(process, log_context={\"log_source\": \"environment\", \"env_name\": \"cellpose\"})\n        logger.subscribe(my_callback)\n        logger.start_reading()\n    \"\"\"\n\n    def __init__(self, process: subprocess.Popen, log_context: dict[str, Any], base_logger: logging.LoggerAdapter):\n        \"\"\"Initialize ProcessLogger.\n\n        Args:\n            process: The subprocess.Popen instance to read from\n            log_context: Dictionary of context to attach to all logs (log_source, env_name, stage, etc.)\n            base_logger: The logging.Logger instance to emit logs to\n        \"\"\"\n        self.process = process\n        self.log_context = log_context.copy() if log_context else {}\n        self.base_logger = base_logger\n        self._subscribers: list[CallableType[[str, dict], None]] = []\n        self._reader_thread: Optional[threading.Thread] = None\n        self._lock = threading.Lock()\n        self._output: list[str] = []  # Accumulate all output lines\n\n    def subscribe(self, callback: CallableType[[str, dict], None], include_history: bool = True) -&gt; None:\n        \"\"\"Register a callback to be notified of each log line.\n\n        Args:\n            callback: Function with signature callback(line: str, context: dict) called for each log line\n            include_history: whether to execute callback on all messages which where produced by the process until now (True), or only the futur ones (False)\n        \"\"\"\n        with self._lock:\n            self._subscribers.append(callback)\n            if include_history:\n                for line in self._output:\n                    callback(line, self.log_context)\n\n    def update_log_context(self, context_update: dict[str, Any]) -&gt; None:\n        \"\"\"Update log context with thread safety.\n\n        Useful for dynamically updating context during execution (e.g., changing call_target).\n\n        Args:\n            context_update: Dictionary with keys to update in log_context\n        \"\"\"\n        with self._lock:\n            self.log_context.update(context_update)\n\n    def start_reading(self) -&gt; None:\n        \"\"\"Start reading process stdout in a background daemon thread.\"\"\"\n        if self._reader_thread is not None:\n            return\n\n        self._reader_thread = threading.Thread(target=self._read_stdout, daemon=True)\n        self._reader_thread.start()\n\n    def _read_stdout(self) -&gt; None:\n        \"\"\"Read stdout line-by-line and emit logs with context.\"\"\"\n        if self.process.stdout is None:\n            return\n\n        try:\n            for line in iter(self.process.stdout.readline, \"\"):\n                line = line.strip()\n                if not line:\n                    continue\n\n                # Accumulate output\n                with self._lock:\n                    self._output.append(line)\n\n                # Emit to logger with context attached via extra\n                self.base_logger.info(line, extra=self.log_context)\n\n                # Notify subscribers\n                with self._lock:\n                    for callback in self._subscribers:\n                        try:\n                            callback(line, self.log_context)\n                        except Exception as e:\n                            self.base_logger.error(f\"Error in log callback: {e}\")\n\n        except (IOError, OSError, ValueError):\n            # File/pipe closed, which is normal when process exits\n            # ValueError can be raised for operations on closed files\n            pass\n        except Exception as e:\n            self.base_logger.error(f\"Exception in ProcessLogger reader thread: {e}\")\n\n    def get_output(self) -&gt; list[str]:\n        \"\"\"Get all accumulated output lines read so far.\n\n        Returns:\n            List of output lines (may be incomplete if process still running)\n        \"\"\"\n        with self._lock:\n            return self._output.copy()\n\n    def wait_for_line(\n        self, predicate: Callable[[str], bool], timeout: Optional[float] = None, include_history: bool = True\n    ) -&gt; Optional[str]:\n        \"\"\"Wait for a line matching predicate and return it.\n\n        Useful for parsing lines like \"Listening port 12345\" during env startup.\n\n        Args:\n            predicate: Function that takes a line and returns True if it's the line we're waiting for\n            timeout: Maximum seconds to wait (None = wait forever)\n            include_history: whether to execute callback on all messages which where produced by the process until now (True), or only the futur ones (False)\n\n        Returns:\n            The first line matching predicate, or None if timeout occurs\n        \"\"\"\n        found_event = threading.Event()\n        found_line = [None]\n\n        def callback(line: str, context: dict) -&gt; None:\n            if predicate(line):\n                found_line[0] = line  # type: ignore\n                found_event.set()\n\n        self.subscribe(callback, include_history=include_history)\n        found_event.wait(timeout=timeout)\n\n        return found_line[0]\n</code></pre>"},{"location":"reference/wetlands/_internal/process_logger/#wetlands._internal.process_logger.ProcessLogger.__init__","title":"<code>__init__(process, log_context, base_logger)</code>","text":"<p>Initialize ProcessLogger.</p> <p>Parameters:</p> Name Type Description Default <code>process</code> <code>Popen</code> <p>The subprocess.Popen instance to read from</p> required <code>log_context</code> <code>dict[str, Any]</code> <p>Dictionary of context to attach to all logs (log_source, env_name, stage, etc.)</p> required <code>base_logger</code> <code>LoggerAdapter</code> <p>The logging.Logger instance to emit logs to</p> required Source code in <code>wetlands/_internal/process_logger.py</code> <pre><code>def __init__(self, process: subprocess.Popen, log_context: dict[str, Any], base_logger: logging.LoggerAdapter):\n    \"\"\"Initialize ProcessLogger.\n\n    Args:\n        process: The subprocess.Popen instance to read from\n        log_context: Dictionary of context to attach to all logs (log_source, env_name, stage, etc.)\n        base_logger: The logging.Logger instance to emit logs to\n    \"\"\"\n    self.process = process\n    self.log_context = log_context.copy() if log_context else {}\n    self.base_logger = base_logger\n    self._subscribers: list[CallableType[[str, dict], None]] = []\n    self._reader_thread: Optional[threading.Thread] = None\n    self._lock = threading.Lock()\n    self._output: list[str] = []  # Accumulate all output lines\n</code></pre>"},{"location":"reference/wetlands/_internal/process_logger/#wetlands._internal.process_logger.ProcessLogger.subscribe","title":"<code>subscribe(callback, include_history=True)</code>","text":"<p>Register a callback to be notified of each log line.</p> <p>Parameters:</p> Name Type Description Default <code>callback</code> <code>Callable[[str, dict], None]</code> <p>Function with signature callback(line: str, context: dict) called for each log line</p> required <code>include_history</code> <code>bool</code> <p>whether to execute callback on all messages which where produced by the process until now (True), or only the futur ones (False)</p> <code>True</code> Source code in <code>wetlands/_internal/process_logger.py</code> <pre><code>def subscribe(self, callback: CallableType[[str, dict], None], include_history: bool = True) -&gt; None:\n    \"\"\"Register a callback to be notified of each log line.\n\n    Args:\n        callback: Function with signature callback(line: str, context: dict) called for each log line\n        include_history: whether to execute callback on all messages which where produced by the process until now (True), or only the futur ones (False)\n    \"\"\"\n    with self._lock:\n        self._subscribers.append(callback)\n        if include_history:\n            for line in self._output:\n                callback(line, self.log_context)\n</code></pre>"},{"location":"reference/wetlands/_internal/process_logger/#wetlands._internal.process_logger.ProcessLogger.update_log_context","title":"<code>update_log_context(context_update)</code>","text":"<p>Update log context with thread safety.</p> <p>Useful for dynamically updating context during execution (e.g., changing call_target).</p> <p>Parameters:</p> Name Type Description Default <code>context_update</code> <code>dict[str, Any]</code> <p>Dictionary with keys to update in log_context</p> required Source code in <code>wetlands/_internal/process_logger.py</code> <pre><code>def update_log_context(self, context_update: dict[str, Any]) -&gt; None:\n    \"\"\"Update log context with thread safety.\n\n    Useful for dynamically updating context during execution (e.g., changing call_target).\n\n    Args:\n        context_update: Dictionary with keys to update in log_context\n    \"\"\"\n    with self._lock:\n        self.log_context.update(context_update)\n</code></pre>"},{"location":"reference/wetlands/_internal/process_logger/#wetlands._internal.process_logger.ProcessLogger.start_reading","title":"<code>start_reading()</code>","text":"<p>Start reading process stdout in a background daemon thread.</p> Source code in <code>wetlands/_internal/process_logger.py</code> <pre><code>def start_reading(self) -&gt; None:\n    \"\"\"Start reading process stdout in a background daemon thread.\"\"\"\n    if self._reader_thread is not None:\n        return\n\n    self._reader_thread = threading.Thread(target=self._read_stdout, daemon=True)\n    self._reader_thread.start()\n</code></pre>"},{"location":"reference/wetlands/_internal/process_logger/#wetlands._internal.process_logger.ProcessLogger.get_output","title":"<code>get_output()</code>","text":"<p>Get all accumulated output lines read so far.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of output lines (may be incomplete if process still running)</p> Source code in <code>wetlands/_internal/process_logger.py</code> <pre><code>def get_output(self) -&gt; list[str]:\n    \"\"\"Get all accumulated output lines read so far.\n\n    Returns:\n        List of output lines (may be incomplete if process still running)\n    \"\"\"\n    with self._lock:\n        return self._output.copy()\n</code></pre>"},{"location":"reference/wetlands/_internal/process_logger/#wetlands._internal.process_logger.ProcessLogger.wait_for_line","title":"<code>wait_for_line(predicate, timeout=None, include_history=True)</code>","text":"<p>Wait for a line matching predicate and return it.</p> <p>Useful for parsing lines like \"Listening port 12345\" during env startup.</p> <p>Parameters:</p> Name Type Description Default <code>predicate</code> <code>Callable[[str], bool]</code> <p>Function that takes a line and returns True if it's the line we're waiting for</p> required <code>timeout</code> <code>Optional[float]</code> <p>Maximum seconds to wait (None = wait forever)</p> <code>None</code> <code>include_history</code> <code>bool</code> <p>whether to execute callback on all messages which where produced by the process until now (True), or only the futur ones (False)</p> <code>True</code> <p>Returns:</p> Type Description <code>Optional[str]</code> <p>The first line matching predicate, or None if timeout occurs</p> Source code in <code>wetlands/_internal/process_logger.py</code> <pre><code>def wait_for_line(\n    self, predicate: Callable[[str], bool], timeout: Optional[float] = None, include_history: bool = True\n) -&gt; Optional[str]:\n    \"\"\"Wait for a line matching predicate and return it.\n\n    Useful for parsing lines like \"Listening port 12345\" during env startup.\n\n    Args:\n        predicate: Function that takes a line and returns True if it's the line we're waiting for\n        timeout: Maximum seconds to wait (None = wait forever)\n        include_history: whether to execute callback on all messages which where produced by the process until now (True), or only the futur ones (False)\n\n    Returns:\n        The first line matching predicate, or None if timeout occurs\n    \"\"\"\n    found_event = threading.Event()\n    found_line = [None]\n\n    def callback(line: str, context: dict) -&gt; None:\n        if predicate(line):\n            found_line[0] = line  # type: ignore\n            found_event.set()\n\n    self.subscribe(callback, include_history=include_history)\n    found_event.wait(timeout=timeout)\n\n    return found_line[0]\n</code></pre>"},{"location":"reference/wetlands/_internal/settings_manager/","title":"Settings manager","text":""},{"location":"reference/wetlands/_internal/settings_manager/#wetlands._internal.settings_manager.SettingsManager","title":"<code>SettingsManager</code>","text":"<p>Methods:</p> Name Description <code>set_conda_path</code> <p>Updates the micromamba path and loads proxy settings if exists.</p> <code>set_proxies</code> <p>Configures proxy settings for Conda operations (see Using Anaconda behind a company proxy).</p> <code>get_conda_paths</code> <p>Gets micromamba root path and binary path.</p> <code>get_proxy_environment_variables_commands</code> <p>Generates proxy environment variable commands.</p> <code>get_proxy_string</code> <p>Gets active proxy string from configuration (HTTPS preferred, fallback to HTTP).</p> Source code in <code>wetlands/_internal/settings_manager.py</code> <pre><code>class SettingsManager:\n    use_pixi = True\n    conda_bin = \"pixi\"  # \"micromamba\"\n    conda_bin_config = \"pixi --manifest-path .pixi/project.toml\"  # \"micromamba --rc-file ~/.mambarc\"\n    proxies: dict[str, str] | None = None\n\n    def __init__(self, conda_path: str | Path = Path(\"pixi\"), use_pixi=True) -&gt; None:\n        self.set_conda_path(conda_path, use_pixi)\n\n    def set_conda_path(self, conda_path: str | Path, use_pixi=True) -&gt; None:\n        \"\"\"Updates the micromamba path and loads proxy settings if exists.\n\n        Args:\n                conda_path: New path to micromamba binary.\n\n        Side Effects:\n                Updates conda_bin_config and proxies from the .mambarc file.\n        \"\"\"\n        self.use_pixi = use_pixi\n        self.conda_bin = (\n            \"pixi.exe\" if platform.system() == \"Windows\" and use_pixi else \"pixi\" if use_pixi else \"micromamba\"\n        )\n        self.conda_path = Path(conda_path).resolve()\n        # conda_bin_config is only used with micromamba but let's initialize it for pixi as well\n        conda_config_path = self.conda_path / \"pixi.toml\" if self.use_pixi else self.conda_path / \".mambarc\"\n        self.conda_bin_config = (\n            f'{self.conda_bin} --manifest-path \"{conda_config_path}\"'\n            if self.use_pixi\n            else f'{self.conda_bin} --rc-file \"{conda_config_path}\"'\n        )\n\n        if self.use_pixi:\n            return\n        import yaml\n\n        if conda_config_path.exists():\n            with open(conda_config_path, \"r\") as f:\n                conda_config = yaml.safe_load(f)\n                if conda_config is not None and \"proxies\" in conda_config:\n                    self.proxies = conda_config[\"proxies\"]\n\n    def set_proxies(self, proxies: dict[str, str]) -&gt; None:\n        \"\"\"Configures proxy settings for Conda operations (see [Using Anaconda behind a company proxy](https://www.anaconda.com/docs/tools/working-with-conda/reference/proxy)).\n\n        Args:\n                proxies: Proxy configuration dictionary (e.g., {'http': 'http://username:password@corp.com:8080', 'https': 'https://username:password@corp.com:8080'}).\n\n        Side Effects:\n                Updates .mambarc configuration file with proxy settings.\n        \"\"\"\n        self.proxies = proxies\n        if self.use_pixi:\n            return\n        conda_config_path = self.conda_path / \".mambarc\"\n        conda_config = dict()\n        import yaml\n\n        if conda_config_path.exists():\n            with open(conda_config_path, \"r\") as f:\n                conda_config = yaml.safe_load(f)\n            if proxies:\n                conda_config[\"proxy_servers\"] = proxies\n            else:\n                del conda_config[\"proxy_servers\"]\n            with open(conda_config_path, \"w\") as f:\n                yaml.safe_dump(conda_config, f)\n\n    def get_conda_paths(self) -&gt; tuple[Path, Path]:\n        \"\"\"Gets micromamba root path and binary path.\n\n        Returns:\n                Tuple of (conda directory path, binary relative path).\n        \"\"\"\n        conda_name = \"pixi\" if self.use_pixi else \"micromamba\"\n        suffix = \".exe\" if platform.system() == \"Windows\" else \"\"\n        conda_bin_path = f\"bin/{conda_name}{suffix}\"\n        return self.conda_path.resolve(), Path(conda_bin_path)\n\n    def get_environment_path_from_name(self, environment_name: str) -&gt; Path:\n        return (\n            self.conda_path / \"workspaces\" / environment_name / \"pixi.toml\"\n            if self.use_pixi\n            else self.conda_path / \"envs\" / environment_name\n        )\n\n    def get_proxy_environment_variables_commands(self) -&gt; list[str]:\n        \"\"\"Generates proxy environment variable commands.\n\n        Returns:\n                List of OS-specific proxy export commands.\n        \"\"\"\n        if self.proxies is None:\n            return []\n        return [\n            f'export {name.lower()}_proxy=\"{value}\"'\n            if platform.system() != \"Windows\"\n            else f'$Env:{name.upper()}_PROXY=\"{value}\"'\n            for name, value in self.proxies.items()\n        ]\n\n    def get_proxy_string(self) -&gt; str | None:\n        \"\"\"Gets active proxy string from configuration (HTTPS preferred, fallback to HTTP).\"\"\"\n        if self.proxies is None:\n            return None\n        return self.proxies.get(\"https\", self.proxies.get(\"http\", None))\n</code></pre>"},{"location":"reference/wetlands/_internal/settings_manager/#wetlands._internal.settings_manager.SettingsManager.set_conda_path","title":"<code>set_conda_path(conda_path, use_pixi=True)</code>","text":"<p>Updates the micromamba path and loads proxy settings if exists.</p> <p>Parameters:</p> Name Type Description Default <code>conda_path</code> <code>str | Path</code> <p>New path to micromamba binary.</p> required Side Effects <p>Updates conda_bin_config and proxies from the .mambarc file.</p> Source code in <code>wetlands/_internal/settings_manager.py</code> <pre><code>def set_conda_path(self, conda_path: str | Path, use_pixi=True) -&gt; None:\n    \"\"\"Updates the micromamba path and loads proxy settings if exists.\n\n    Args:\n            conda_path: New path to micromamba binary.\n\n    Side Effects:\n            Updates conda_bin_config and proxies from the .mambarc file.\n    \"\"\"\n    self.use_pixi = use_pixi\n    self.conda_bin = (\n        \"pixi.exe\" if platform.system() == \"Windows\" and use_pixi else \"pixi\" if use_pixi else \"micromamba\"\n    )\n    self.conda_path = Path(conda_path).resolve()\n    # conda_bin_config is only used with micromamba but let's initialize it for pixi as well\n    conda_config_path = self.conda_path / \"pixi.toml\" if self.use_pixi else self.conda_path / \".mambarc\"\n    self.conda_bin_config = (\n        f'{self.conda_bin} --manifest-path \"{conda_config_path}\"'\n        if self.use_pixi\n        else f'{self.conda_bin} --rc-file \"{conda_config_path}\"'\n    )\n\n    if self.use_pixi:\n        return\n    import yaml\n\n    if conda_config_path.exists():\n        with open(conda_config_path, \"r\") as f:\n            conda_config = yaml.safe_load(f)\n            if conda_config is not None and \"proxies\" in conda_config:\n                self.proxies = conda_config[\"proxies\"]\n</code></pre>"},{"location":"reference/wetlands/_internal/settings_manager/#wetlands._internal.settings_manager.SettingsManager.set_proxies","title":"<code>set_proxies(proxies)</code>","text":"<p>Configures proxy settings for Conda operations (see Using Anaconda behind a company proxy).</p> <p>Parameters:</p> Name Type Description Default <code>proxies</code> <code>dict[str, str]</code> <p>Proxy configuration dictionary (e.g., {'http': 'http://username:password@corp.com:8080', 'https': 'https://username:password@corp.com:8080'}).</p> required Side Effects <p>Updates .mambarc configuration file with proxy settings.</p> Source code in <code>wetlands/_internal/settings_manager.py</code> <pre><code>def set_proxies(self, proxies: dict[str, str]) -&gt; None:\n    \"\"\"Configures proxy settings for Conda operations (see [Using Anaconda behind a company proxy](https://www.anaconda.com/docs/tools/working-with-conda/reference/proxy)).\n\n    Args:\n            proxies: Proxy configuration dictionary (e.g., {'http': 'http://username:password@corp.com:8080', 'https': 'https://username:password@corp.com:8080'}).\n\n    Side Effects:\n            Updates .mambarc configuration file with proxy settings.\n    \"\"\"\n    self.proxies = proxies\n    if self.use_pixi:\n        return\n    conda_config_path = self.conda_path / \".mambarc\"\n    conda_config = dict()\n    import yaml\n\n    if conda_config_path.exists():\n        with open(conda_config_path, \"r\") as f:\n            conda_config = yaml.safe_load(f)\n        if proxies:\n            conda_config[\"proxy_servers\"] = proxies\n        else:\n            del conda_config[\"proxy_servers\"]\n        with open(conda_config_path, \"w\") as f:\n            yaml.safe_dump(conda_config, f)\n</code></pre>"},{"location":"reference/wetlands/_internal/settings_manager/#wetlands._internal.settings_manager.SettingsManager.get_conda_paths","title":"<code>get_conda_paths()</code>","text":"<p>Gets micromamba root path and binary path.</p> <p>Returns:</p> Type Description <code>tuple[Path, Path]</code> <p>Tuple of (conda directory path, binary relative path).</p> Source code in <code>wetlands/_internal/settings_manager.py</code> <pre><code>def get_conda_paths(self) -&gt; tuple[Path, Path]:\n    \"\"\"Gets micromamba root path and binary path.\n\n    Returns:\n            Tuple of (conda directory path, binary relative path).\n    \"\"\"\n    conda_name = \"pixi\" if self.use_pixi else \"micromamba\"\n    suffix = \".exe\" if platform.system() == \"Windows\" else \"\"\n    conda_bin_path = f\"bin/{conda_name}{suffix}\"\n    return self.conda_path.resolve(), Path(conda_bin_path)\n</code></pre>"},{"location":"reference/wetlands/_internal/settings_manager/#wetlands._internal.settings_manager.SettingsManager.get_proxy_environment_variables_commands","title":"<code>get_proxy_environment_variables_commands()</code>","text":"<p>Generates proxy environment variable commands.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of OS-specific proxy export commands.</p> Source code in <code>wetlands/_internal/settings_manager.py</code> <pre><code>def get_proxy_environment_variables_commands(self) -&gt; list[str]:\n    \"\"\"Generates proxy environment variable commands.\n\n    Returns:\n            List of OS-specific proxy export commands.\n    \"\"\"\n    if self.proxies is None:\n        return []\n    return [\n        f'export {name.lower()}_proxy=\"{value}\"'\n        if platform.system() != \"Windows\"\n        else f'$Env:{name.upper()}_PROXY=\"{value}\"'\n        for name, value in self.proxies.items()\n    ]\n</code></pre>"},{"location":"reference/wetlands/_internal/settings_manager/#wetlands._internal.settings_manager.SettingsManager.get_proxy_string","title":"<code>get_proxy_string()</code>","text":"<p>Gets active proxy string from configuration (HTTPS preferred, fallback to HTTP).</p> Source code in <code>wetlands/_internal/settings_manager.py</code> <pre><code>def get_proxy_string(self) -&gt; str | None:\n    \"\"\"Gets active proxy string from configuration (HTTPS preferred, fallback to HTTP).\"\"\"\n    if self.proxies is None:\n        return None\n    return self.proxies.get(\"https\", self.proxies.get(\"http\", None))\n</code></pre>"}]}