{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Overview","text":""},{"location":"#wetlands","title":"Wetlands","text":"<p>Wetlands is a lightweight Python library for managing Conda environments.</p> <p>Wetlands can create Conda environments on demand, install dependencies, and execute arbitrary code within them. This makes it easy to build plugin systems or integrate external modules into an application without dependency conflicts, as each environment remains isolated.</p> <p>The name Wetlands comes from the tropical environments where anacondas thrive.</p> <p>Documentation: https://arthursw.github.io/wetlands/latest/</p> <p>Source Code: https://github.com/arthursw/wetlands/</p>"},{"location":"#features","title":"\u2728 Features","text":"<ul> <li>Automatic Environment Management: Create and configure environments on demand.</li> <li>Dependency Isolation: Install dependencies without conflicts.</li> <li>Embedded Execution: Run Python functions inside isolated environments.</li> <li>Pixi &amp; Micromamba: Wetlands uses either a self-contained <code>pixi</code> or <code>micromamba</code> for fast and lightweight Conda environment handling.</li> </ul>"},{"location":"#installation","title":"\ud83d\udce6 Installation","text":"<p>To install Wetlands, simply run:</p> <pre><code>pip install wetlands\n</code></pre>"},{"location":"#usage","title":"\ud83d\ude80 Usage","text":""},{"location":"#minimal-example","title":"Minimal example","text":"<p>Here is a minimal example usage:</p> <pre><code>from wetlands.environment_manager import EnvironmentManager\n\n# Initialize the environment manager\nenvironmentManager = EnvironmentManager(\"pixi/\")\n\n# Create and launch a Conda environment named \"numpy_env\"\nenv = environmentManager.create(\"numpy_env\", {\"pip\": [\"numpy==2.2.4\"]})\nenv.launch()\n\n# Import minimal_module in the environment (see minimal_module.py below)\nminimal_module = env.importModule(\"minimal_module.py\")\n# minimal_module is a proxy to minimal_module.py in the environment\narray = [1, 2, 3]\n# Execute the sum() function in the numpy_env environment and get the result\nresult = minimal_module.sum(array)\n\nprint(f\"Sum of {array} is {result}.\")\n\n# Clean up and exit the environment\nenv.exit()\n</code></pre> <p>With <code>minimal_module.py</code>:</p> <pre><code>def sum(x):\n    import numpy as np  # type: ignore\n    return int(np.sum(x))\n</code></pre>"},{"location":"#general-usage","title":"General usage","text":"<p>Wetlands allows you to interact with isolated Conda environments in two main ways:</p> <ol> <li>Simplified Execution (<code>env.importModule</code> / <code>env.execute</code>): Wetlands manages the communication details, providing a proxy object to call functions within the environment seamlessly. See Getting started.</li> <li>Manual Control (<code>env.executeCommands</code>): You run specific commands (like starting a Python script that listens for connections) and manage the inter-process communication yourself. See Advanced example.</li> </ol> <p>You can run those examples form the <code>examples/</code> folder in the repository.</p> <p>Explore the inner workings on the How it Works page.</p>"},{"location":"#license","title":"\ud83d\udcdc License","text":"<p>This project was made at Inria in Rennes (Centre Inria de l'Universit\u00e9 de Rennes) and is licensed under the MIT License.</p> <p>The logo Wetland was made by Dan Hetteix from Noun Project (CC BY 3.0).</p>"},{"location":"advanced_example/","title":"Advanced example","text":""},{"location":"advanced_example/#manual-communication-with-envexecutecommands","title":"Manual Communication with <code>env.executeCommands</code>","text":"<p>This example shows how to use Wetlands to run a specific script within the environment and manage the communication manually using Python's <code>multiprocessing.connection</code>. This gives you full control over the interaction protocol but requires more setup.</p> <p>Let's see the main script <code>advanced_example.py</code> step by step. </p>"},{"location":"advanced_example/#initialize-wetlands-and-logging","title":"Initialize Wetlands and Logging","text":"<p>We import necessary modules, including <code>Client</code> for manual connection and standard Python libraries like <code>subprocess</code>, <code>threading</code>, and <code>logging</code>. We also enable debug logging for Wetlands to see more internal details and initialize the <code>EnvironmentManager</code>.</p> <pre><code># main_script_manual.py\nfrom multiprocessing.connection import Client\nimport subprocess\nimport sys\nimport threading\nimport logging\nfrom pathlib import Path\nimport time\n\nfrom wetlands.environment_manager import EnvironmentManager\nfrom wetlands import logger\n\nlogger.setLogLevel(logging.DEBUG)\n\nenvironmentManager = EnvironmentManager(\"micromamba/\", False)\n</code></pre>"},{"location":"advanced_example/#create-the-environment","title":"Create the Environment","text":"<p>Similar to the first example, we create the environment (<code>advanced_cellpose_env</code>) and specify its dependencies.</p> <pre><code>deps = {\"conda\": [\"cellpose==3.1.0\"]}\nenv = environmentManager.create(\"advanced_cellpose_env\", deps)\n</code></pre>"},{"location":"advanced_example/#execute-a-custom-script-in-the-environment","title":"Execute a Custom Script in the Environment","text":"<p>Instead of <code>env.launch()</code>, we use <code>env.executeCommands()</code>. This method allows us to run arbitrary shell commands within the activated environment. Here, we execute a specific Python script (<code>advanced_example_module.py</code>) using <code>python -u</code> (unbuffered output, important for reading stdout line-by-line immediately). We capture the <code>Popen</code> object for the launched process. We also redirect stderr to stdout for easier log capture.</p> <pre><code>print(\"Executing advanced_example_module.py in environment...\")\nprocess = env.executeCommands([\"python -u advanced_example_module.py\"])\n</code></pre> <p>Windows users</p> <p>The <code>python</code> command will be available since it will be run in the conda environment.</p>"},{"location":"advanced_example/#establish-manual-connection","title":"Establish Manual Connection","text":"<p>The script we just launched (<code>advanced_example_module.py</code>) is designed to start a server and print the port it's listening on to its standard output. Our main script now needs to read the <code>stdout</code> of the <code>process</code> launched by Wetlands to discover this port number. We loop through the output lines until we find the line indicating the port.</p> <pre><code>port = None\nif process.stdout is None:\n    print(\"Process has no stdout stream.\", file=sys.stderr)\n    sys.exit(1)\nprint(\"Waiting for environment process to report listening port...\")\nfor line in process.stdout:\n    if line.strip().startswith(\"Listening port \"):\n        port = int(line.strip().replace(\"Listening port \", \"\"))\n        break\n\nprint(f\"Connecting to localhost:{port}...\")\nconnection = Client((\"localhost\", port))\n</code></pre>"},{"location":"advanced_example/#log-environment-output-optional","title":"Log Environment Output (Optional)","text":"<p>To see ongoing output from the script running in the environment, we can start a background thread that continuously reads and prints lines from the process's stdout.</p> <pre><code>def log_output(proc: subprocess.Popen):\n    if proc.stdout:\n        for line_bytes in iter(proc.stdout.readline, b''):\n            print(f\"[Env Output]: {line_bytes.decode().strip()}\")\n\noutput_thread = threading.Thread(target=log_output, args=(process,), daemon=True)\noutput_thread.start()\n</code></pre>"},{"location":"advanced_example/#send-commands-and-receive-results-manually","title":"Send Commands and Receive Results Manually","text":"<p>Now that we have a direct <code>connection</code> object (from <code>multiprocessing.connection.Client</code>), we can implement our own communication protocol. We send dictionaries containing an <code>action</code>, <code>function</code> name, and <code>args</code>. We then wait (<code>connection.recv()</code>) for a response dictionary from the server script running in the environment.</p> <pre><code>imagePath = \"cellpose_img02.png\"\n\nprint(f\"Sending command: download image {imagePath}\")\nconnection.send(dict(action=\"execute\", function=\"downloadImage\", args=[imagePath]))\nresult = connection.recv()\nprint(f\"Received response: {result}\")\n\nsegmentationPath = \"cellpose_img02_segmentation.png\"\nprint(f\"Sending command: segment image {imagePath}\")\nargs = [str(imagePath), str(segmentationPath)]\nconnection.send(dict(action=\"execute\", function=\"segmentImage\", args=args))\nresult = connection.recv()\nprint(f\"Received response: {result}\")\nif 'diameters' in result:\n    print(f\"Object diameters: {result['diameters']}\")\n</code></pre>"},{"location":"advanced_example/#tell-the-environment-process-to-exit-and-clean-up","title":"Tell the Environment Process to Exit and clean up","text":"<p>We send a custom 'exit' message according to our protocol. The server script is designed to shut down upon receiving this message.</p> <pre><code>print(\"Sending exit command...\")\nconnection.send(dict(action=\"exit\"))\n</code></pre> <p>We close our client-side connection and wait for the process we launched with <code>executeCommands</code> to terminate.</p> <pre><code>connection.close()\nprocess.wait(timeout=10)\nif process.returncode is None:\n    process.kill()\n</code></pre> <p>Now, let's examine the <code>advanced_example_module.py</code> script, which is executed by Wetlands in the isolated environment via <code>executeCommands</code>.</p> <p>Define Callable Functions</p> <p>This script defines the functions (<code>downloadImage</code>, <code>segmentImage</code>) that the main script will invoke remotely. These functions perform the actual work (downloading, segmenting using <code>example_module</code>) inside the environment and use the provided <code>connection</code> object to send back results or status messages.</p> <pre><code># advanced_example_module.py\nimport sys\nimport urllib.request\nfrom multiprocessing.connection import Listener\nfrom pathlib import Path\nimport example_module # Reuse logic from the simple example module\n\ndef downloadImage(imagePath_str, connection):\n    \"\"\"Downloads the image *inside* the environment.\"\"\"\n    imagePath = Path(imagePath_str)\n    imageUrl = \"https://www.cellpose.org/static/images/img02.png\"\n    print(f\"[Inside Env] Downloading image to {imagePath}...\")\n    try:\n        with urllib.request.urlopen(imageUrl) as response:\n            imageData = response.read()\n        with open(imagePath, \"wb\") as handler:\n            handler.write(imageData)\n        print(\"[Inside Env] Image downloaded.\")\n        connection.send(dict(status=\"success\", message=\"Image downloaded.\"))\n    except Exception as e:\n        print(f\"[Inside Env] Error downloading image: {e}\")\n        connection.send(dict(status=\"error\", message=str(e)))\n\ndef segmentImage(imagePath_str, segmentationPath_str, connection):\n    \"\"\"Runs segmentation *inside* the environment.\"\"\"\n    imagePath = Path(imagePath_str)\n    segmentationPath = Path(segmentationPath_str)\n    print(f\"[Inside Env] Segmenting {imagePath}...\")\n    try:\n        diameters = example_module.segment(imagePath, segmentationPath)\n        print(\"[Inside Env] Segmentation complete.\")\n        connection.send(dict(status=\"success\", message=\"Image segmented.\", diameters=diameters))\n    except Exception as e:\n        print(f\"[Inside Env] Error during segmentation: {e}\")\n        connection.send(dict(status=\"error\", message=str(e)))\n</code></pre> <p>Set Up the Server</p> <p>The main part of the script uses <code>multiprocessing.connection.Listener</code> to create a server socket listening on <code>localhost</code> and an OS-assigned port (<code>0</code>). Crucially, it prints the chosen port number to standard output, which is how the main script discovers where to connect. It then waits for the main script to connect (<code>listener.accept()</code>).</p> <pre><code>with Listener((\"localhost\", 0)) as listener:\n    # Print the port for the main process to read\n    print(f\"Listening port {listener.address[1]}\", flush=True)\n    with listener.accept() as connection:\n</code></pre> <p>Process Incoming Messages</p> <p>Once connected, the script enters a loop, waiting to receive messages (<code>connection.recv()</code>). It parses the received dictionary, checks the <code>action</code>, and calls the corresponding local function (<code>downloadImage</code> or <code>segmentImage</code>) if the action is <code>execute</code>. If the action is <code>exit</code>, it sends a confirmation and terminates the script (<code>sys.exit(0)</code>).</p> <pre><code>        while message := connection.recv():\n            if message[\"action\"] == \"execute\":\n                locals()[message[\"function\"]](*(message[\"args\"] + [connection]))\n            if message[\"action\"] == \"exit\":\n                connection.send(dict(action=\"Exited.\"))\n                sys.exit(0)\n</code></pre> <p>Summary of Example 2 Flow:</p> <p>The main script uses <code>EnvironmentManager</code> to create an environment. <code>env.executeCommands()</code> starts a custom server script (<code>advanced_example_module.py</code>) inside the environment. The main script reads the server's port from stdout and connects manually using <code>Client</code>. Communication happens via custom message dictionaries sent over this connection. The main script explicitly tells the server to exit before cleaning up the process started by <code>executeCommands</code>. This approach offers more control but requires implementing the server logic and communication protocol.</p>"},{"location":"debugging/","title":"Debugging Wetlands Environments","text":"<p>Wetlands provides built-in debugging tools that allow you to attach a debugger to an isolated environment and step through code execution in real-time. This is essential for development and troubleshooting when running code in isolated Conda environments.</p>"},{"location":"debugging/#overview","title":"Overview","text":"<p>The debugging system includes:</p> <ul> <li>IDE Integration: Support for VS Code and PyCharm</li> <li>Remote Debugging: Attach to running environment processes</li> <li>Environment Management: List and kill running environments</li> <li>Port Allocation: Automatic debug port assignment for each environment</li> </ul>"},{"location":"debugging/#installation","title":"Installation","text":"<p>The debugging tools are part of the Wetlands package and are automatically installed with:</p> <pre><code>pip install wetlands\n</code></pre>"},{"location":"debugging/#usage-commands","title":"Usage Commands","text":""},{"location":"debugging/#1-wetlands-list-view-running-environments","title":"1. <code>wetlands list</code> - View Running Environments","text":"<p>List all currently running Wetlands environments and their debug ports.</p> <pre><code>wetlands list [-wip PATH]\n</code></pre> <p>Arguments:</p> <ul> <li><code>-wip, --wetlandsInstancePath PATH</code> (optional): Path to the Wetlands instance folder (default: <code>pixi/wetlands</code>)</li> </ul> <p>Example:</p> <pre><code>$ wetlands list\nRunning wetlands environments (for all wetlands instance):\n\nCommand line | Process ID | Parent process ID\n---\npython /path/to/wetlands/module_executor.py env1 --wetlandsInstancePath /tmp/wetlands | 12345 | 12340\npython /path/to/wetlands/module_executor.py env2 --wetlandsInstancePath /tmp/wetlands | 12346 | 12340\n\nEnvironments of the wetlands instance /tmp/wetlands:\n\nEnvironment | Debug Port | Path\n---\nenv1 | 5678 | /path/to/module_executor.py\nenv2 | 5679 | /path/to/module_executor.py\n</code></pre> <p>This command displays: - Running processes: All active Wetlands environment processes with their PIDs - Available debug ports: The port number assigned to each environment for debugging - Module executor paths: Where the module executor is located for each environment</p>"},{"location":"debugging/#2-wetlands-debug-attach-debugger-to-an-environment","title":"2. <code>wetlands debug</code> - Attach Debugger to an Environment","text":"<p>Attach VS Code or PyCharm to a running Wetlands environment for debugging.</p> <pre><code>wetlands debug -s SOURCE_PATH -n ENV_NAME [-ide {vscode,pycharm}] [-wip PATH] [-jmc]\n</code></pre> <p>Arguments:</p> <ul> <li><code>-s, --sources SOURCE_PATH</code> (required): Path to the source code directory you want to debug</li> <li><code>-n, --name ENV_NAME</code> (required): Name of the environment to debug</li> <li><code>-ide, --ide {vscode,pycharm}</code> (optional): IDE to use (default: <code>vscode</code>)</li> <li><code>-wip, --wetlandsInstancePath PATH</code> (optional): Path to the Wetlands instance folder (default: <code>pixi/wetlands</code>)</li> <li><code>-jmc, --justMyCode</code> (optional, VS Code only): Only debug your source files, not library code</li> </ul> <p>Example - VS Code:</p> <pre><code>wetlands debug -s /path/to/my/project -n my_env\n</code></pre> <p>Example - PyCharm:</p> <pre><code>wetlands debug -s /path/to/my/project -n my_env -ide pycharm\n</code></pre> <p>Example - VS Code with Just My Code:</p> <pre><code>wetlands debug -s /path/to/my/project -n my_env -jmc\n</code></pre>"},{"location":"debugging/#what-happens-when-you-run-wetlands-debug","title":"What Happens When You Run <code>wetlands debug</code>","text":"<ol> <li>Configuration Detection: Wetlands searches for running processes matching the environment name</li> <li>Port Discovery: The debug port for the environment is read from <code>debug_ports.json</code> in the Wetlands instance directory</li> <li>IDE Configuration:</li> <li>VS Code: Creates/updates <code>.vscode/launch.json</code> with remote attach configuration</li> <li>PyCharm: Creates <code>.idea/runConfigurations/Remote_Attach_Wetlands.xml</code> with remote debugging configuration</li> <li>IDE Launch: Opens the specified IDE with the source directory</li> <li>Debugger Connection: The IDE connects to the remote debugger running in the isolated environment</li> </ol>"},{"location":"debugging/#3-wetlands-kill-stop-an-environment","title":"3. <code>wetlands kill</code> - Stop an Environment","text":"<p>Terminate a running Wetlands environment and all its child processes.</p> <pre><code>wetlands kill -n ENV_NAME [-wip PATH]\n</code></pre> <p>Arguments:</p> <ul> <li><code>-n, --name ENV_NAME</code> (required): Name of the environment to kill</li> <li><code>-wip, --wetlandsInstancePath PATH</code> (optional): Path to the Wetlands instance folder (default: <code>pixi/wetlands</code>)</li> </ul> <p>Example:</p> <pre><code>wetlands kill -n my_env\n</code></pre>"},{"location":"debugging/#debugging-with-vs-code","title":"Debugging with VS Code","text":""},{"location":"debugging/#setup-and-debugging","title":"Setup and Debugging","text":"<ol> <li>Start your Wetlands environment in your Python script:</li> </ol> <pre><code>from wetlands.environment_manager import EnvironmentManager\n\nenv_manager = EnvironmentManager(\"pixi/\")\nenv = env_manager.create(\"my_env\", {\"pip\": [\"numpy\", \"pandas\"]})\nenv.launch()\n\n# Your code here\n</code></pre> <ol> <li>List available environments to verify it's running:</li> </ol> <pre><code>wetlands list\n</code></pre> <ol> <li>Attach the debugger with VS Code:</li> </ol> <pre><code>wetlands debug -s /path/to/my/project -n my_env\n</code></pre> <ol> <li> <p>Set breakpoints in VS Code and interact with your environment code</p> </li> <li> <p>Stop debugging when finished:</p> </li> </ol> <pre><code>wetlands kill -n my_env\n</code></pre>"},{"location":"debugging/#configuration-details","title":"Configuration Details","text":"<p>The <code>launch.json</code> file created by Wetlands for VS Code contains:</p> <pre><code>{\n  \"version\": \"0.2.0\",\n  \"configurations\": [\n    {\n      \"name\": \"Python Debugger: Remote Attach Wetlands\",\n      \"type\": \"debugpy\",\n      \"request\": \"attach\",\n      \"justMyCode\": false,\n      \"connect\": {\n        \"host\": \"localhost\",\n        \"port\": 5678\n      },\n      \"pathMappings\": [\n        {\n          \"localRoot\": \"/path/to/module/executor\",\n          \"remoteRoot\": \"/path/to/module/executor\"\n        }\n      ]\n    }\n  ]\n}\n</code></pre> <ul> <li>type: Uses <code>debugpy</code> for Python debugging</li> <li>connect: Specifies <code>localhost</code> and the assigned debug port</li> <li>justMyCode: Set to <code>true</code> if you used the <code>-jmc</code> flag</li> <li>pathMappings: Maps local source paths to remote paths in the environment</li> </ul>"},{"location":"debugging/#debugging-with-pycharm","title":"Debugging with PyCharm","text":""},{"location":"debugging/#setup-and-debugging_1","title":"Setup and Debugging","text":"<ol> <li> <p>Start your Wetlands environment in your Python script (same as VS Code)</p> </li> <li> <p>Attach the debugger with PyCharm:</p> </li> </ol> <pre><code>wetlands debug -s /path/to/my/project -n my_env -ide pycharm\n</code></pre> <ol> <li>Select the run configuration in PyCharm:</li> <li>Look for \"Remote_Attach_Wetlands\" in the run configurations dropdown</li> <li> <p>Click the Debug button</p> </li> <li> <p>Set breakpoints in PyCharm and interact with your environment code</p> </li> <li> <p>Stop debugging when finished:</p> </li> </ol> <pre><code>wetlands kill -n my_env\n</code></pre>"},{"location":"debugging/#configuration-details_1","title":"Configuration Details","text":"<p>The XML configuration file created in <code>.idea/runConfigurations/Remote_Attach_Wetlands.xml</code> contains:</p> <pre><code>&lt;?xml version=\"1.0\" encoding=\"UTF-8\"?&gt;\n&lt;component name=\"ProjectRunConfigurationManager\"&gt;\n  &lt;configuration name=\"Remote Attach Wetlands\" type=\"Python\"\n                 factoryName=\"Python\" show_console_on_std_err=\"false\"\n                 show_console_on_std_out=\"false\"&gt;\n    &lt;module name=\"$PROJECT_NAME\" /&gt;\n    &lt;option name=\"PATH_MAPPINGS\"&gt;\n      &lt;list&gt;\n        &lt;item index=\"0\" itemvalue=\"/path/to/module/executor:/path/to/module/executor\" /&gt;\n      &lt;/list&gt;\n    &lt;/option&gt;\n  &lt;/configuration&gt;\n&lt;/component&gt;\n</code></pre> <ul> <li>Creates a Python remote debugging configuration</li> <li>Path mappings ensure source code paths are correctly resolved</li> </ul>"},{"location":"debugging/#workflow-example","title":"Workflow Example","text":"<p>Here's a complete workflow for debugging a Wetlands environment:</p>"},{"location":"debugging/#1-create-your-project-structure","title":"1. Create Your Project Structure","text":"<pre><code>my_project/\n\u251c\u2500\u2500 main.py              # Main script\n\u251c\u2500\u2500 module_to_debug.py   # Code to debug\n\u2514\u2500\u2500 requirements.txt     # Dependencies\n</code></pre>"},{"location":"debugging/#2-create-the-main-script","title":"2. Create the Main Script","text":"<pre><code># main.py\nfrom pathlib import Path\nfrom wetlands.environment_manager import EnvironmentManager\n\nenv_manager = EnvironmentManager(\"pixi/\")\nenv = env_manager.create(\n    \"my_debug_env\",\n    {\"pip\": [\"requests\", \"numpy\"]}\n)\nenv.launch()\n\n# Import module and call function\nmy_module = env.importModule(\"module_to_debug.py\")\nresult = my_module.process_data([1, 2, 3, 4, 5])\n\nprint(f\"Result: {result}\")\nenv.exit()\n</code></pre>"},{"location":"debugging/#3-create-the-module-to-debug","title":"3. Create the Module to Debug","text":"<pre><code># module_to_debug.py\nimport numpy as np\n\ndef process_data(data):\n    \"\"\"Process data with numpy\"\"\"\n    arr = np.array(data)\n    result = np.sum(arr) * 2\n    return int(result)  # Breakpoint here to inspect values\n</code></pre>"},{"location":"debugging/#4-start-your-application","title":"4. Start Your Application","text":"<pre><code>python main.py\n</code></pre>"},{"location":"debugging/#5-launch-the-environment","title":"5. Launch the Environment","text":"<p>Keep the main script running, and in another terminal:</p> <pre><code>wetlands list\n</code></pre> <p>You'll see <code>my_debug_env</code> listed.</p>"},{"location":"debugging/#6-attach-the-debugger","title":"6. Attach the Debugger","text":"<pre><code># For VS Code:\nwetlands debug -s /path/to/my_project -n my_debug_env\n\n# Or for PyCharm:\nwetlands debug -s /path/to/my_project -n my_debug_env -ide pycharm\n</code></pre>"},{"location":"debugging/#7-debug-your-code","title":"7. Debug Your Code","text":"<ul> <li>Set breakpoints in <code>module_to_debug.py</code></li> <li>Call functions from your main script</li> <li>Step through code and inspect variables</li> <li>VS Code/PyCharm will break at your breakpoints</li> </ul>"},{"location":"debugging/#8-clean-up","title":"8. Clean Up","text":"<p>When finished:</p> <pre><code>wetlands kill -n my_debug_env\n</code></pre>"},{"location":"debugging/#troubleshooting","title":"Troubleshooting","text":""},{"location":"debugging/#debug-ports-file-does-not-exist","title":"\"Debug ports file does not exist\"","text":"<p>Cause: The Wetlands instance hasn't created the <code>debug_ports.json</code> file yet.</p> <p>Solution: Make sure your environment has been launched with <code>env.launch()</code> before running the debug command.</p>"},{"location":"debugging/#debug-port-not-found-for-environment","title":"\"Debug port not found for environment\"","text":"<p>Cause: The environment name doesn't exist or is spelled incorrectly.</p> <p>Solution: - Verify the environment is running: <code>wetlands list</code> - Check the exact environment name - Make sure you're using the correct <code>-wip</code> path if you have multiple Wetlands instances</p>"},{"location":"debugging/#no-wetlands-process-with-environment-name-found","title":"\"No wetlands process with environment name found\"","text":"<p>Cause: The specified environment is not currently running.</p> <p>Solution: - Start your Python script that creates and launches the environment - Keep the script running while debugging - Verify with <code>wetlands list</code></p>"},{"location":"debugging/#debugger-doesnt-break-at-breakpoints","title":"Debugger doesn't break at breakpoints","text":"<p>Cause: The source code path mapping might be incorrect.</p> <p>Solution: - Ensure the source path you provide to <code>wetlands debug</code> matches your actual source code location - Check the path mappings in the generated configuration file - Verify that the line numbers haven't changed since you set the breakpoint</p>"},{"location":"debugging/#kill-environment-no-process-found","title":"\"Kill environment: no process found\"","text":"<p>Cause: The environment is not currently running.</p> <p>Solution: This is usually not a problem. Verify with <code>wetlands list</code> that the environment isn't running, and proceed.</p>"},{"location":"debugging/#advanced-usage","title":"Advanced Usage","text":""},{"location":"debugging/#debugging-multiple-environments","title":"Debugging Multiple Environments","text":"<p>You can debug multiple environments simultaneously by:</p> <ol> <li>Opening multiple IDE windows</li> <li>Using <code>wetlands debug</code> with different environment names</li> <li>Each environment gets its own debug port</li> </ol> <pre><code># Terminal 1\nwetlands debug -s /project1 -n env1\n\n# Terminal 2\nwetlands debug -s /project2 -n env2\n</code></pre>"},{"location":"debugging/#debugging-with-custom-wetlands-instances","title":"Debugging with Custom Wetlands Instances","text":"<p>If you have multiple Wetlands instances, specify the instance path:</p> <pre><code>wetlands debug -s /path/to/project -n my_env -wip /custom/wetlands/path\n</code></pre>"},{"location":"debugging/#vs-code-only-just-my-code-mode","title":"VS Code Only: Just My Code Mode","text":"<p>Debug only your code, skipping library internals:</p> <pre><code>wetlands debug -s /path/to/project -n my_env -jmc\n</code></pre> <p>This sets <code>justMyCode: true</code> in the VS Code launch configuration, which speeds up debugging by not stepping into library code.</p>"},{"location":"debugging/#how-it-works-under-the-hood","title":"How It Works Under the Hood","text":"<ol> <li>Process Detection: Wetlands uses <code>psutil</code> to find running processes matching your environment</li> <li>Port Assignment: Each environment gets a unique debug port from <code>debug_ports.json</code></li> <li>Debugpy Integration: The environment's module executor runs <code>debugpy</code> in socket mode</li> <li>IDE Configuration: Wetlands generates IDE-specific configuration files for remote attach</li> <li>Network Connection: Your IDE connects via localhost to the debug port in the isolated environment</li> </ol>"},{"location":"debugging/#see-also","title":"See Also","text":"<ul> <li>Getting Started - Basic Wetlands usage</li> <li>Advanced Example - More complex scenarios</li> <li>How It Works - Internal architecture</li> </ul>"},{"location":"dependencies/","title":"\ud83d\udce6 Dependency Specification Documentation","text":"<p>This document explains how to define dependencies using Wetlands' structured format. The schema supports specifying dependencies for different platforms, optional dependencies, and conditional dependencies via <code>conda</code> or <code>pip</code>.</p>"},{"location":"dependencies/#type-definitions","title":"\ud83d\udd27 Type Definitions","text":""},{"location":"dependencies/#platform","title":"Platform","text":"<p><pre><code>Platform = Literal[\"osx-64\", \"osx-arm64\", \"win-64\", \"win-arm64\", \"linux-64\", \"linux-arm64\"]\n</code></pre> Defines supported operating systems and architectures.</p>"},{"location":"dependencies/#dependency","title":"Dependency","text":"<pre><code>class Dependency(TypedDict):\n    name: str\n    platforms: NotRequired[list[Platform]]\n    optional: NotRequired[bool]\n    dependencies: NotRequired[bool]\n</code></pre> <p>Represents an individual dependency with additional metadata:</p> <ul> <li>name (str): The name of the package (e.g., <code>\"numpy\"</code>) with an optional channel specification (for conda specification) and a version specifier. Format: <code>channel::package==version.number</code>. Supports PEP 440 version specifiers like <code>&gt;=1.20,&lt;2.0</code>, <code>~=1.5.0</code>, <code>!=1.0.0</code>, etc.</li> <li>platforms (optional): A list of platforms on which this package should be installed.</li> <li>optional (optional): Marks the dependency as optional (e.g., for extra features like enabling computation on GPU).</li> <li>dependencies (optional): Indicates whether to install sub-dependencies.</li> </ul>"},{"location":"dependencies/#dependencies","title":"Dependencies","text":"<pre><code>class Dependencies(TypedDict):\n    python: NotRequired[str]\n    conda: NotRequired[list[str | Dependency]]\n    pip: NotRequired[list[str | Dependency]]\n</code></pre> <p>Top-level dependency configuration:</p> <ul> <li>python (optional str): Specifies the Python version required (e.g., <code>\"==3.9\"</code>).</li> <li>conda (optional list): Conda dependencies (package names or <code>Dependency</code> objects).</li> <li>pip (optional list): Pip dependencies (package names or <code>Dependency</code> objects).</li> </ul>"},{"location":"dependencies/#example","title":"\ud83e\uddea Example","text":"<p>Here\u2019s an example dependency specification:</p> <pre><code>dependencies: Dependencies = {\n    \"python\": \"==3.11\",\n    \"conda\": [\n        \"numpy\",\n        {\"name\": \"nvidia::cudatoolkit=11.0.*\", \"optional\": True, \"platforms\": [\"linux-64\", \"windows-64\"]},\n        {\"name\": \"nvidia::nvidia::cudnn=8.0.*\", \"optional\": True, \"platforms\": [\"linux-64\", \"windows-64\"]},\n        {\"name\": \"pyobjc\", \"platforms\": [\"osx-64\", \"osx-arm64\"], \"optional\": True},\n    ],\n    \"pip\": [\n        \"tensorflow==2.16.1\",\n        \"csbdeep==0.8.1\", \n        \"stardist==0.9.1\",\n        {\"name\": \"some-macos-only-package\", \"platforms\": [\"osx-arm64\"]},\n        {\"name\": \"helper\", \"optional\": True, \"dependencies\": False}\n    ]\n}\n</code></pre>"},{"location":"dependencies/#explanation","title":"Explanation:","text":"<ul> <li><code>python: \"==3.11\"</code>: Requires Python version 3.11 exactly.</li> <li><code>conda</code> section:<ul> <li><code>\"numpy\"</code>: required on all platforms.</li> <li><code>\"nvidia::cudatoolkit=11.0.*\"</code>: An optional CUDA toolkit, installed only on Linux and Windows (x86_64) (so that GPU is used on x86_64 linux and windows, and CPU is used otherwise).</li> <li><code>\"nvidia::nvidia::cudnn=8.0.*\"</code>: An optional cuDNN library for deep learning acceleration on Linux and Windows (x86_64) (so that GPU is used on x86_64 linux and windows, and CPU is used otherwise).</li> <li><code>\"pyobjc\"</code>: An optional macOS-only dependency for Python\u2013Objective-C bridging, included on both Intel and Apple Silicon macOS.</li> </ul> </li> <li><code>pip</code> section:<ul> <li><code>\"tensorflow==2.16.1\"</code>: Required version of TensorFlow for all platforms.</li> <li><code>\"csbdeep==0.8.1\"</code> and <code>\"stardist==0.9.1\"</code>: Required deep learning packages for image restoration and segmentation.</li> <li><code>\"some-macos-only-package\"</code>: Only installed on macOS Apple Silicon (<code>osx-arm64</code>).</li> <li><code>helper</code>: An optional pip package which much be installed without its dependencies.</li> </ul> </li> </ul>"},{"location":"dependencies/#usage-recommendations","title":"\u2705 Usage Recommendations","text":"<ul> <li>Use <code>platforms</code> to restrict platform-specific packages (e.g., <code>pyobjc</code> for macOS).</li> <li>Use <code>optional</code> for optional feature packages.</li> <li>Use <code>dependencies=False</code> to only install the package without its dependencies.</li> </ul>"},{"location":"getting_started/","title":"Getting started","text":""},{"location":"getting_started/#simplified-execution-with-envimportmodule","title":"Simplified Execution with <code>env.importModule</code>","text":"<p>To demonstrates the most straightforward way to use Wetlands, we will create an environment, install <code>cellpose</code>, and run a segmentation function defined in a separate file (<code>example_module.py</code>) within that isolated environment.</p> <p>Let's see the main script <code>getting_started.py</code> step by step. </p> <p>We will segment the image <code>img02.png</code> (available here).</p> <pre><code>from pathlib import Path\nimagePath = Path(\"img02.png\")\nsegmentationPath = imagePath.parent / f\"{imagePath.stem}_segmentation.png\"\n</code></pre>"},{"location":"getting_started/#1-initialize-the-environment-manager","title":"1. Initialize the Environment Manager","text":"<p>We start by initializing the EnvironmentManager. We provide: - A <code>wetlandsInstancePath</code> where Wetlands stores logs and debug information (defaults to <code>\"wetlands/\"</code>). - Optionally, a <code>condaPath</code> where Wetlands should look for an existing Pixi (or Micromamba) installation or where it should download and set up a new one. If not provided, it defaults to <code>wetlandsInstancePath / \"pixi\"</code>.</p> <pre><code>from wetlands.environment_manager import EnvironmentManager\n\nenvironmentManager = EnvironmentManager()\n# Or with explicit paths:\n# environmentManager = EnvironmentManager(\n#     wetlandsInstancePath=\"wetlands_state\",\n#     condaPath=\"path/to/pixi/\"\n# )\n</code></pre> <p>Note</p> <p>EnvironmentManager also accepts a <code>mainCondaEnvironmentPath</code> argument, useful if Wetlands is used in a conda environment (e.g. <code>environmentManager = EnvironmentManager(mainCondaEnvironmentPath=\"/path/to/project/environment/\")</code>). Wetlands will activate this main environment and check if the installed packages satisfy the requirements when creating new environments. If the required dependencies are already installed in the main environment, EnvironmentManager.create() will return the main enviroment instead of creating a new one. The modules will be called directly, bypassing the Wetlands communication server.</p> <p>Warning</p> <p>On Windows, spaces are not allowed in the <code>condaPath</code> argument of <code>EnvironmentManager()</code>.</p>"},{"location":"getting_started/#2-create-or-get-an-environment-and-install-dependencies","title":"2. Create (or get) an Environment and Install Dependencies","text":"<p>Next, we define and create the Conda environment. We give it a name (<code>\"cellpose_env\"</code>) and specify its dependencies using a dictionary. Here, we require <code>cellpose</code> version 3.1.0, to be installed via Conda. If an environment with this name already exists, Wetlands will use it (and ignore the dependencies); otherwise, it will create it and install the specified dependencies. The <code>create</code> method returns an <code>Environment</code> object.</p> <pre><code>env = environmentManager.create(\n    \"cellpose_env\",\n    {\"conda\": [\"cellpose==3.1.0\"]}\n)\n</code></pre> <p>Note</p> <p>If a <code>mainCondaEnvironmentPath</code> was provided when instanciating the <code>EnvironmentManager</code>, Wetlands will check if <code>cellpose==3.1.0</code> is already installed in the main environment and return it if it is the case. If <code>mainCondaEnvironmentPath</code> is not provided but the required dependencies are only pip packages, Wetlands will check if the dependencies are installed in the current python environment and return it if it is the case.</p> <p>Reusing existing environments with <code>useExisting=True</code></p> <p>You can pass <code>useExisting=True</code> to <code>create()</code> to search for and reuse an existing environment that satisfies the dependencies. This includes the main environment. If no environment satisfies the requirements, a new one will be created. By default, <code>useExisting=False</code>, which always creates a new environment.</p> <pre><code># Return main or existing environment if it satisfies the dependencies\nenv = environmentManager.create(\n    \"cellpose_env\",\n    {\"conda\": [\"cellpose==3.1.0\"]},\n    useExisting=True  # Check if any existing env satisfies the dependencies\n)\n</code></pre> <p>Specifying dependencies</p> <p>See the dependencies page to learn more on specifying dependencies. Wetlands supports PEP 440 version specifiers, so you can use flexible version constraints like <code>\"numpy&gt;=1.20,&lt;2.0\"</code>, <code>\"scipy~=1.5\"</code>, or <code>\"pandas!=1.0.0\"</code>. You can also use <code>EnvironmentManager.createFromConfig()</code> and provide a <code>requirements.txt</code>, <code>environment.yml</code>, <code>pyproject.toml</code> or <code>pixi.toml</code> file for your dependencies.</p> <p>Load an existing environment</p> <p>You can also load an existing environment with <code>environment.load(\"env_name\", Path(\"Path/to/existing/environment/pyproject.toml\"))</code>. See <code>EnvironmentManager.load()</code>.</p>"},{"location":"getting_started/#3-launch-the-environments-communication-server","title":"3. Launch the Environment's Communication Server","text":"<p>For Wetlands to execute code within the isolated environment (using <code>importModule</code> or <code>execute</code>), we need to launch its background communication server. This server runs as a separate process inside the <code>cellpose_env</code> and listens for commands from our main script.</p> <pre><code>env.launch()\n</code></pre>"},{"location":"getting_started/#4-import-and-execute-code-in-the-environment-via-proxy","title":"4. Import and Execute Code in the Environment via Proxy","text":"<p>This is where the core Wetlands interaction happens. We use <code>env.importModule(\"example_module.py\")</code> to gain access to the functions defined in <code>example_module.py</code>. Wetlands doesn't actually import the module into the main process; instead, it returns a proxy object. When we call a method on this proxy object (like <code>example_module.segment(...)</code>), Wetlands intercepts the call, sends the function name and arguments to the server running in the <code>cellpose_env</code>, executes the real function there, and returns the result back to the main script. File paths and other pickleable arguments are automatically transferred.</p> <pre><code>print(\"Importing module in environment...\")\nexample_module = env.importModule(\"example_module.py\")\n\nprint(f\"Running segmentation on {imagePath}...\")\ndiameters = example_module.segment(str(imagePath), str(segmentationPath))\n\nprint(f\"Segmentation complete. Found diameters of {diameters} pixels.\")\n</code></pre> <p>Alternatively, we could use <code>env.execute()</code> directly:</p> <pre><code>print(f\"Running segmentation on {imagePath}...\")\nargs = (str(imagePath), str(segmentationPath))\ndiameters = env.execute(\"example_module.py\", \"segment\", args)\n\nprint(f\"Segmentation complete. Found diameters of {diameters} pixels.\")\n</code></pre> <p>Function arguments must be serializable</p> <p>The arguments of the segment function will be send to the other process via <code>multiprocessing.connection.Connection.send()</code> so the objects must be picklable.</p>"},{"location":"getting_started/#5-clean-up","title":"5. Clean Up","text":"<p>Finally, we tell Wetlands to shut down the communication server and clean up resources associated with the launched environment.</p> <pre><code>print(\"Exiting environment...\")\nenv.exit()\n\nprint(\"Done.\")\n</code></pre> <code>getting_started.py</code> source code <pre><code>from pathlib import Path\nfrom wetlands.environment_manager import EnvironmentManager\nimport urllib.request\n\n\ndef initialize():\n    # Initialize the environment manager\n    # Wetlands will store logs and state in the wetlandsInstancePath (defaults to \"wetlands/\")\n    # Pixi/Micromamba will be installed in wetlandsInstancePath/pixi by default\n    environmentManager = EnvironmentManager()\n\n    # Create and launch an isolated Conda environment named \"cellpose\"\n    env = environmentManager.create(\"cellpose\", {\"conda\": [\"cellpose==3.1.0\"]})\n    env.launch()\n\n    # Download example image from cellpose\n    imagePath = Path(\"cellpose_img02.png\")\n    imageUrl = \"https://www.cellpose.org/static/images/img02.png\"\n\n    with urllib.request.urlopen(imageUrl) as response:\n        imageData = response.read()\n\n    with open(imagePath, \"wb\") as handler:\n        handler.write(imageData)\n\n    segmentationPath = imagePath.parent / f\"{imagePath.stem}_segmentation.png\"\n    return imagePath, segmentationPath, env\n\n\nif __name__ == \"__main__\":\n    # Initialize: create the environment manager, the Cellpose conda environment, and download the image to segment\n    imagePath, segmentationPath, env = initialize()\n\n    # Import example_module in the environment\n    exampleModule = env.importModule(\"example_module.py\")\n    # exampleModule is a proxy to example_module.py in the environment,\n    # calling exampleModule.function_name(args) will run env.execute(module_name, function_name, args)\n    diameters = exampleModule.segment(str(imagePath), str(segmentationPath))\n\n    # Or use env.execute() directly to call a function in a module\n    # diameters = env.execute(\"example_module.py\", \"segment\", (imagePath, segmentationPath))\n\n    # Alternatively, use env.runScript() to run an entire Python script\n    # env.runScript(\"script.py\", args=(str(imagePath), str(segmentationPath)))\n\n    print(f\"Found diameters of {diameters} pixels.\")\n\n    # Clean up and exit the environment\n    env.exit()\n</code></pre> <p>Now, let's look at the <code>example_module.py</code> file. This code contains the actual segmentation logic and is executed inside the isolated <code>cellpose_env</code> when called via the proxy object.</p>"},{"location":"getting_started/#define-the-segmentation-function","title":"Define the Segmentation Function","text":"<p>The module defines a <code>segment</code> function that takes input/output paths and other parameters. It uses a global variable <code>model</code> to potentially cache the loaded Cellpose model between calls within the same environment process lifetime.</p> <pre><code># example_module.py\nfrom pathlib import Path\nfrom typing import Any, cast\n\nmodel = None\n\ndef segment(\n    inputImage: Path | str,\n    segmentation: Path | str,\n    modelType=\"cyto\",\n    useGPU=False,\n    channels=[0, 0],\n    autoDiameter=True,\n    diameter=30,\n):\n    \"\"\"Performs cell segmentation using Cellpose.\"\"\"\n    global model\n\n    inputImage = Path(inputImage)\n    if not inputImage.exists():\n        raise FileNotFoundError(f\"Error: input image {inputImage}\"\\\n                                \"does not exist.\")\n</code></pre>"},{"location":"getting_started/#import-dependencies-inside-the-environment","title":"Import Dependencies (Inside the Environment)","text":"<p>Crucially, the necessary libraries (<code>cellpose</code>, <code>numpy</code>) are imported within this function, meaning they are resolved using the packages installed inside the isolated <code>cellpose_env</code>, not the main script's environment. This is important to enable the main script to import <code>example_module.py</code> without raising a <code>ModuleNotFoundError</code>. In this way, the main script can see the functions defined in <code>example_module.py</code>. This is only necessary when using the proxy object (<code>env.importModule(\"example_module.py\")</code> then <code>example_module.function(args)</code>) but it is not required when using <code>env.execute(\"example_module.py\", \"function\", (args))</code> directly.</p> <pre><code>    print(f\"[[1/4]] Load libraries and model '{modelType}'\")\n    import cellpose.models\n    import cellpose.io\n    import numpy as np\n</code></pre> <p>Using try catch to prevent <code>ModuleNotFoundError</code></p> <p>A better approach is to use a try statement at the beginning of <code>example_module.py</code> to fail silently when importing modules which are not accessible in the main environment, like so:</p> <pre><code>try:\n    import cellpose.models\n    import cellpose.io\n    import numpy as np\nexcept ModuleNotFoundError:\n    pass\n...\n</code></pre> <p>This allows:  - to access the function definitions in the main environment (even if we won't be able to execute them in the main environment),  - to import the modules for all functions defined in <code>example_module.py</code> in the <code>cellpose_env</code>.</p>"},{"location":"getting_started/#load-model-and-process-image","title":"Load Model and Process Image","text":"<p>The code proceeds to load the Cellpose model (if not already cached) and the input image. All this happens within the context of the <code>cellpose_env</code>.</p> <pre><code>    if model is None or model.cp.model_type != modelType:\n        print(\"Loading model...\")\n        gpu_flag = str(useGPU).lower() == 'true'\n        model = cellpose.models.Cellpose(gpu=gpu_flag, model_type=modelType)\n\n    print(f\"[[2/4]] Load image {inputImage}\")\n    image = cast(np.ndarray, cellpose.io.imread(str(inputImage)))\n</code></pre>"},{"location":"getting_started/#perform-segmentation","title":"Perform Segmentation","text":"<p>The core segmentation task is performed using the loaded model and image. Any exceptions raised here will be captured by Wetlands and re-raised in the main script.</p> <pre><code>    print(f\"[[3/4]] Compute segmentation for image shape {image.shape}\")\n    try:\n        kwargs: Any = dict(diameter=int(diameter)) if autoDiameter else {}\n        masks, _, _, diams = model.eval(image, channels=channels, **kwargs)\n    except Exception as e:\n        print(f\"Error during segmentation: {e}\")\n        raise e\n    print(\"Segmentation finished (inside environment).\")\n</code></pre>"},{"location":"getting_started/#save-results-and-return-value","title":"Save Results and Return Value","text":"<p>The segmentation results (masks) are saved to disk, potentially renaming the output file. The function then returns the calculated cell diameters (<code>diams</code>). This return value is serialized by Wetlands and sent back to the main script.</p> <pre><code>    if segmentation is None:                # If segmentation is None: return all results\n        return masks, flows, styles, diams\n\n    segmentation_path = Path(segmentation)\n    print(f\"[[4/4]] Save segmentation to {segmentation_path}\")\n\n    cellpose.io.save_masks(image, masks, flows, str(inputImage), png=True)\n    default_output = inputImage.parent / f\"{inputImage.stem}_cp_masks.png\"\n\n    if default_output.exists():\n        if segmentation_path.exists():\n            segmentation_path.unlink()\n        default_output.rename(segmentation_path)\n        print(f\"Saved mask: {segmentation_path}\")\n    else:\n        print(\"Warning: Segmentation mask file was not generated by cellpose.\")\n\n    return diams\n</code></pre> <code>example_module.py</code> source code <pre><code>from pathlib import Path\nfrom typing import Any, cast\n\nmodel = None\n\n\ndef segment(\n    inputImage: Path | str,\n    segmentation: Path | str | None = None,\n    modelType=\"cyto\",\n    useGPU=False,\n    channels=[0, 0],\n    autoDiameter=True,\n    diameter=30,\n) -&gt; Any:\n    global model\n\n    inputImage = Path(inputImage)\n    if not inputImage.exists():\n        raise Exception(f\"Error: input image {inputImage} does not exist.\")\n\n    print(f\"[[1/4]] Load libraries and model {modelType}\")\n    print(\"Loading libraries...\")\n    import cellpose.models  # type: ignore\n    import cellpose.io  # type: ignore\n    import numpy as np  # type: ignore\n\n    if model is None or model.cp.model_type != modelType:\n        print(\"Loading model...\")\n        model = cellpose.models.Cellpose(gpu=True if useGPU == \"True\" else False, model_type=modelType)\n\n    print(f\"[[2/4]] Load image {inputImage}\")\n    image = cast(np.ndarray, cellpose.io.imread(str(inputImage)))\n\n    print(\"[[3/4]] Compute segmentation\", image.shape)\n    try:\n        kwargs: Any = dict(diameter=int(diameter)) if autoDiameter else {}\n        masks, flows, styles, diams = model.eval(image, channels=channels, **kwargs)\n    except Exception as e:\n        print(e)\n        raise e\n    print(\"segmentation finished.\")\n\n    # If segmentation is None: return all results\n    if segmentation is None:\n        return masks, flows, styles, diams\n\n    segmentation = Path(segmentation)\n    print(f\"[[4/4]] Save segmentation {segmentation}\")\n    # save results as png\n    cellpose.io.save_masks(image, masks, flows, str(inputImage), png=True)\n    output_mask = inputImage.parent / f\"{inputImage.stem}_cp_masks.png\"\n    if output_mask.exists():\n        if segmentation.exists():\n            segmentation.unlink()\n        (output_mask).rename(segmentation)\n        print(f\"Saved out: {segmentation}\")\n    else:\n        print(\"Segmentation was not generated because no masks were found.\")\n\n    return diams\n</code></pre>"},{"location":"getting_started/#summary-of-example-1-flow","title":"Summary of Example 1 Flow:","text":"<p>The main script uses <code>EnvironmentManager</code> to prepare an isolated environment. <code>env.launch()</code> starts a hidden server in that environment. <code>env.importModule()</code> provides a proxy, and calling functions on the proxy executes the code (like <code>example_module.segment</code>) within the isolated environment, handling data transfer automatically. <code>env.exit()</code> cleans up the server process.</p>"},{"location":"how_it_works/","title":"How it works","text":""},{"location":"how_it_works/#step-by-step","title":"\ud83c\udf93 Step by Step","text":"<p>Wetlands leverages Pixi, a package management tool for developers, or Micromamba, a fast, native reimplementation of the Conda package manager.</p> <ol> <li>Pixi or Micromamba Setup: When <code>EnvironmentManager</code> is initialized, it checks for a <code>pixi</code> or <code>micromamba</code> executable at the specified path (e.g., <code>\"micromamba/\"</code>). If not found, it downloads a self-contained Pixi or Micromamba binary suitable for the current operating system and architecture into that directory. This means Wetlands doesn't require a pre-existing Conda/Mamba installation.</li> <li>Environment Creation: <code>create(envName, dependencies)</code> uses Pixi or Micromamba commands (<code>pixi init /path/to/envName</code> or  <code>micromamba create -n envName -c channel package ...</code>) to build a new, isolated Conda environment within the Pixi or Micromamba prefix (e.g., <code>pixi/workspaces/envName/envs/default/</code> or <code>micromamba/envs/envName</code>). When using Pixi, Wetlands also creates a workspace for the environment (e.g. <code>pixi/workspace/envName/</code>). Note that the main environemnt is returned if it already satisfies the required dependencies.</li> <li>Dependency Installation: Dependencies (Conda packages, Pip packages) are installed into the target environment using <code>pixi add ...</code> or <code>micromamba install ...</code> and <code>pip install ...</code> (executed within the activated environment).</li> <li>Execution (<code>launch</code>/<code>execute</code>/<code>importModule</code>):<ul> <li><code>launch()</code> starts a helper Python script (<code>wetlands._internal.executor_server</code>) within the activated target environment using <code>subprocess.Popen</code>.</li> <li>This server listens on a local socket using <code>multiprocessing.connection.Listener</code>.</li> <li>The main process connects to this server using <code>multiprocessing.connection.Client</code>.</li> <li><code>execute(module, func, args)</code> sends a message containing the module path, function name, and arguments to the server.</li> <li>The server imports the module (if not already imported), executes the function with the provided arguments, and sends the result (or exception) back to the main process.</li> <li><code>importModule(module)</code> creates a proxy object in the main process. When methods are called on this proxy, it triggers the <code>execute</code> mechanism described above.</li> </ul> </li> <li>Direct Execution (<code>executeCommands</code>): This method directly activates the target environment and runs the provided shell commands using <code>subprocess.Popen</code> (no communication server involved here). The user is responsible for managing the launched process and any necessary communication.</li> <li>Isolation: Each environment created by Wetlands is fully isolated, preventing dependency conflicts between different environments or with the main application's environment.</li> </ol>"},{"location":"how_it_works/#under-the-hood","title":"\u2699\ufe0f Under the Hood","text":"<p>Wetlands uses the <code>EnvironmentManager.executeCommands()</code> for different operations (to create environments, install dependencies, etc).  Behind the scenes, this method creates and executes a temporary script (a bash script on Linux and Mac, and a PowerShell script on Windows) which looks like the following:</p> <pre><code># Initialize Micromamba\ncd \"/path/to/examples/micromamba\"\nexport MAMBA_ROOT_PREFIX=\"/path/to/examples/micromamba\"\neval \"$(micromamba shell hook -s posix)\"\n\n# Create the cellpose environment\ncd \"/Users/amasson/Travail/wetlands/examples\"\nmicromamba --rc-file \"/path/to/examples/micromamba/.mambarc\" create -n cellpose python=3.12.7 -y\n\n# Activate the environment\ncd \"/path/to/examples/\"\nmicromamba activate cellpose\n\n# Install the dependencies\necho \"Installing conda dependencies...\"\nmicromamba --rc-file \"/path/to/examples/micromamba/.mambarc\" install \"cellpose==3.1.0\" -y\n\n# Execute optional custom commands\npython -u example_module.py\n</code></pre>"},{"location":"shared_memory/","title":"Sharing memory among processes","text":"<p>The Python <code>multiprocessing.shared_memory</code> module enables to share memory among processes.</p> <p>The <code>shared_memory_example.py</code> script demonstrate this.</p> <p>Note</p> <p>Please see the shared memory helpers in the [<code>shared_memory</code> module][wetlands.shared_memory], even though there are not used in the examples.</p> <p>Note</p> <p>You need to install <code>numpy</code> to run this example, since it is used to save the resulting masks stored in the shared memory.</p> <p>It will use <code>shared_memory_module.py</code> to create the segmentation and the shared memory holding the resulting masks.</p> <p>This module defines two functions:</p> <ul> <li> <p>a <code>segment</code> function which uses the <code>segment</code> function of <code>example_module.py</code> and creates a NumPy array backed by a shared memory to store the resulting masks,</p> </li> <li> <p>a <code>clean</code> function to clean up, free and release the shared memory block.</p> </li> </ul> <pre><code>import numpy as np\nfrom pathlib import Path\nfrom multiprocessing import shared_memory\n\nimport example_module\n\nshm: shared_memory.SharedMemory | None = None\n\n\ndef segment(imagePath: Path | str):\n    global shm\n    # Segment the image with example_module.py\n    masks, flows, styles, diams = example_module.segment(imagePath)\n    # Create the shared memory\n    shm = shared_memory.SharedMemory(create=True, size=masks.nbytes)\n    # Create a NumPy array backed by shared memory\n    masksShared = np.ndarray(masks.shape, dtype=masks.dtype, buffer=shm.buf)\n    # Copy the masks into the shared memory\n    masksShared[:] = masks[:]\n    # Return the shape, dtype and shared memory name to recreate the numpy array on the other side\n    return masks.shape, masks.dtype, shm.name\n\n\ndef clean():\n    global shm\n    if shm is None:\n        return\n    # Clean up the shared memory in this process\n    shm.close()\n    # Free and release the shared memory block\n    shm.unlink()\n</code></pre> <p>The <code>shared_memory_example.py</code> script creates an environment using the initialization function from <code>getting_started.py</code>.</p> <p><code>shared_memory_example.py</code> <pre><code>from multiprocessing import shared_memory\nimport numpy as np\n\nimport getting_started\n\n# Create a Conda environment from getting_started.py\nimagePath, segmentationPath, env = getting_started.initialize()\n</code></pre></p> <p>Then, it imports <code>shared_memory_module.py</code> to perform a <code>cellpose</code> segmentation, and creates a shared memory for the resulting masks.</p> <pre><code># Import shared_memory_module in the environment\nsharedMemoryModule = env.importModule(\"shared_memory_module.py\")\n# run env.execute(module_name, function_name, args)\ndiameters, masksShape, masksDtype, shmName = sharedMemoryModule.segment(imagePath)\n</code></pre> <p>This shared memory can now be used in the main process, for example to save the masks as a numpy binary file:</p> <pre><code># Save the segmentation from the shared memory\nshm = shared_memory.SharedMemory(name=shmName)\nmasks = np.ndarray(masksShape, dtype=masksDtype, buffer=shm.buf)\nsegmentationPath = imagePath.parent / f\"{imagePath.stem}_segmentation.bin\"\nmasks.tofile(segmentationPath)\n\nprint(f\"Found diameters of {diameters} pixels.\")\n\n# Clean up and exit the environment\nenv.exit()\n</code></pre> <p>Note</p> <p>Changes to the shared memory made by one process will be refelcted in the other process. You can update the memory from both processes and perform more sofisticated operations.</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>Environment manager</li> <li>Environment</li> <li>Internal environment</li> <li>External environment</li> <li>internal<ul> <li>Command executor</li> <li>Command generator</li> <li>Config parser</li> <li>Dependency manager</li> <li>Exceptions</li> <li>Install</li> <li>Module executor</li> <li>Settings manager</li> </ul> </li> </ul>"},{"location":"reference/wetlands/environment/","title":"Environment","text":""},{"location":"reference/wetlands/environment/#wetlands.environment.Environment","title":"<code>Environment</code>","text":"<p>Methods:</p> Name Description <code>importModule</code> <p>Imports the given module (if necessary) and returns a fake module object</p> <code>install</code> <p>Installs dependencies.</p> <code>launch</code> <p>Launch the environment, only available in ExternalEnvironment. Do nothing when InternalEnvironment. See <code>ExternalEnvironment.launch</code></p> <code>executeCommands</code> <p>Executes the given commands in this environment.</p> <code>execute</code> <p>Execute the given function in the given module. See <code>ExternalEnvironment.execute</code> and <code>InternalEnvironment.execute</code></p> <code>launched</code> <p>Check if the environment is launched, important in ExternalEnvironment</p> <code>exit</code> <p>Exit the environment</p> <code>delete</code> <p>Delete this environment. Only available in ExternalEnvironment.</p> <code>update</code> <p>Update this environment with new dependencies. Only available in ExternalEnvironment.</p> Source code in <code>wetlands/environment.py</code> <pre><code>class Environment:\n    modules: dict[str, ModuleType] = {}\n\n    def __init__(self, name: str, path: Path | None, environmentManager: \"EnvironmentManager\") -&gt; None:\n        self.name = name\n        self.path = path.resolve() if isinstance(path, Path) else path\n        self.environmentManager = environmentManager\n\n    def _isModFunction(self, mod, func):\n        \"\"\"Checks that func is a function defined in module mod\"\"\"\n        return inspect.isfunction(func) and inspect.getmodule(func) == mod\n\n    def _listFunctions(self, mod):\n        \"\"\"Returns the list of functions defined in module mod\"\"\"\n        return [func.__name__ for func in mod.__dict__.values() if self._isModFunction(mod, func)]\n\n    def _importModule(self, modulePath: Path | str):\n        \"\"\"Imports the given module (if necessary) and adds it to the module map.\"\"\"\n        modulePath = Path(modulePath)\n        module = modulePath.stem\n        if module not in self.modules:\n            sys.path.append(str(modulePath.parent))\n            self.modules[module] = import_module(module)\n        return self.modules[module]\n\n    def importModule(self, modulePath: Path | str) -&gt; Any:\n        \"\"\"Imports the given module (if necessary) and returns a fake module object\n        that contains the same methods of the module which will be executed within the environment.\"\"\"\n        module = self._importModule(modulePath)\n\n        class FakeModule:\n            pass\n\n        for f in self._listFunctions(module):\n\n            def fakeFunction(*args, _wetlands_imported_function=f, **kwargs):\n                return self.execute(modulePath, _wetlands_imported_function, args, kwargs)\n\n            setattr(FakeModule, f, fakeFunction)\n        return FakeModule\n\n    def install(self, dependencies: Dependencies, additionalInstallCommands: Commands = {}) -&gt; list[str]:\n        \"\"\"Installs dependencies.\n        See [`EnvironmentManager.create`][wetlands.environment_manager.EnvironmentManager.create] for more details on the ``dependencies`` and ``additionalInstallCommands`` parameters.\n\n        Args:\n                dependencies: Dependencies to install.\n                additionalInstallCommands: Platform-specific commands during installation.\n        Returns:\n                Output lines of the installation commands.\n        \"\"\"\n        return self.environmentManager.install(self, dependencies, additionalInstallCommands)\n\n    def launch(self, additionalActivateCommands: Commands = {}, logOutputInThread: bool = True) -&gt; None:\n        \"\"\"Launch the environment, only available in [ExternalEnvironment][wetlands.external_environment.ExternalEnvironment]. Do nothing when InternalEnvironment. See [`ExternalEnvironment.launch`][wetlands.external_environment.ExternalEnvironment.launch]\"\"\"\n        return\n\n    def executeCommands(\n        self,\n        commands: Commands,\n        additionalActivateCommands: Commands = {},\n        popenKwargs: dict[str, Any] = {},\n        wait: bool = False,\n    ) -&gt; subprocess.Popen:\n        \"\"\"Executes the given commands in this environment.\n\n        Args:\n                commands: The commands to execute in the environment.\n                additionalActivateCommands: Platform-specific activation commands.\n                popenKwargs: Keyword arguments for subprocess.Popen(). See [`EnvironmentManager.executeCommands`][wetlands.environment_manager.EnvironmentManager.executeCommands].\n                wait: Whether to wait for the process to complete before returning.\n\n        Returns:\n                The launched process.\n        \"\"\"\n        return self.environmentManager.executeCommands(\n            self, commands, additionalActivateCommands, popenKwargs, wait=wait\n        )\n\n    @abstractmethod\n    def execute(self, modulePath: str | Path, function: str, args: tuple = (), kwargs: dict[str, Any] = {}) -&gt; Any:\n        \"\"\"Execute the given function in the given module. See [`ExternalEnvironment.execute`][wetlands.external_environment.ExternalEnvironment.execute] and [`InternalEnvironment.execute`][wetlands.internal_environment.InternalEnvironment.execute]\"\"\"\n        pass\n\n    def _exit(self) -&gt; None:\n        \"\"\"Exit the environment, important in ExternalEnvironment\"\"\"\n        pass\n\n    def launched(self) -&gt; bool:\n        \"\"\"Check if the environment is launched, important in ExternalEnvironment\"\"\"\n        return True\n\n    def exit(self) -&gt; None:\n        \"\"\"Exit the environment\"\"\"\n        self._exit()\n        self.environmentManager._removeEnvironment(self)\n\n    def delete(self) -&gt; None:\n        \"\"\"Delete this environment. Only available in ExternalEnvironment.\"\"\"\n        raise NotImplementedError(\"delete() is only available in ExternalEnvironment\")\n\n    def update(\n        self,\n        dependencies: Union[Dependencies, None] = None,\n        additionalInstallCommands: Commands = {},\n        useExisting: bool = False,\n    ) -&gt; \"Environment\":\n        \"\"\"Update this environment with new dependencies. Only available in ExternalEnvironment.\"\"\"\n        raise NotImplementedError(\"update() in ExternalEnvironment\")\n</code></pre>"},{"location":"reference/wetlands/environment/#wetlands.environment.Environment.importModule","title":"<code>importModule(modulePath)</code>","text":"<p>Imports the given module (if necessary) and returns a fake module object that contains the same methods of the module which will be executed within the environment.</p> Source code in <code>wetlands/environment.py</code> <pre><code>def importModule(self, modulePath: Path | str) -&gt; Any:\n    \"\"\"Imports the given module (if necessary) and returns a fake module object\n    that contains the same methods of the module which will be executed within the environment.\"\"\"\n    module = self._importModule(modulePath)\n\n    class FakeModule:\n        pass\n\n    for f in self._listFunctions(module):\n\n        def fakeFunction(*args, _wetlands_imported_function=f, **kwargs):\n            return self.execute(modulePath, _wetlands_imported_function, args, kwargs)\n\n        setattr(FakeModule, f, fakeFunction)\n    return FakeModule\n</code></pre>"},{"location":"reference/wetlands/environment/#wetlands.environment.Environment.install","title":"<code>install(dependencies, additionalInstallCommands={})</code>","text":"<p>Installs dependencies. See <code>EnvironmentManager.create</code> for more details on the <code>dependencies</code> and <code>additionalInstallCommands</code> parameters.</p> <p>Parameters:</p> Name Type Description Default <code>dependencies</code> <code>Dependencies</code> <p>Dependencies to install.</p> required <code>additionalInstallCommands</code> <code>Commands</code> <p>Platform-specific commands during installation.</p> <code>{}</code> <p>Returns:         Output lines of the installation commands.</p> Source code in <code>wetlands/environment.py</code> <pre><code>def install(self, dependencies: Dependencies, additionalInstallCommands: Commands = {}) -&gt; list[str]:\n    \"\"\"Installs dependencies.\n    See [`EnvironmentManager.create`][wetlands.environment_manager.EnvironmentManager.create] for more details on the ``dependencies`` and ``additionalInstallCommands`` parameters.\n\n    Args:\n            dependencies: Dependencies to install.\n            additionalInstallCommands: Platform-specific commands during installation.\n    Returns:\n            Output lines of the installation commands.\n    \"\"\"\n    return self.environmentManager.install(self, dependencies, additionalInstallCommands)\n</code></pre>"},{"location":"reference/wetlands/environment/#wetlands.environment.Environment.launch","title":"<code>launch(additionalActivateCommands={}, logOutputInThread=True)</code>","text":"<p>Launch the environment, only available in ExternalEnvironment. Do nothing when InternalEnvironment. See <code>ExternalEnvironment.launch</code></p> Source code in <code>wetlands/environment.py</code> <pre><code>def launch(self, additionalActivateCommands: Commands = {}, logOutputInThread: bool = True) -&gt; None:\n    \"\"\"Launch the environment, only available in [ExternalEnvironment][wetlands.external_environment.ExternalEnvironment]. Do nothing when InternalEnvironment. See [`ExternalEnvironment.launch`][wetlands.external_environment.ExternalEnvironment.launch]\"\"\"\n    return\n</code></pre>"},{"location":"reference/wetlands/environment/#wetlands.environment.Environment.executeCommands","title":"<code>executeCommands(commands, additionalActivateCommands={}, popenKwargs={}, wait=False)</code>","text":"<p>Executes the given commands in this environment.</p> <p>Parameters:</p> Name Type Description Default <code>commands</code> <code>Commands</code> <p>The commands to execute in the environment.</p> required <code>additionalActivateCommands</code> <code>Commands</code> <p>Platform-specific activation commands.</p> <code>{}</code> <code>popenKwargs</code> <code>dict[str, Any]</code> <p>Keyword arguments for subprocess.Popen(). See <code>EnvironmentManager.executeCommands</code>.</p> <code>{}</code> <code>wait</code> <code>bool</code> <p>Whether to wait for the process to complete before returning.</p> <code>False</code> <p>Returns:</p> Type Description <code>Popen</code> <p>The launched process.</p> Source code in <code>wetlands/environment.py</code> <pre><code>def executeCommands(\n    self,\n    commands: Commands,\n    additionalActivateCommands: Commands = {},\n    popenKwargs: dict[str, Any] = {},\n    wait: bool = False,\n) -&gt; subprocess.Popen:\n    \"\"\"Executes the given commands in this environment.\n\n    Args:\n            commands: The commands to execute in the environment.\n            additionalActivateCommands: Platform-specific activation commands.\n            popenKwargs: Keyword arguments for subprocess.Popen(). See [`EnvironmentManager.executeCommands`][wetlands.environment_manager.EnvironmentManager.executeCommands].\n            wait: Whether to wait for the process to complete before returning.\n\n    Returns:\n            The launched process.\n    \"\"\"\n    return self.environmentManager.executeCommands(\n        self, commands, additionalActivateCommands, popenKwargs, wait=wait\n    )\n</code></pre>"},{"location":"reference/wetlands/environment/#wetlands.environment.Environment.execute","title":"<code>execute(modulePath, function, args=(), kwargs={})</code>  <code>abstractmethod</code>","text":"<p>Execute the given function in the given module. See <code>ExternalEnvironment.execute</code> and <code>InternalEnvironment.execute</code></p> Source code in <code>wetlands/environment.py</code> <pre><code>@abstractmethod\ndef execute(self, modulePath: str | Path, function: str, args: tuple = (), kwargs: dict[str, Any] = {}) -&gt; Any:\n    \"\"\"Execute the given function in the given module. See [`ExternalEnvironment.execute`][wetlands.external_environment.ExternalEnvironment.execute] and [`InternalEnvironment.execute`][wetlands.internal_environment.InternalEnvironment.execute]\"\"\"\n    pass\n</code></pre>"},{"location":"reference/wetlands/environment/#wetlands.environment.Environment.launched","title":"<code>launched()</code>","text":"<p>Check if the environment is launched, important in ExternalEnvironment</p> Source code in <code>wetlands/environment.py</code> <pre><code>def launched(self) -&gt; bool:\n    \"\"\"Check if the environment is launched, important in ExternalEnvironment\"\"\"\n    return True\n</code></pre>"},{"location":"reference/wetlands/environment/#wetlands.environment.Environment.exit","title":"<code>exit()</code>","text":"<p>Exit the environment</p> Source code in <code>wetlands/environment.py</code> <pre><code>def exit(self) -&gt; None:\n    \"\"\"Exit the environment\"\"\"\n    self._exit()\n    self.environmentManager._removeEnvironment(self)\n</code></pre>"},{"location":"reference/wetlands/environment/#wetlands.environment.Environment.delete","title":"<code>delete()</code>","text":"<p>Delete this environment. Only available in ExternalEnvironment.</p> Source code in <code>wetlands/environment.py</code> <pre><code>def delete(self) -&gt; None:\n    \"\"\"Delete this environment. Only available in ExternalEnvironment.\"\"\"\n    raise NotImplementedError(\"delete() is only available in ExternalEnvironment\")\n</code></pre>"},{"location":"reference/wetlands/environment/#wetlands.environment.Environment.update","title":"<code>update(dependencies=None, additionalInstallCommands={}, useExisting=False)</code>","text":"<p>Update this environment with new dependencies. Only available in ExternalEnvironment.</p> Source code in <code>wetlands/environment.py</code> <pre><code>def update(\n    self,\n    dependencies: Union[Dependencies, None] = None,\n    additionalInstallCommands: Commands = {},\n    useExisting: bool = False,\n) -&gt; \"Environment\":\n    \"\"\"Update this environment with new dependencies. Only available in ExternalEnvironment.\"\"\"\n    raise NotImplementedError(\"update() in ExternalEnvironment\")\n</code></pre>"},{"location":"reference/wetlands/environment_manager/","title":"Environment manager","text":""},{"location":"reference/wetlands/environment_manager/#wetlands.environment_manager.EnvironmentManager","title":"<code>EnvironmentManager</code>","text":"<p>Manages Conda environments using micromamba for isolation and dependency management.</p> <p>Attributes:</p> Name Type Description <code>mainEnvironment</code> <code>InternalEnvironment</code> <p>The main conda environment in which wetlands is installed.</p> <code>environments</code> <code>dict[str | Path, Environment]</code> <p>map of the environments</p> <code>settingsManager</code> <p>SettingsManager(condaPath)</p> <code>commandGenerator</code> <p>CommandGenerator(settingsManager)</p> <code>dependencyManager</code> <p>DependencyManager(commandGenerator)</p> <code>commandExecutor</code> <p>CommandExecutor()</p> <p>Methods:</p> Name Description <code>__init__</code> <p>Initializes the EnvironmentManager.</p> <code>installConda</code> <p>Install Pixi or Micromamba (depending on settingsManager.usePixi)</p> <code>setCondaPath</code> <p>Updates the micromamba path and loads proxy settings if exists.</p> <code>setProxies</code> <p>Configures proxy settings for Conda operations.</p> <code>getInstalledPackages</code> <p>Get the list of the packages installed in the environment</p> <code>environmentExists</code> <p>Checks if a Conda environment exists.</p> <code>create</code> <p>Creates a new Conda environment with specified dependencies or returns an existing one.</p> <code>createFromConfig</code> <p>Creates a new Conda environment from a config file (pixi.toml, pyproject.toml, environment.yml, or requirements.txt) or returns an existing one.</p> <code>load</code> <p>Load an existing Conda environment from disk.</p> <code>install</code> <p>Installs dependencies.</p> <code>executeCommands</code> <p>Executes the given commands in the given environment.</p> <code>registerEnvironment</code> <p>Register the environment (save its debug port to <code>wetlandsInstancePath / debug_ports.json</code>) so that it can be debugged later.</p> Source code in <code>wetlands/environment_manager.py</code> <pre><code>class EnvironmentManager:\n    \"\"\"Manages Conda environments using micromamba for isolation and dependency management.\n\n    Attributes:\n            mainEnvironment: The main conda environment in which wetlands is installed.\n            environments: map of the environments\n\n            settingsManager: SettingsManager(condaPath)\n            commandGenerator: CommandGenerator(settingsManager)\n            dependencyManager: DependencyManager(commandGenerator)\n            commandExecutor: CommandExecutor()\n    \"\"\"\n\n    mainEnvironment: InternalEnvironment\n    wetlandsInstancePath: Path\n    debug: bool\n\n    def __init__(\n        self,\n        wetlandsInstancePath: Path = Path(\"wetlands\"),\n        condaPath: str | Path | None = None,\n        mainCondaEnvironmentPath: Path | None = None,\n        debug: bool = False,\n        manager=\"auto\",\n    ) -&gt; None:\n        \"\"\"Initializes the EnvironmentManager.\n\n        The wetlandsInstancePath directory will contain:\n        - logs (managed by logger.py)\n        - debug_ports.json (for debug port tracking)\n        - conda installation (by default at wetlandsInstancePath / \"pixi\" or \"micromamba\")\n\n        Args:\n                wetlandsInstancePath: Path to the folder which will contain the state of this wetlands instance (logs, debug ports stored in debug_ports.json, and conda installation). Defaults to \"wetlands\".\n                condaPath: Path to the micromamba or pixi installation path. If None, defaults to wetlandsInstancePath / \"pixi\". Warning: cannot contain any space character on Windows when using micromamba.\n                mainCondaEnvironmentPath: Path of the main conda environment in which Wetlands is installed, used to check whether it is necessary to create new environments (only when dependencies are not already available in the main environment). When using Pixi, this must point to the pixi.toml or pyproject.toml file.\n                debug: When true, processes will listen to debugpy ( debugpy.listen(0) ) to enable debugging, and their ports will be sorted in  wetlandsInstancePath / debug_ports.json\n                manager: Use \"pixi\" to use Pixi as the conda manager, \"micromamba\" to use Micromamba and \"auto\" to infer from condaPath (will look for \"pixi\" or \"micromamba\" in the path).\n        \"\"\"\n        from wetlands.logger import setLogFilePath\n\n        self.environments: dict[str | Path, Environment] = {}\n        self.wetlandsInstancePath = cast(Path, wetlandsInstancePath).resolve()\n\n        # Set default condaPath if not provided\n        if condaPath is None:\n            condaPath = self.wetlandsInstancePath / \"pixi\"\n\n        condaPath = Path(condaPath)\n\n        # Initialize logger to use the wetlandsInstancePath for logs\n        setLogLevel(logging.DEBUG if debug else logging.INFO)\n        setLogFilePath(self.wetlandsInstancePath / \"wetlands.log\")\n\n        usePixi = self._initManager(manager, condaPath)\n\n        if platform.system() == \"Windows\" and (not usePixi) and \" \" in str(condaPath) and not condaPath.exists():\n            raise Exception(\n                f'The Micromamba path cannot contain any space character on Windows (given path is \"{condaPath}\").'\n            )\n\n        self.mainEnvironment = InternalEnvironment(\"wetlands_main\", mainCondaEnvironmentPath, self)\n        self.environments[\"wetlands_main\"] = self.mainEnvironment\n        self.settingsManager = SettingsManager(condaPath, usePixi)\n        self.debug = debug\n        self.installConda()\n        self.commandGenerator = CommandGenerator(self.settingsManager)\n        self.dependencyManager = DependencyManager(self.commandGenerator)\n        self.commandExecutor = CommandExecutor(self.wetlandsInstancePath / \"command_executions\" if debug else None)\n\n    def _initManager(self, manager: str, condaPath: Path) -&gt; bool:\n        if manager not in [\"auto\", \"pixi\", \"micromamba\"]:\n            raise Exception(f'Invalid manager \"{manager}\", must be \"auto\", \"pixi\" or \"micromamba\".')\n        if manager == \"auto\":\n            if \"pixi\" in str(condaPath).lower():\n                usePixi = True\n            elif \"micromamba\" in str(condaPath).lower():\n                usePixi = False\n            else:\n                raise Exception(\n                    'When using manager=\"auto\", the condaPath must contain either \"pixi\" or \"micromamba\" to infer the manager to use.'\n                )\n        elif manager == \"pixi\":\n            usePixi = True\n        else:\n            usePixi = False\n        return usePixi\n\n    def installConda(self):\n        \"\"\"Install Pixi or Micromamba (depending on settingsManager.usePixi)\"\"\"\n\n        condaPath, condaBinPath = self.settingsManager.getCondaPaths()\n        if (condaPath / condaBinPath).exists():\n            return []\n\n        condaPath.mkdir(exist_ok=True, parents=True)\n\n        if self.settingsManager.usePixi:\n            installPixi(condaPath, proxies=self.settingsManager.proxies)\n        else:\n            installMicromamba(condaPath, proxies=self.settingsManager.proxies)\n        return\n\n    def setCondaPath(self, condaPath: str | Path, usePixi: bool = True) -&gt; None:\n        \"\"\"Updates the micromamba path and loads proxy settings if exists.\n\n        Args:\n                condaPath: New path to micromamba binary.\n                usePixi: Whether to use Pixi or Micromamba\n\n        Side Effects:\n                Updates self.settingsManager.condaBinConfig, and self.settingsManager.proxies from the .mambarc file.\n        \"\"\"\n        self.settingsManager.setCondaPath(condaPath, usePixi)\n\n    def setProxies(self, proxies: dict[str, str]) -&gt; None:\n        \"\"\"Configures proxy settings for Conda operations.\n\n        Args:\n                proxies: Proxy configuration dictionary (e.g., {\"http\": \"...\", \"https\": \"...\"}).\n\n        Side Effects:\n                Updates .mambarc configuration file with proxy settings.\n        \"\"\"\n        self.settingsManager.setProxies(proxies)\n\n    def _removeChannel(self, condaDependency: str) -&gt; str:\n        \"\"\"Removes channel prefix from a Conda dependency string (e.g., \"channel::package\" -&gt; \"package\").\"\"\"\n        return condaDependency.split(\"::\")[1] if \"::\" in condaDependency else condaDependency\n\n    def getInstalledPackages(self, environment: Environment) -&gt; list[dict[str, str]]:\n        \"\"\"Get the list of the packages installed in the environment\n\n        Args:\n                environment: The environment name.\n\n        Returns:\n                A list of dict containing the installed packages [{\"kind\":\"conda|pypi\", \"name\": \"numpy\", \"version\", \"2.1.3\"}, ...].\n        \"\"\"\n        if self.settingsManager.usePixi:\n            commands = self.commandGenerator.getActivateCondaCommands()\n            commands += [f'{self.settingsManager.condaBin} list --json --manifest-path \"{environment.path}\"']\n            return self.commandExecutor.executeCommandAndGetJsonOutput(commands, log=False)\n        else:\n            commands = self.commandGenerator.getActivateEnvironmentCommands(environment) + [\n                f\"{self.settingsManager.condaBin} list --json\",\n            ]\n            packages = self.commandExecutor.executeCommandAndGetJsonOutput(commands, log=False)\n            for package in packages:\n                package[\"kind\"] = \"conda\"\n\n            commands = self.commandGenerator.getActivateEnvironmentCommands(environment) + [\n                f\"pip freeze --all\",\n            ]\n            output = self.commandExecutor.executeCommandsAndGetOutput(commands, log=False)\n            parsedOutput = [o.split(\"==\") for o in output if \"==\" in o]\n            packages += [{\"name\": name, \"version\": version, \"kind\": \"pypi\"} for name, version in parsedOutput]\n            return packages\n\n    def _checkRequirement(\n        self, dependency: str, packageManager: Literal[\"pip\", \"conda\"], installedPackages: list[dict[str, str]]\n    ) -&gt; bool:\n        \"\"\"Check if dependency is installed (exists in installedPackages).\n\n        Supports PEP 440 version specifiers like:\n        - \"numpy\" (any version)\n        - \"numpy==1.20.0\" (exact version)\n        - \"numpy&gt;=1.20,&lt;2.0\" (version range)\n        - \"numpy~=2.28\" (compatible release)\n        - \"numpy!=1.5.0\" (any except specific version)\n        \"\"\"\n        if packageManager == \"conda\":\n            dependency = self._removeChannel(dependency)\n\n        packageManagerName = \"conda\" if packageManager == \"conda\" else \"pypi\"\n\n        # Parse dependency string to extract package name and version specifier\n        # Package name is followed by optional version specifier (starts with ==, &gt;=, &lt;=, &gt;, &lt;, !=, ~=)\n        match = re.match(r\"^([a-zA-Z0-9._-]+)((?:[&lt;&gt;=!~].*)?)\", dependency)\n        if not match:\n            return False\n\n        package_name = match.group(1)\n        version_spec = match.group(2).strip()\n\n        # Find matching package\n        for package in installedPackages:\n            if package_name != package[\"name\"] or packageManagerName != package[\"kind\"]:\n                continue\n\n            # If no version specified, just match on name\n            if not version_spec:\n                return True\n\n            # Check version against specifier using packaging library\n            try:\n                installed_version = Version(package[\"version\"])\n                specifier_set = SpecifierSet(version_spec)\n                if installed_version in specifier_set:\n                    return True\n            except InvalidVersion:\n                # If version parsing fails, continue to next package\n                continue\n\n        return False\n\n    def _environmentValidatesRequirements(self, environment: Environment, dependencies: Dependencies) -&gt; bool:\n        \"\"\"Verifies if all specified dependencies are installed in the given environment.\n\n        Applies special handling for main environment with None path (uses metadata.distributions() for pip packages).\n\n        Args:\n                environment: The environment to check.\n                dependencies: Dependencies to verify.\n\n        Returns:\n                True if all dependencies are installed, False otherwise.\n        \"\"\"\n        if not sys.version.startswith(dependencies.get(\"python\", \"\").replace(\"=\", \"\")):\n            return False\n\n        condaDependencies, condaDependenciesNoDeps, hasCondaDependencies = self.dependencyManager.formatDependencies(\n            \"conda\", dependencies, False, False\n        )\n        pipDependencies, pipDependenciesNoDeps, hasPipDependencies = self.dependencyManager.formatDependencies(\n            \"pip\", dependencies, False, False\n        )\n        if not hasPipDependencies and not hasCondaDependencies:\n            return True\n\n        # Special handling for main environment with None path\n        isMainEnvironment = environment == self.mainEnvironment\n        if isMainEnvironment and environment.path is None:\n            if hasCondaDependencies:\n                return False\n            if hasPipDependencies:\n                installedPackages = [\n                    {\"name\": dist.metadata[\"Name\"], \"version\": dist.version, \"kind\": \"pypi\"}\n                    for dist in metadata.distributions()\n                ]\n            else:\n                return True\n        else:\n            # Get installed packages for the environment\n            installedPackages = self.getInstalledPackages(environment)\n\n        condaSatisfied = (\n            all(\n                [\n                    self._checkRequirement(d, \"conda\", installedPackages)\n                    for d in condaDependencies + condaDependenciesNoDeps\n                ]\n            )\n            if hasCondaDependencies\n            else True\n        )\n        pipSatisfied = (\n            all([self._checkRequirement(d, \"pip\", installedPackages) for d in pipDependencies + pipDependenciesNoDeps])\n            if hasPipDependencies\n            else True\n        )\n\n        return condaSatisfied and pipSatisfied\n\n    def environmentExists(self, environmentPath: Path) -&gt; bool:\n        \"\"\"Checks if a Conda environment exists.\n\n        Args:\n                environmentPath: Environment name to check.\n\n        Returns:\n                True if environment exists, False otherwise.\n        \"\"\"\n        if self.settingsManager.usePixi:\n            condaMeta = environmentPath.parent / \".pixi\" / \"envs\" / \"default\" / \"conda-meta\"\n            return environmentPath.is_file() and condaMeta.is_dir()\n        else:\n            condaMeta = environmentPath / \"conda-meta\"\n            return condaMeta.is_dir()\n\n    def _addDebugpyInDependencies(self, dependencies: Dependencies) -&gt; None:\n        \"\"\"Add debugpy in the dependencies to be able to debug in debug mode. Does nothing when not in debug mode.\n\n        Args:\n                dependencies: Dependencies to install.\n        \"\"\"\n        if not self.debug:\n            return\n        # Check that debugpy is not already in dependencies\n        for packageManager in [\"pip\", \"conda\"]:\n            if packageManager in dependencies:\n                for dep in dependencies[packageManager]:\n                    import re\n\n                    pattern = r\"debugpy(?==|$)\"\n                    if isinstance(dep, str):\n                        if bool(re.search(pattern, dep)):\n                            return\n                    elif dep[\"name\"] == \"debugpy\":\n                        return\n        # Add debugpy without version because we need one compatible with the required python version\n        # Use conda (conda forge) since there are more versions available (especially for python 3.9 on macOS arm64)\n        debugpy = \"debugpy\"\n        if \"conda\" in dependencies:\n            dependencies[\"conda\"].append(debugpy)\n        else:\n            dependencies[\"conda\"] = [debugpy]\n        return\n\n    def _parseDependenciesFromConfig(\n        self,\n        config_path: Union[str, Path],\n        environmentName: str | None = None,\n        optionalDependencies: list[str] | None = None,\n    ) -&gt; Dependencies:\n        \"\"\"Parse dependencies from a config file (pixi.toml, pyproject.toml, or environment.yml).\n\n        Args:\n                config_path: Path to configuration file\n                environmentName: Environment name for pixi/pyproject configs\n                optionalDependencies: Optional dependency groups for pyproject configs\n\n        Returns:\n                Dependencies dict\n\n        Raises:\n                FileNotFoundError: If config file doesn't exist\n                ValueError: If config format is invalid or parameters are missing\n        \"\"\"\n        config_path = Path(config_path)\n        parser = ConfigParser()\n\n        # Detect and validate config file type\n        try:\n            file_type = parser.detectConfigFileType(config_path)\n        except ValueError as e:\n            raise ValueError(f\"Unsupported config file: {e}\")\n\n        # Validate required parameters for specific file types\n        if file_type == \"pixi\" and not environmentName:\n            raise ValueError(\n                f\"environmentName is required for pixi.toml files. \"\n                f\"Please provide the environment name to extract dependencies from.\"\n            )\n\n        if file_type == \"pyproject\" and not environmentName and not optionalDependencies:\n            raise ValueError(\n                f\"For pyproject.toml, provide either environmentName (for pixi config) \"\n                f\"or optionalDependencies (for optional dependency groups).\"\n            )\n\n        # Parse the config file\n        return parser.parse(\n            config_path,\n            environmentName=environmentName,\n            optionalDependencies=optionalDependencies,\n        )\n\n    def create(\n        self,\n        name: str,\n        dependencies: Union[Dependencies, None] = None,\n        additionalInstallCommands: Commands = {},\n        useExisting: bool = False,\n    ) -&gt; Environment:\n        \"\"\"Creates a new Conda environment with specified dependencies or returns an existing one.\n\n        Args:\n                name: Name for the new environment.\n                dependencies: Dependencies to install. Can be one of:\n                    - A Dependencies dict: dict(python=\"3.12.7\", conda=[\"numpy\"], pip=[\"requests\"])\n                    - None (no dependencies to install)\n                additionalInstallCommands: Platform-specific commands during installation (e.g. {\"mac\": [\"cd ...\", \"wget https://...\", \"unzip ...\"], \"all\"=[], ...}).\n                useExisting: if True, search through existing environments and return the first one that satisfies the dependencies instead of creating a new one.\n\n        Returns:\n                The created or existing environment (ExternalEnvironment if created, or an existing environment if useExisting=True and match found).\n        \"\"\"\n        if isinstance(name, Path):\n            raise Exception(\n                \"Environment name cannot be a Path, use EnvironmentManager.load() to load an existing environment.\"\n            )\n\n        if name in self.environments:\n            logger.debug(f\"Environment '{name}' already exists, returning existing instance.\")\n            return self.environments[name]\n\n        if dependencies is None:\n            dependencies = {}\n        elif not isinstance(dependencies, dict):\n            raise ValueError(f\"Unsupported dependencies type: {type(dependencies)}\")\n\n        self._addDebugpyInDependencies(dependencies)\n\n        # Try to find existing environment if useExisting=True\n        if useExisting:\n            envs = [self.mainEnvironment] + [env for env in self.environments.values() if env != self.mainEnvironment]\n            for env in envs:\n                try:\n                    if self._environmentValidatesRequirements(env, dependencies):\n                        logger.debug(f\"Environment '{env.name}' satisfies dependencies for '{name}', returning it.\")\n                        return env\n                except Exception as e:\n                    logger.debug(f\"Error checking environment '{env.name}': {e}\")\n                    continue\n\n        # Create new environment\n        pythonVersion = dependencies.get(\"python\", \"\").replace(\"=\", \"\")\n        match = re.search(r\"(\\d+)\\.(\\d+)\", pythonVersion)\n        if match and (int(match.group(1)) &lt; 3 or int(match.group(2)) &lt; 9):\n            raise Exception(\"Python version must be greater than 3.8\")\n        pythonRequirement = \" python=\" + (pythonVersion if len(pythonVersion) &gt; 0 else platform.python_version())\n        createEnvCommands = self.commandGenerator.getActivateCondaCommands()\n        path = self.settingsManager.getEnvironmentPathFromName(name)\n        if self.settingsManager.usePixi:\n            manifestPath = path\n            if not manifestPath.exists():\n                platformArgs = f\"--platform win-64\" if platform.system() == \"Windows\" else \"\"\n                createEnvCommands += [\n                    f'{self.settingsManager.condaBin} init --no-progress {platformArgs} \"{manifestPath.parent}\"'\n                ]\n            createEnvCommands += [\n                f'{self.settingsManager.condaBin} add --no-progress --manifest-path \"{manifestPath}\" {pythonRequirement}'\n            ]\n        else:\n            createEnvCommands += [f\"{self.settingsManager.condaBinConfig} create -n {name}{pythonRequirement} -y\"]\n        environment = ExternalEnvironment(name, path, self)\n        self.environments[name] = environment\n        createEnvCommands += self.dependencyManager.getInstallDependenciesCommands(environment, dependencies)\n        createEnvCommands += self.commandGenerator.getCommandsForCurrentPlatform(additionalInstallCommands)\n        self.commandExecutor.executeCommandsAndGetOutput(createEnvCommands)\n        return self.environments[name]\n\n    def createFromConfig(\n        self,\n        name: str,\n        configPath: str | Path,\n        optionalDependencies: list[str] | None = None,\n        additionalInstallCommands: Commands = {},\n        useExisting: bool = False,\n    ) -&gt; Environment:\n        \"\"\"Creates a new Conda environment from a config file (pixi.toml, pyproject.toml, environment.yml, or requirements.txt) or returns an existing one.\n\n        Args:\n                name: Name for the new environment.\n                configPath: Path to configuration file (pixi.toml, pyproject.toml, environment.yml, or requirements.txt).\n                optionalDependencies: List of optional dependency groups to extract from pyproject.toml.\n                additionalInstallCommands: Platform-specific commands during installation.\n                useExisting: if True, search through existing environments and return the first one that satisfies the dependencies instead of creating a new one.\n\n        Returns:\n                The created or existing environment (ExternalEnvironment if created, or an existing environment if useExisting=True and match found).\n        \"\"\"\n\n        # Parse config file\n        dependencies = self._parseDependenciesFromConfig(\n            configPath, environmentName=name, optionalDependencies=optionalDependencies\n        )\n\n        # Use create() with parsed dependencies\n        return self.create(name, dependencies, additionalInstallCommands, useExisting)\n\n    def load(\n        self,\n        name: str,\n        environmentPath: Path,\n    ) -&gt; Environment:\n        \"\"\"Load an existing Conda environment from disk.\n\n        Args:\n                name: Name for the environment instance.\n                environmentPath: Path to an existing Conda environment, or the folder containing the pixi.toml/pyproject.toml when using Pixi.\n\n        Returns:\n                The loaded environment (ExternalEnvironment if using Pixi or micromamba with a path, InternalEnvironment otherwise).\n\n        Raises:\n                Exception: If the environment does not exist.\n        \"\"\"\n        environmentPath = environmentPath.resolve()\n\n        if not self.environmentExists(environmentPath):\n            raise Exception(f\"The environment {environmentPath} was not found.\")\n\n        if name not in self.environments:\n            self.environments[name] = ExternalEnvironment(name, environmentPath, self)\n        return self.environments[name]\n\n    def install(\n        self, environment: Environment, dependencies: Dependencies, additionalInstallCommands: Commands = {}\n    ) -&gt; list[str]:\n        \"\"\"Installs dependencies.\n        See [`EnvironmentManager.create`][wetlands.environment_manager.EnvironmentManager.create] for more details on the ``dependencies`` and ``additionalInstallCommands`` parameters.\n\n        Args:\n                environmentName: The environment to install dependencies.\n                dependencies: Dependencies to install.\n                additionalInstallCommands: Platform-specific commands during installation.\n\n        Returns:\n                Output lines of the installation commands.\n        \"\"\"\n        if environment == self.mainEnvironment and self.settingsManager.usePixi:\n            raise Exception(\"Cannot install packages in an InternalEnvironment when using Pixi.\")\n        if environment == self.mainEnvironment and environment.path is None:\n            raise Exception(\"Cannot install packages in an InternalEnvironment with no conda path.\")\n\n        installCommands = self.dependencyManager.getInstallDependenciesCommands(environment, dependencies)\n        installCommands += self.commandGenerator.getCommandsForCurrentPlatform(additionalInstallCommands)\n        return self.commandExecutor.executeCommandsAndGetOutput(installCommands)\n\n    def executeCommands(\n        self,\n        environment: Environment,\n        commands: Commands,\n        additionalActivateCommands: Commands = {},\n        popenKwargs: dict[str, Any] = {},\n        wait: bool = False,\n    ) -&gt; subprocess.Popen:\n        \"\"\"Executes the given commands in the given environment.\n\n        Args:\n                environment: The environment in which to execute commands.\n                commands: The commands to execute in the environment.\n                additionalActivateCommands: Platform-specific activation commands.\n                popenKwargs: Keyword arguments for subprocess.Popen() (see [Popen documentation](https://docs.python.org/3/library/subprocess.html#popen-constructor)). Defaults are: dict(stdout=subprocess.PIPE, stderr=subprocess.STDOUT, stdin=subprocess.DEVNULL, encoding=\"utf-8\", errors=\"replace\", bufsize=1).\n\n        Returns:\n                The launched process.\n        \"\"\"\n        activateCommands = self.commandGenerator.getActivateEnvironmentCommands(environment, additionalActivateCommands)\n        platformCommands = self.commandGenerator.getCommandsForCurrentPlatform(commands)\n        return self.commandExecutor.executeCommands(\n            activateCommands + platformCommands, popenKwargs=popenKwargs, wait=wait\n        )\n\n    def registerEnvironment(self, environment: ExternalEnvironment, debugPort: int, moduleExecutorPath: Path) -&gt; None:\n        \"\"\"\n        Register the environment (save its debug port to `wetlandsInstancePath / debug_ports.json`) so that it can be debugged later.\n\n        Args:\n                environment: The external environment object to register\n                debugPort: The debug port to save\n        \"\"\"\n        if environment.process is None:\n            return\n        wetlands_debug_ports_path = self.wetlandsInstancePath / \"debug_ports.json\"\n        wetlands_debug_ports_path.parent.mkdir(exist_ok=True, parents=True)\n        wetlands_debug_ports = {}\n        try:\n            if wetlands_debug_ports_path.exists():\n                with open(wetlands_debug_ports_path, \"r\") as f:\n                    wetlands_debug_ports = json.load(f)\n            wetlands_debug_ports[environment.name] = dict(\n                debugPort=debugPort, moduleExecutorPath=moduleExecutorPath.as_posix()\n            )\n            with open(wetlands_debug_ports_path, \"w\") as f:\n                json.dump(wetlands_debug_ports, f)\n        except Exception as e:\n            e.add_note(f\"Error while updating the debug ports file {wetlands_debug_ports_path}.\")\n            raise e\n        return\n\n    def _removeEnvironment(self, environment: Environment) -&gt; None:\n        \"\"\"Remove an environment.\n\n        Args:\n                environment: instance to remove.\n        \"\"\"\n        if environment.name in self.environments:\n            del self.environments[environment.name]\n</code></pre>"},{"location":"reference/wetlands/environment_manager/#wetlands.environment_manager.EnvironmentManager.__init__","title":"<code>__init__(wetlandsInstancePath=Path('wetlands'), condaPath=None, mainCondaEnvironmentPath=None, debug=False, manager='auto')</code>","text":"<p>Initializes the EnvironmentManager.</p> <p>The wetlandsInstancePath directory will contain: - logs (managed by logger.py) - debug_ports.json (for debug port tracking) - conda installation (by default at wetlandsInstancePath / \"pixi\" or \"micromamba\")</p> <p>Parameters:</p> Name Type Description Default <code>wetlandsInstancePath</code> <code>Path</code> <p>Path to the folder which will contain the state of this wetlands instance (logs, debug ports stored in debug_ports.json, and conda installation). Defaults to \"wetlands\".</p> <code>Path('wetlands')</code> <code>condaPath</code> <code>str | Path | None</code> <p>Path to the micromamba or pixi installation path. If None, defaults to wetlandsInstancePath / \"pixi\". Warning: cannot contain any space character on Windows when using micromamba.</p> <code>None</code> <code>mainCondaEnvironmentPath</code> <code>Path | None</code> <p>Path of the main conda environment in which Wetlands is installed, used to check whether it is necessary to create new environments (only when dependencies are not already available in the main environment). When using Pixi, this must point to the pixi.toml or pyproject.toml file.</p> <code>None</code> <code>debug</code> <code>bool</code> <p>When true, processes will listen to debugpy ( debugpy.listen(0) ) to enable debugging, and their ports will be sorted in  wetlandsInstancePath / debug_ports.json</p> <code>False</code> <code>manager</code> <p>Use \"pixi\" to use Pixi as the conda manager, \"micromamba\" to use Micromamba and \"auto\" to infer from condaPath (will look for \"pixi\" or \"micromamba\" in the path).</p> <code>'auto'</code> Source code in <code>wetlands/environment_manager.py</code> <pre><code>def __init__(\n    self,\n    wetlandsInstancePath: Path = Path(\"wetlands\"),\n    condaPath: str | Path | None = None,\n    mainCondaEnvironmentPath: Path | None = None,\n    debug: bool = False,\n    manager=\"auto\",\n) -&gt; None:\n    \"\"\"Initializes the EnvironmentManager.\n\n    The wetlandsInstancePath directory will contain:\n    - logs (managed by logger.py)\n    - debug_ports.json (for debug port tracking)\n    - conda installation (by default at wetlandsInstancePath / \"pixi\" or \"micromamba\")\n\n    Args:\n            wetlandsInstancePath: Path to the folder which will contain the state of this wetlands instance (logs, debug ports stored in debug_ports.json, and conda installation). Defaults to \"wetlands\".\n            condaPath: Path to the micromamba or pixi installation path. If None, defaults to wetlandsInstancePath / \"pixi\". Warning: cannot contain any space character on Windows when using micromamba.\n            mainCondaEnvironmentPath: Path of the main conda environment in which Wetlands is installed, used to check whether it is necessary to create new environments (only when dependencies are not already available in the main environment). When using Pixi, this must point to the pixi.toml or pyproject.toml file.\n            debug: When true, processes will listen to debugpy ( debugpy.listen(0) ) to enable debugging, and their ports will be sorted in  wetlandsInstancePath / debug_ports.json\n            manager: Use \"pixi\" to use Pixi as the conda manager, \"micromamba\" to use Micromamba and \"auto\" to infer from condaPath (will look for \"pixi\" or \"micromamba\" in the path).\n    \"\"\"\n    from wetlands.logger import setLogFilePath\n\n    self.environments: dict[str | Path, Environment] = {}\n    self.wetlandsInstancePath = cast(Path, wetlandsInstancePath).resolve()\n\n    # Set default condaPath if not provided\n    if condaPath is None:\n        condaPath = self.wetlandsInstancePath / \"pixi\"\n\n    condaPath = Path(condaPath)\n\n    # Initialize logger to use the wetlandsInstancePath for logs\n    setLogLevel(logging.DEBUG if debug else logging.INFO)\n    setLogFilePath(self.wetlandsInstancePath / \"wetlands.log\")\n\n    usePixi = self._initManager(manager, condaPath)\n\n    if platform.system() == \"Windows\" and (not usePixi) and \" \" in str(condaPath) and not condaPath.exists():\n        raise Exception(\n            f'The Micromamba path cannot contain any space character on Windows (given path is \"{condaPath}\").'\n        )\n\n    self.mainEnvironment = InternalEnvironment(\"wetlands_main\", mainCondaEnvironmentPath, self)\n    self.environments[\"wetlands_main\"] = self.mainEnvironment\n    self.settingsManager = SettingsManager(condaPath, usePixi)\n    self.debug = debug\n    self.installConda()\n    self.commandGenerator = CommandGenerator(self.settingsManager)\n    self.dependencyManager = DependencyManager(self.commandGenerator)\n    self.commandExecutor = CommandExecutor(self.wetlandsInstancePath / \"command_executions\" if debug else None)\n</code></pre>"},{"location":"reference/wetlands/environment_manager/#wetlands.environment_manager.EnvironmentManager.installConda","title":"<code>installConda()</code>","text":"<p>Install Pixi or Micromamba (depending on settingsManager.usePixi)</p> Source code in <code>wetlands/environment_manager.py</code> <pre><code>def installConda(self):\n    \"\"\"Install Pixi or Micromamba (depending on settingsManager.usePixi)\"\"\"\n\n    condaPath, condaBinPath = self.settingsManager.getCondaPaths()\n    if (condaPath / condaBinPath).exists():\n        return []\n\n    condaPath.mkdir(exist_ok=True, parents=True)\n\n    if self.settingsManager.usePixi:\n        installPixi(condaPath, proxies=self.settingsManager.proxies)\n    else:\n        installMicromamba(condaPath, proxies=self.settingsManager.proxies)\n    return\n</code></pre>"},{"location":"reference/wetlands/environment_manager/#wetlands.environment_manager.EnvironmentManager.setCondaPath","title":"<code>setCondaPath(condaPath, usePixi=True)</code>","text":"<p>Updates the micromamba path and loads proxy settings if exists.</p> <p>Parameters:</p> Name Type Description Default <code>condaPath</code> <code>str | Path</code> <p>New path to micromamba binary.</p> required <code>usePixi</code> <code>bool</code> <p>Whether to use Pixi or Micromamba</p> <code>True</code> Side Effects <p>Updates self.settingsManager.condaBinConfig, and self.settingsManager.proxies from the .mambarc file.</p> Source code in <code>wetlands/environment_manager.py</code> <pre><code>def setCondaPath(self, condaPath: str | Path, usePixi: bool = True) -&gt; None:\n    \"\"\"Updates the micromamba path and loads proxy settings if exists.\n\n    Args:\n            condaPath: New path to micromamba binary.\n            usePixi: Whether to use Pixi or Micromamba\n\n    Side Effects:\n            Updates self.settingsManager.condaBinConfig, and self.settingsManager.proxies from the .mambarc file.\n    \"\"\"\n    self.settingsManager.setCondaPath(condaPath, usePixi)\n</code></pre>"},{"location":"reference/wetlands/environment_manager/#wetlands.environment_manager.EnvironmentManager.setProxies","title":"<code>setProxies(proxies)</code>","text":"<p>Configures proxy settings for Conda operations.</p> <p>Parameters:</p> Name Type Description Default <code>proxies</code> <code>dict[str, str]</code> <p>Proxy configuration dictionary (e.g., {\"http\": \"...\", \"https\": \"...\"}).</p> required Side Effects <p>Updates .mambarc configuration file with proxy settings.</p> Source code in <code>wetlands/environment_manager.py</code> <pre><code>def setProxies(self, proxies: dict[str, str]) -&gt; None:\n    \"\"\"Configures proxy settings for Conda operations.\n\n    Args:\n            proxies: Proxy configuration dictionary (e.g., {\"http\": \"...\", \"https\": \"...\"}).\n\n    Side Effects:\n            Updates .mambarc configuration file with proxy settings.\n    \"\"\"\n    self.settingsManager.setProxies(proxies)\n</code></pre>"},{"location":"reference/wetlands/environment_manager/#wetlands.environment_manager.EnvironmentManager.getInstalledPackages","title":"<code>getInstalledPackages(environment)</code>","text":"<p>Get the list of the packages installed in the environment</p> <p>Parameters:</p> Name Type Description Default <code>environment</code> <code>Environment</code> <p>The environment name.</p> required <p>Returns:</p> Type Description <code>list[dict[str, str]]</code> <p>A list of dict containing the installed packages [{\"kind\":\"conda|pypi\", \"name\": \"numpy\", \"version\", \"2.1.3\"}, ...].</p> Source code in <code>wetlands/environment_manager.py</code> <pre><code>def getInstalledPackages(self, environment: Environment) -&gt; list[dict[str, str]]:\n    \"\"\"Get the list of the packages installed in the environment\n\n    Args:\n            environment: The environment name.\n\n    Returns:\n            A list of dict containing the installed packages [{\"kind\":\"conda|pypi\", \"name\": \"numpy\", \"version\", \"2.1.3\"}, ...].\n    \"\"\"\n    if self.settingsManager.usePixi:\n        commands = self.commandGenerator.getActivateCondaCommands()\n        commands += [f'{self.settingsManager.condaBin} list --json --manifest-path \"{environment.path}\"']\n        return self.commandExecutor.executeCommandAndGetJsonOutput(commands, log=False)\n    else:\n        commands = self.commandGenerator.getActivateEnvironmentCommands(environment) + [\n            f\"{self.settingsManager.condaBin} list --json\",\n        ]\n        packages = self.commandExecutor.executeCommandAndGetJsonOutput(commands, log=False)\n        for package in packages:\n            package[\"kind\"] = \"conda\"\n\n        commands = self.commandGenerator.getActivateEnvironmentCommands(environment) + [\n            f\"pip freeze --all\",\n        ]\n        output = self.commandExecutor.executeCommandsAndGetOutput(commands, log=False)\n        parsedOutput = [o.split(\"==\") for o in output if \"==\" in o]\n        packages += [{\"name\": name, \"version\": version, \"kind\": \"pypi\"} for name, version in parsedOutput]\n        return packages\n</code></pre>"},{"location":"reference/wetlands/environment_manager/#wetlands.environment_manager.EnvironmentManager.environmentExists","title":"<code>environmentExists(environmentPath)</code>","text":"<p>Checks if a Conda environment exists.</p> <p>Parameters:</p> Name Type Description Default <code>environmentPath</code> <code>Path</code> <p>Environment name to check.</p> required <p>Returns:</p> Type Description <code>bool</code> <p>True if environment exists, False otherwise.</p> Source code in <code>wetlands/environment_manager.py</code> <pre><code>def environmentExists(self, environmentPath: Path) -&gt; bool:\n    \"\"\"Checks if a Conda environment exists.\n\n    Args:\n            environmentPath: Environment name to check.\n\n    Returns:\n            True if environment exists, False otherwise.\n    \"\"\"\n    if self.settingsManager.usePixi:\n        condaMeta = environmentPath.parent / \".pixi\" / \"envs\" / \"default\" / \"conda-meta\"\n        return environmentPath.is_file() and condaMeta.is_dir()\n    else:\n        condaMeta = environmentPath / \"conda-meta\"\n        return condaMeta.is_dir()\n</code></pre>"},{"location":"reference/wetlands/environment_manager/#wetlands.environment_manager.EnvironmentManager.create","title":"<code>create(name, dependencies=None, additionalInstallCommands={}, useExisting=False)</code>","text":"<p>Creates a new Conda environment with specified dependencies or returns an existing one.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name for the new environment.</p> required <code>dependencies</code> <code>Union[Dependencies, None]</code> <p>Dependencies to install. Can be one of: - A Dependencies dict: dict(python=\"3.12.7\", conda=[\"numpy\"], pip=[\"requests\"]) - None (no dependencies to install)</p> <code>None</code> <code>additionalInstallCommands</code> <code>Commands</code> <p>Platform-specific commands during installation (e.g. {\"mac\": [\"cd ...\", \"wget https://...\", \"unzip ...\"], \"all\"=[], ...}).</p> <code>{}</code> <code>useExisting</code> <code>bool</code> <p>if True, search through existing environments and return the first one that satisfies the dependencies instead of creating a new one.</p> <code>False</code> <p>Returns:</p> Type Description <code>Environment</code> <p>The created or existing environment (ExternalEnvironment if created, or an existing environment if useExisting=True and match found).</p> Source code in <code>wetlands/environment_manager.py</code> <pre><code>def create(\n    self,\n    name: str,\n    dependencies: Union[Dependencies, None] = None,\n    additionalInstallCommands: Commands = {},\n    useExisting: bool = False,\n) -&gt; Environment:\n    \"\"\"Creates a new Conda environment with specified dependencies or returns an existing one.\n\n    Args:\n            name: Name for the new environment.\n            dependencies: Dependencies to install. Can be one of:\n                - A Dependencies dict: dict(python=\"3.12.7\", conda=[\"numpy\"], pip=[\"requests\"])\n                - None (no dependencies to install)\n            additionalInstallCommands: Platform-specific commands during installation (e.g. {\"mac\": [\"cd ...\", \"wget https://...\", \"unzip ...\"], \"all\"=[], ...}).\n            useExisting: if True, search through existing environments and return the first one that satisfies the dependencies instead of creating a new one.\n\n    Returns:\n            The created or existing environment (ExternalEnvironment if created, or an existing environment if useExisting=True and match found).\n    \"\"\"\n    if isinstance(name, Path):\n        raise Exception(\n            \"Environment name cannot be a Path, use EnvironmentManager.load() to load an existing environment.\"\n        )\n\n    if name in self.environments:\n        logger.debug(f\"Environment '{name}' already exists, returning existing instance.\")\n        return self.environments[name]\n\n    if dependencies is None:\n        dependencies = {}\n    elif not isinstance(dependencies, dict):\n        raise ValueError(f\"Unsupported dependencies type: {type(dependencies)}\")\n\n    self._addDebugpyInDependencies(dependencies)\n\n    # Try to find existing environment if useExisting=True\n    if useExisting:\n        envs = [self.mainEnvironment] + [env for env in self.environments.values() if env != self.mainEnvironment]\n        for env in envs:\n            try:\n                if self._environmentValidatesRequirements(env, dependencies):\n                    logger.debug(f\"Environment '{env.name}' satisfies dependencies for '{name}', returning it.\")\n                    return env\n            except Exception as e:\n                logger.debug(f\"Error checking environment '{env.name}': {e}\")\n                continue\n\n    # Create new environment\n    pythonVersion = dependencies.get(\"python\", \"\").replace(\"=\", \"\")\n    match = re.search(r\"(\\d+)\\.(\\d+)\", pythonVersion)\n    if match and (int(match.group(1)) &lt; 3 or int(match.group(2)) &lt; 9):\n        raise Exception(\"Python version must be greater than 3.8\")\n    pythonRequirement = \" python=\" + (pythonVersion if len(pythonVersion) &gt; 0 else platform.python_version())\n    createEnvCommands = self.commandGenerator.getActivateCondaCommands()\n    path = self.settingsManager.getEnvironmentPathFromName(name)\n    if self.settingsManager.usePixi:\n        manifestPath = path\n        if not manifestPath.exists():\n            platformArgs = f\"--platform win-64\" if platform.system() == \"Windows\" else \"\"\n            createEnvCommands += [\n                f'{self.settingsManager.condaBin} init --no-progress {platformArgs} \"{manifestPath.parent}\"'\n            ]\n        createEnvCommands += [\n            f'{self.settingsManager.condaBin} add --no-progress --manifest-path \"{manifestPath}\" {pythonRequirement}'\n        ]\n    else:\n        createEnvCommands += [f\"{self.settingsManager.condaBinConfig} create -n {name}{pythonRequirement} -y\"]\n    environment = ExternalEnvironment(name, path, self)\n    self.environments[name] = environment\n    createEnvCommands += self.dependencyManager.getInstallDependenciesCommands(environment, dependencies)\n    createEnvCommands += self.commandGenerator.getCommandsForCurrentPlatform(additionalInstallCommands)\n    self.commandExecutor.executeCommandsAndGetOutput(createEnvCommands)\n    return self.environments[name]\n</code></pre>"},{"location":"reference/wetlands/environment_manager/#wetlands.environment_manager.EnvironmentManager.createFromConfig","title":"<code>createFromConfig(name, configPath, optionalDependencies=None, additionalInstallCommands={}, useExisting=False)</code>","text":"<p>Creates a new Conda environment from a config file (pixi.toml, pyproject.toml, environment.yml, or requirements.txt) or returns an existing one.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name for the new environment.</p> required <code>configPath</code> <code>str | Path</code> <p>Path to configuration file (pixi.toml, pyproject.toml, environment.yml, or requirements.txt).</p> required <code>optionalDependencies</code> <code>list[str] | None</code> <p>List of optional dependency groups to extract from pyproject.toml.</p> <code>None</code> <code>additionalInstallCommands</code> <code>Commands</code> <p>Platform-specific commands during installation.</p> <code>{}</code> <code>useExisting</code> <code>bool</code> <p>if True, search through existing environments and return the first one that satisfies the dependencies instead of creating a new one.</p> <code>False</code> <p>Returns:</p> Type Description <code>Environment</code> <p>The created or existing environment (ExternalEnvironment if created, or an existing environment if useExisting=True and match found).</p> Source code in <code>wetlands/environment_manager.py</code> <pre><code>def createFromConfig(\n    self,\n    name: str,\n    configPath: str | Path,\n    optionalDependencies: list[str] | None = None,\n    additionalInstallCommands: Commands = {},\n    useExisting: bool = False,\n) -&gt; Environment:\n    \"\"\"Creates a new Conda environment from a config file (pixi.toml, pyproject.toml, environment.yml, or requirements.txt) or returns an existing one.\n\n    Args:\n            name: Name for the new environment.\n            configPath: Path to configuration file (pixi.toml, pyproject.toml, environment.yml, or requirements.txt).\n            optionalDependencies: List of optional dependency groups to extract from pyproject.toml.\n            additionalInstallCommands: Platform-specific commands during installation.\n            useExisting: if True, search through existing environments and return the first one that satisfies the dependencies instead of creating a new one.\n\n    Returns:\n            The created or existing environment (ExternalEnvironment if created, or an existing environment if useExisting=True and match found).\n    \"\"\"\n\n    # Parse config file\n    dependencies = self._parseDependenciesFromConfig(\n        configPath, environmentName=name, optionalDependencies=optionalDependencies\n    )\n\n    # Use create() with parsed dependencies\n    return self.create(name, dependencies, additionalInstallCommands, useExisting)\n</code></pre>"},{"location":"reference/wetlands/environment_manager/#wetlands.environment_manager.EnvironmentManager.load","title":"<code>load(name, environmentPath)</code>","text":"<p>Load an existing Conda environment from disk.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name for the environment instance.</p> required <code>environmentPath</code> <code>Path</code> <p>Path to an existing Conda environment, or the folder containing the pixi.toml/pyproject.toml when using Pixi.</p> required <p>Returns:</p> Type Description <code>Environment</code> <p>The loaded environment (ExternalEnvironment if using Pixi or micromamba with a path, InternalEnvironment otherwise).</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the environment does not exist.</p> Source code in <code>wetlands/environment_manager.py</code> <pre><code>def load(\n    self,\n    name: str,\n    environmentPath: Path,\n) -&gt; Environment:\n    \"\"\"Load an existing Conda environment from disk.\n\n    Args:\n            name: Name for the environment instance.\n            environmentPath: Path to an existing Conda environment, or the folder containing the pixi.toml/pyproject.toml when using Pixi.\n\n    Returns:\n            The loaded environment (ExternalEnvironment if using Pixi or micromamba with a path, InternalEnvironment otherwise).\n\n    Raises:\n            Exception: If the environment does not exist.\n    \"\"\"\n    environmentPath = environmentPath.resolve()\n\n    if not self.environmentExists(environmentPath):\n        raise Exception(f\"The environment {environmentPath} was not found.\")\n\n    if name not in self.environments:\n        self.environments[name] = ExternalEnvironment(name, environmentPath, self)\n    return self.environments[name]\n</code></pre>"},{"location":"reference/wetlands/environment_manager/#wetlands.environment_manager.EnvironmentManager.install","title":"<code>install(environment, dependencies, additionalInstallCommands={})</code>","text":"<p>Installs dependencies. See <code>EnvironmentManager.create</code> for more details on the <code>dependencies</code> and <code>additionalInstallCommands</code> parameters.</p> <p>Parameters:</p> Name Type Description Default <code>environmentName</code> <p>The environment to install dependencies.</p> required <code>dependencies</code> <code>Dependencies</code> <p>Dependencies to install.</p> required <code>additionalInstallCommands</code> <code>Commands</code> <p>Platform-specific commands during installation.</p> <code>{}</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>Output lines of the installation commands.</p> Source code in <code>wetlands/environment_manager.py</code> <pre><code>def install(\n    self, environment: Environment, dependencies: Dependencies, additionalInstallCommands: Commands = {}\n) -&gt; list[str]:\n    \"\"\"Installs dependencies.\n    See [`EnvironmentManager.create`][wetlands.environment_manager.EnvironmentManager.create] for more details on the ``dependencies`` and ``additionalInstallCommands`` parameters.\n\n    Args:\n            environmentName: The environment to install dependencies.\n            dependencies: Dependencies to install.\n            additionalInstallCommands: Platform-specific commands during installation.\n\n    Returns:\n            Output lines of the installation commands.\n    \"\"\"\n    if environment == self.mainEnvironment and self.settingsManager.usePixi:\n        raise Exception(\"Cannot install packages in an InternalEnvironment when using Pixi.\")\n    if environment == self.mainEnvironment and environment.path is None:\n        raise Exception(\"Cannot install packages in an InternalEnvironment with no conda path.\")\n\n    installCommands = self.dependencyManager.getInstallDependenciesCommands(environment, dependencies)\n    installCommands += self.commandGenerator.getCommandsForCurrentPlatform(additionalInstallCommands)\n    return self.commandExecutor.executeCommandsAndGetOutput(installCommands)\n</code></pre>"},{"location":"reference/wetlands/environment_manager/#wetlands.environment_manager.EnvironmentManager.executeCommands","title":"<code>executeCommands(environment, commands, additionalActivateCommands={}, popenKwargs={}, wait=False)</code>","text":"<p>Executes the given commands in the given environment.</p> <p>Parameters:</p> Name Type Description Default <code>environment</code> <code>Environment</code> <p>The environment in which to execute commands.</p> required <code>commands</code> <code>Commands</code> <p>The commands to execute in the environment.</p> required <code>additionalActivateCommands</code> <code>Commands</code> <p>Platform-specific activation commands.</p> <code>{}</code> <code>popenKwargs</code> <code>dict[str, Any]</code> <p>Keyword arguments for subprocess.Popen() (see Popen documentation). Defaults are: dict(stdout=subprocess.PIPE, stderr=subprocess.STDOUT, stdin=subprocess.DEVNULL, encoding=\"utf-8\", errors=\"replace\", bufsize=1).</p> <code>{}</code> <p>Returns:</p> Type Description <code>Popen</code> <p>The launched process.</p> Source code in <code>wetlands/environment_manager.py</code> <pre><code>def executeCommands(\n    self,\n    environment: Environment,\n    commands: Commands,\n    additionalActivateCommands: Commands = {},\n    popenKwargs: dict[str, Any] = {},\n    wait: bool = False,\n) -&gt; subprocess.Popen:\n    \"\"\"Executes the given commands in the given environment.\n\n    Args:\n            environment: The environment in which to execute commands.\n            commands: The commands to execute in the environment.\n            additionalActivateCommands: Platform-specific activation commands.\n            popenKwargs: Keyword arguments for subprocess.Popen() (see [Popen documentation](https://docs.python.org/3/library/subprocess.html#popen-constructor)). Defaults are: dict(stdout=subprocess.PIPE, stderr=subprocess.STDOUT, stdin=subprocess.DEVNULL, encoding=\"utf-8\", errors=\"replace\", bufsize=1).\n\n    Returns:\n            The launched process.\n    \"\"\"\n    activateCommands = self.commandGenerator.getActivateEnvironmentCommands(environment, additionalActivateCommands)\n    platformCommands = self.commandGenerator.getCommandsForCurrentPlatform(commands)\n    return self.commandExecutor.executeCommands(\n        activateCommands + platformCommands, popenKwargs=popenKwargs, wait=wait\n    )\n</code></pre>"},{"location":"reference/wetlands/environment_manager/#wetlands.environment_manager.EnvironmentManager.registerEnvironment","title":"<code>registerEnvironment(environment, debugPort, moduleExecutorPath)</code>","text":"<p>Register the environment (save its debug port to <code>wetlandsInstancePath / debug_ports.json</code>) so that it can be debugged later.</p> <p>Parameters:</p> Name Type Description Default <code>environment</code> <code>ExternalEnvironment</code> <p>The external environment object to register</p> required <code>debugPort</code> <code>int</code> <p>The debug port to save</p> required Source code in <code>wetlands/environment_manager.py</code> <pre><code>def registerEnvironment(self, environment: ExternalEnvironment, debugPort: int, moduleExecutorPath: Path) -&gt; None:\n    \"\"\"\n    Register the environment (save its debug port to `wetlandsInstancePath / debug_ports.json`) so that it can be debugged later.\n\n    Args:\n            environment: The external environment object to register\n            debugPort: The debug port to save\n    \"\"\"\n    if environment.process is None:\n        return\n    wetlands_debug_ports_path = self.wetlandsInstancePath / \"debug_ports.json\"\n    wetlands_debug_ports_path.parent.mkdir(exist_ok=True, parents=True)\n    wetlands_debug_ports = {}\n    try:\n        if wetlands_debug_ports_path.exists():\n            with open(wetlands_debug_ports_path, \"r\") as f:\n                wetlands_debug_ports = json.load(f)\n        wetlands_debug_ports[environment.name] = dict(\n            debugPort=debugPort, moduleExecutorPath=moduleExecutorPath.as_posix()\n        )\n        with open(wetlands_debug_ports_path, \"w\") as f:\n            json.dump(wetlands_debug_ports, f)\n    except Exception as e:\n        e.add_note(f\"Error while updating the debug ports file {wetlands_debug_ports_path}.\")\n        raise e\n    return\n</code></pre>"},{"location":"reference/wetlands/external_environment/","title":"External environment","text":"<p>Functions:</p> Name Description <code>synchronized</code> <p>Decorator to wrap a method call with self._lock.</p>"},{"location":"reference/wetlands/external_environment/#wetlands.external_environment.ExternalEnvironment","title":"<code>ExternalEnvironment</code>","text":"<p>               Bases: <code>Environment</code></p> <p>Methods:</p> Name Description <code>logOutput</code> <p>Logs output from the subprocess.</p> <code>launch</code> <p>Launches a server listening for orders in the environment.</p> <code>execute</code> <p>Executes a function in the given module and return the result.</p> <code>runScript</code> <p>Runs a Python script remotely using runpy.run_path(), simulating</p> <code>launched</code> <p>Return true if the environment server process is launched and the connection is open.</p> <code>delete</code> <p>Deletes this external environment and cleans up associated resources.</p> <code>update</code> <p>Updates this external environment by deleting it and recreating it with new dependencies.</p> Source code in <code>wetlands/external_environment.py</code> <pre><code>class ExternalEnvironment(Environment):\n    port: int | None = None\n    process: subprocess.Popen | None = None\n    connection: Connection | None = None\n\n    def __init__(self, name: str, path: Path, environmentManager: \"EnvironmentManager\") -&gt; None:\n        super().__init__(name, path, environmentManager)\n        self._lock = threading.RLock()\n        self._logThread: threading.Thread | None = None\n        self.loggingQueue = queue.Queue()\n\n    def logOutput(self) -&gt; None:\n        \"\"\"Logs output from the subprocess.\"\"\"\n        if self.process is None or self.process.stdout is None or self.process.stdout.readline is None:\n            return\n        try:\n            for line in iter(self.process.stdout.readline, \"\"):  # Use iter to avoid buffering issues:\n                # iter(callable, sentinel) repeatedly calls callable (process.stdout.readline) until it returns the sentinel value (\"\", an empty string).\n                # Since readline() is called directly in each iteration, it immediately processes available output instead of accumulating it in a buffer.\n                # This effectively forces line-by-line reading in real-time rather than waiting for the subprocess to fill its buffer.\n                logger.info(line.strip())\n                self.loggingQueue.put(line.strip())\n        except Exception as e:\n            logger.error(f\"Exception in logging thread: {e}\")\n            self.loggingQueue.put(f\"Exception in logging thread: {e}\")\n        finally:\n            self.loggingQueue.put(None)\n        return\n\n    @synchronized\n    def launch(self, additionalActivateCommands: Commands = {}, logOutputInThread: bool = True) -&gt; None:\n        \"\"\"Launches a server listening for orders in the environment.\n\n        Args:\n                additionalActivateCommands: Platform-specific activation commands.\n                logOutputInThread: Logs the process output in a separate thread.\n        \"\"\"\n\n        if self.launched():\n            return\n\n        moduleExecutorFile = \"module_executor.py\"\n        moduleExecutorPath = Path(__file__).parent.resolve() / \"_internal\" / moduleExecutorFile\n\n        debugArgs = f\" --debugPort 0\" if self.environmentManager.debug else \"\"\n        commands = [\n            f'python -u \"{moduleExecutorPath}\" {self.name} --wetlandsInstancePath {self.environmentManager.wetlandsInstancePath.resolve()}{debugArgs}'\n        ]\n\n        self.process = self.executeCommands(commands, additionalActivateCommands)\n\n        if self.process.stdout is not None:\n            try:\n                for line in self.process.stdout:\n                    logger.info(line.strip())\n                    if self.environmentManager.debug:\n                        if line.strip().startswith(\"Listening debug port \"):\n                            debugPort = int(line.strip().replace(\"Listening debug port \", \"\"))\n                            self.environmentManager.registerEnvironment(self, debugPort, moduleExecutorPath)\n                    if line.strip().startswith(\"Listening port \"):\n                        self.port = int(line.strip().replace(\"Listening port \", \"\"))\n                        break\n            except Exception as e:\n                self.process.stdout.close()\n                raise e\n\n        if self.process.poll() is not None:\n            if self.process.stdout is not None:\n                self.process.stdout.close()\n            raise Exception(f\"Process exited with return code {self.process.returncode}.\")\n        if self.port is None:\n            raise Exception(f\"Could not find the server port.\")\n        self.connection = Client((\"localhost\", self.port))\n\n        if logOutputInThread:\n            self._logThread = threading.Thread(target=self.logOutput, daemon=True)\n            self._logThread.start()\n\n    def _sendAndWait(self, payload: dict) -&gt; Any:\n        \"\"\"Send a payload to the remote environment and wait for its response.\"\"\"\n        connection = self.connection\n        if connection is None or connection.closed:\n            raise ExecutionException(\"Connection not ready.\")\n\n        try:\n            connection.send(payload)\n            while message := connection.recv():\n                action = message.get(\"action\")\n                if action == \"execution finished\":\n                    logger.info(f\"{payload.get('action')} finished\")\n                    return message.get(\"result\")\n                elif action == \"error\":\n                    logger.error(message[\"exception\"])\n                    logger.error(\"Traceback:\")\n                    for line in message[\"traceback\"]:\n                        logger.error(line)\n                    raise ExecutionException(message)\n                else:\n                    logger.warning(f\"Got an unexpected message: {message}\")\n\n        except EOFError:\n            logger.info(\"Connection closed gracefully by the peer.\")\n        except BrokenPipeError as e:\n            logger.error(f\"Broken pipe. The peer process might have terminated. Exception: {e}.\")\n        except OSError as e:\n            if e.errno == 9:  # Bad file descriptor\n                logger.error(\"Connection closed abruptly by the peer.\")\n            else:\n                logger.error(f\"Unexpected OSError: {e}\")\n                raise e\n        return None\n\n    @synchronized\n    def execute(self, modulePath: str | Path, function: str, args: tuple = (), kwargs: dict[str, Any] = {}) -&gt; Any:\n        \"\"\"Executes a function in the given module and return the result.\n        Warning: all arguments (args and kwargs) must be picklable (since they will be send with [multiprocessing.connection.Connection.send](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.connection.Connection.send))!\n\n        Args:\n                modulePath: the path to the module to import\n                function: the name of the function to execute\n                args: the argument list for the function\n                kwargs: the keyword arguments for the function\n\n        Returns:\n                The result of the function if it is defined and the connection is opened ; None otherwise.\n        Raises:\n            OSError when raised by the communication.\n        \"\"\"\n        payload = dict(\n            action=\"execute\",\n            modulePath=str(modulePath),\n            function=function,\n            args=args,\n            kwargs=kwargs,\n        )\n        return self._sendAndWait(payload)\n\n    @synchronized\n    def runScript(self, scriptPath: str | Path, args: tuple = (), run_name: str = \"__main__\") -&gt; Any:\n        \"\"\"\n        Runs a Python script remotely using runpy.run_path(), simulating\n        'python script.py arg1 arg2 ...'\n\n        Args:\n            scriptPath: Path to the script to execute.\n            args: List of arguments to pass (becomes sys.argv[1:] remotely).\n            run_name: Value for runpy.run_path(run_name=...); defaults to \"__main__\".\n\n        Returns:\n            The resulting globals dict from the executed script, or None on failure.\n        \"\"\"\n        payload = dict(\n            action=\"run\",\n            scriptPath=str(scriptPath),\n            args=args,\n            run_name=run_name,\n        )\n        return self._sendAndWait(payload)\n\n    @synchronized\n    def launched(self) -&gt; bool:\n        \"\"\"Return true if the environment server process is launched and the connection is open.\"\"\"\n        return (\n            self.process is not None\n            and self.process.poll() is None\n            and self.connection is not None\n            and not self.connection.closed\n            and self.connection.writable\n            and self.connection.readable\n        )\n\n    @synchronized\n    def _exit(self) -&gt; None:\n        \"\"\"Close the connection to the environment and kills the process.\"\"\"\n        if self.connection is not None:\n            try:\n                self.connection.send(dict(action=\"exit\"))\n            except OSError as e:\n                if e.args[0] == \"handle is closed\":\n                    pass\n            self.connection.close()\n\n        if self.process and self.process.stdout:\n            self.process.stdout.close()\n\n        if self._logThread:\n            self._logThread.join(timeout=2)\n\n        CommandExecutor.killProcess(self.process)\n\n    @synchronized\n    def delete(self) -&gt; None:\n        \"\"\"Deletes this external environment and cleans up associated resources.\n\n        Raises:\n                Exception: If the environment does not exist.\n\n        Side Effects:\n                - If the environment is running, calls _exit() on it\n                - Removes environment from environmentManager.environments dict\n                - Deletes the environment directory using appropriate conda manager\n        \"\"\"\n        if self.path is None:\n            raise Exception(\"Cannot delete an environment with no path.\")\n\n        if not self.environmentManager.environmentExists(self.path):\n            raise Exception(f\"The environment {self.name} does not exist.\")\n\n        # Exit the environment if it's running\n        if self.launched():\n            self._exit()\n\n        # Generate delete commands based on conda manager type\n        if self.environmentManager.settingsManager.usePixi:\n            send2trash(self.path.parent)\n        else:\n            send2trash(self.path)\n\n        # Remove from environments dict\n        if self.name in self.environmentManager.environments:\n            del self.environmentManager.environments[self.name]\n\n    @synchronized\n    def update(\n        self,\n        dependencies: Union[Dependencies, None] = None,\n        additionalInstallCommands: Commands = {},\n        useExisting: bool = False,\n    ) -&gt; \"Environment\":\n        \"\"\"Updates this external environment by deleting it and recreating it with new dependencies.\n\n        Args:\n                dependencies: New dependencies to install. Can be one of:\n                    - A Dependencies dict: dict(python=\"3.12.7\", conda=[\"numpy\"], pip=[\"requests\"])\n                    - None (no dependencies to install)\n                additionalInstallCommands: Platform-specific commands during installation.\n                useExisting: use existing environment if it exists instead of recreating it.\n\n        Returns:\n                The recreated environment.\n\n        Raises:\n                Exception: If the environment does not exist.\n\n        Side Effects:\n                - Deletes the existing environment\n                - Creates a new environment with the same name but new dependencies\n        \"\"\"\n        if not self.path:\n            raise Exception(\"Cannot update an environment with no path.\")\n\n        if not self.environmentManager.environmentExists(self.path):\n            raise Exception(f\"The environment {self.name} does not exist.\")\n\n        # Delete the existing environment\n        self.delete()\n\n        # Use create for direct Dependencies dict\n        return self.environmentManager.create(\n            str(self.name),\n            dependencies=dependencies,\n            additionalInstallCommands=additionalInstallCommands,\n            useExisting=useExisting,\n        )\n</code></pre>"},{"location":"reference/wetlands/external_environment/#wetlands.external_environment.ExternalEnvironment.logOutput","title":"<code>logOutput()</code>","text":"<p>Logs output from the subprocess.</p> Source code in <code>wetlands/external_environment.py</code> <pre><code>def logOutput(self) -&gt; None:\n    \"\"\"Logs output from the subprocess.\"\"\"\n    if self.process is None or self.process.stdout is None or self.process.stdout.readline is None:\n        return\n    try:\n        for line in iter(self.process.stdout.readline, \"\"):  # Use iter to avoid buffering issues:\n            # iter(callable, sentinel) repeatedly calls callable (process.stdout.readline) until it returns the sentinel value (\"\", an empty string).\n            # Since readline() is called directly in each iteration, it immediately processes available output instead of accumulating it in a buffer.\n            # This effectively forces line-by-line reading in real-time rather than waiting for the subprocess to fill its buffer.\n            logger.info(line.strip())\n            self.loggingQueue.put(line.strip())\n    except Exception as e:\n        logger.error(f\"Exception in logging thread: {e}\")\n        self.loggingQueue.put(f\"Exception in logging thread: {e}\")\n    finally:\n        self.loggingQueue.put(None)\n    return\n</code></pre>"},{"location":"reference/wetlands/external_environment/#wetlands.external_environment.ExternalEnvironment.launch","title":"<code>launch(additionalActivateCommands={}, logOutputInThread=True)</code>","text":"<p>Launches a server listening for orders in the environment.</p> <p>Parameters:</p> Name Type Description Default <code>additionalActivateCommands</code> <code>Commands</code> <p>Platform-specific activation commands.</p> <code>{}</code> <code>logOutputInThread</code> <code>bool</code> <p>Logs the process output in a separate thread.</p> <code>True</code> Source code in <code>wetlands/external_environment.py</code> <pre><code>@synchronized\ndef launch(self, additionalActivateCommands: Commands = {}, logOutputInThread: bool = True) -&gt; None:\n    \"\"\"Launches a server listening for orders in the environment.\n\n    Args:\n            additionalActivateCommands: Platform-specific activation commands.\n            logOutputInThread: Logs the process output in a separate thread.\n    \"\"\"\n\n    if self.launched():\n        return\n\n    moduleExecutorFile = \"module_executor.py\"\n    moduleExecutorPath = Path(__file__).parent.resolve() / \"_internal\" / moduleExecutorFile\n\n    debugArgs = f\" --debugPort 0\" if self.environmentManager.debug else \"\"\n    commands = [\n        f'python -u \"{moduleExecutorPath}\" {self.name} --wetlandsInstancePath {self.environmentManager.wetlandsInstancePath.resolve()}{debugArgs}'\n    ]\n\n    self.process = self.executeCommands(commands, additionalActivateCommands)\n\n    if self.process.stdout is not None:\n        try:\n            for line in self.process.stdout:\n                logger.info(line.strip())\n                if self.environmentManager.debug:\n                    if line.strip().startswith(\"Listening debug port \"):\n                        debugPort = int(line.strip().replace(\"Listening debug port \", \"\"))\n                        self.environmentManager.registerEnvironment(self, debugPort, moduleExecutorPath)\n                if line.strip().startswith(\"Listening port \"):\n                    self.port = int(line.strip().replace(\"Listening port \", \"\"))\n                    break\n        except Exception as e:\n            self.process.stdout.close()\n            raise e\n\n    if self.process.poll() is not None:\n        if self.process.stdout is not None:\n            self.process.stdout.close()\n        raise Exception(f\"Process exited with return code {self.process.returncode}.\")\n    if self.port is None:\n        raise Exception(f\"Could not find the server port.\")\n    self.connection = Client((\"localhost\", self.port))\n\n    if logOutputInThread:\n        self._logThread = threading.Thread(target=self.logOutput, daemon=True)\n        self._logThread.start()\n</code></pre>"},{"location":"reference/wetlands/external_environment/#wetlands.external_environment.ExternalEnvironment.execute","title":"<code>execute(modulePath, function, args=(), kwargs={})</code>","text":"<p>Executes a function in the given module and return the result. Warning: all arguments (args and kwargs) must be picklable (since they will be send with multiprocessing.connection.Connection.send)!</p> <p>Parameters:</p> Name Type Description Default <code>modulePath</code> <code>str | Path</code> <p>the path to the module to import</p> required <code>function</code> <code>str</code> <p>the name of the function to execute</p> required <code>args</code> <code>tuple</code> <p>the argument list for the function</p> <code>()</code> <code>kwargs</code> <code>dict[str, Any]</code> <p>the keyword arguments for the function</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>The result of the function if it is defined and the connection is opened ; None otherwise.</p> <p>Raises:     OSError when raised by the communication.</p> Source code in <code>wetlands/external_environment.py</code> <pre><code>@synchronized\ndef execute(self, modulePath: str | Path, function: str, args: tuple = (), kwargs: dict[str, Any] = {}) -&gt; Any:\n    \"\"\"Executes a function in the given module and return the result.\n    Warning: all arguments (args and kwargs) must be picklable (since they will be send with [multiprocessing.connection.Connection.send](https://docs.python.org/3/library/multiprocessing.html#multiprocessing.connection.Connection.send))!\n\n    Args:\n            modulePath: the path to the module to import\n            function: the name of the function to execute\n            args: the argument list for the function\n            kwargs: the keyword arguments for the function\n\n    Returns:\n            The result of the function if it is defined and the connection is opened ; None otherwise.\n    Raises:\n        OSError when raised by the communication.\n    \"\"\"\n    payload = dict(\n        action=\"execute\",\n        modulePath=str(modulePath),\n        function=function,\n        args=args,\n        kwargs=kwargs,\n    )\n    return self._sendAndWait(payload)\n</code></pre>"},{"location":"reference/wetlands/external_environment/#wetlands.external_environment.ExternalEnvironment.runScript","title":"<code>runScript(scriptPath, args=(), run_name='__main__')</code>","text":"<p>Runs a Python script remotely using runpy.run_path(), simulating 'python script.py arg1 arg2 ...'</p> <p>Parameters:</p> Name Type Description Default <code>scriptPath</code> <code>str | Path</code> <p>Path to the script to execute.</p> required <code>args</code> <code>tuple</code> <p>List of arguments to pass (becomes sys.argv[1:] remotely).</p> <code>()</code> <code>run_name</code> <code>str</code> <p>Value for runpy.run_path(run_name=...); defaults to \"main\".</p> <code>'__main__'</code> <p>Returns:</p> Type Description <code>Any</code> <p>The resulting globals dict from the executed script, or None on failure.</p> Source code in <code>wetlands/external_environment.py</code> <pre><code>@synchronized\ndef runScript(self, scriptPath: str | Path, args: tuple = (), run_name: str = \"__main__\") -&gt; Any:\n    \"\"\"\n    Runs a Python script remotely using runpy.run_path(), simulating\n    'python script.py arg1 arg2 ...'\n\n    Args:\n        scriptPath: Path to the script to execute.\n        args: List of arguments to pass (becomes sys.argv[1:] remotely).\n        run_name: Value for runpy.run_path(run_name=...); defaults to \"__main__\".\n\n    Returns:\n        The resulting globals dict from the executed script, or None on failure.\n    \"\"\"\n    payload = dict(\n        action=\"run\",\n        scriptPath=str(scriptPath),\n        args=args,\n        run_name=run_name,\n    )\n    return self._sendAndWait(payload)\n</code></pre>"},{"location":"reference/wetlands/external_environment/#wetlands.external_environment.ExternalEnvironment.launched","title":"<code>launched()</code>","text":"<p>Return true if the environment server process is launched and the connection is open.</p> Source code in <code>wetlands/external_environment.py</code> <pre><code>@synchronized\ndef launched(self) -&gt; bool:\n    \"\"\"Return true if the environment server process is launched and the connection is open.\"\"\"\n    return (\n        self.process is not None\n        and self.process.poll() is None\n        and self.connection is not None\n        and not self.connection.closed\n        and self.connection.writable\n        and self.connection.readable\n    )\n</code></pre>"},{"location":"reference/wetlands/external_environment/#wetlands.external_environment.ExternalEnvironment.delete","title":"<code>delete()</code>","text":"<p>Deletes this external environment and cleans up associated resources.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the environment does not exist.</p> Side Effects <ul> <li>If the environment is running, calls _exit() on it</li> <li>Removes environment from environmentManager.environments dict</li> <li>Deletes the environment directory using appropriate conda manager</li> </ul> Source code in <code>wetlands/external_environment.py</code> <pre><code>@synchronized\ndef delete(self) -&gt; None:\n    \"\"\"Deletes this external environment and cleans up associated resources.\n\n    Raises:\n            Exception: If the environment does not exist.\n\n    Side Effects:\n            - If the environment is running, calls _exit() on it\n            - Removes environment from environmentManager.environments dict\n            - Deletes the environment directory using appropriate conda manager\n    \"\"\"\n    if self.path is None:\n        raise Exception(\"Cannot delete an environment with no path.\")\n\n    if not self.environmentManager.environmentExists(self.path):\n        raise Exception(f\"The environment {self.name} does not exist.\")\n\n    # Exit the environment if it's running\n    if self.launched():\n        self._exit()\n\n    # Generate delete commands based on conda manager type\n    if self.environmentManager.settingsManager.usePixi:\n        send2trash(self.path.parent)\n    else:\n        send2trash(self.path)\n\n    # Remove from environments dict\n    if self.name in self.environmentManager.environments:\n        del self.environmentManager.environments[self.name]\n</code></pre>"},{"location":"reference/wetlands/external_environment/#wetlands.external_environment.ExternalEnvironment.update","title":"<code>update(dependencies=None, additionalInstallCommands={}, useExisting=False)</code>","text":"<p>Updates this external environment by deleting it and recreating it with new dependencies.</p> <p>Parameters:</p> Name Type Description Default <code>dependencies</code> <code>Union[Dependencies, None]</code> <p>New dependencies to install. Can be one of: - A Dependencies dict: dict(python=\"3.12.7\", conda=[\"numpy\"], pip=[\"requests\"]) - None (no dependencies to install)</p> <code>None</code> <code>additionalInstallCommands</code> <code>Commands</code> <p>Platform-specific commands during installation.</p> <code>{}</code> <code>useExisting</code> <code>bool</code> <p>use existing environment if it exists instead of recreating it.</p> <code>False</code> <p>Returns:</p> Type Description <code>Environment</code> <p>The recreated environment.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If the environment does not exist.</p> Side Effects <ul> <li>Deletes the existing environment</li> <li>Creates a new environment with the same name but new dependencies</li> </ul> Source code in <code>wetlands/external_environment.py</code> <pre><code>@synchronized\ndef update(\n    self,\n    dependencies: Union[Dependencies, None] = None,\n    additionalInstallCommands: Commands = {},\n    useExisting: bool = False,\n) -&gt; \"Environment\":\n    \"\"\"Updates this external environment by deleting it and recreating it with new dependencies.\n\n    Args:\n            dependencies: New dependencies to install. Can be one of:\n                - A Dependencies dict: dict(python=\"3.12.7\", conda=[\"numpy\"], pip=[\"requests\"])\n                - None (no dependencies to install)\n            additionalInstallCommands: Platform-specific commands during installation.\n            useExisting: use existing environment if it exists instead of recreating it.\n\n    Returns:\n            The recreated environment.\n\n    Raises:\n            Exception: If the environment does not exist.\n\n    Side Effects:\n            - Deletes the existing environment\n            - Creates a new environment with the same name but new dependencies\n    \"\"\"\n    if not self.path:\n        raise Exception(\"Cannot update an environment with no path.\")\n\n    if not self.environmentManager.environmentExists(self.path):\n        raise Exception(f\"The environment {self.name} does not exist.\")\n\n    # Delete the existing environment\n    self.delete()\n\n    # Use create for direct Dependencies dict\n    return self.environmentManager.create(\n        str(self.name),\n        dependencies=dependencies,\n        additionalInstallCommands=additionalInstallCommands,\n        useExisting=useExisting,\n    )\n</code></pre>"},{"location":"reference/wetlands/external_environment/#wetlands.external_environment.synchronized","title":"<code>synchronized(method)</code>","text":"<p>Decorator to wrap a method call with self._lock.</p> Source code in <code>wetlands/external_environment.py</code> <pre><code>def synchronized(method):\n    \"\"\"Decorator to wrap a method call with self._lock.\"\"\"\n\n    @functools.wraps(method)\n    def wrapper(self, *args, **kwargs):\n        with self._lock:\n            return method(self, *args, **kwargs)\n\n    return wrapper\n</code></pre>"},{"location":"reference/wetlands/internal_environment/","title":"Internal environment","text":""},{"location":"reference/wetlands/internal_environment/#wetlands.internal_environment.InternalEnvironment","title":"<code>InternalEnvironment</code>","text":"<p>               Bases: <code>Environment</code></p> <p>Methods:</p> Name Description <code>__init__</code> <p>Use absolute path as name for micromamba to consider the activation from a folder path, not from a name</p> <code>execute</code> <p>Executes a function in the given module</p> <code>runScript</code> <p>Runs a Python script locally using runpy.run_path(), simulating</p> Source code in <code>wetlands/internal_environment.py</code> <pre><code>class InternalEnvironment(Environment):\n    def __init__(self, name: str, path: Path | None, environmentManager: \"EnvironmentManager\") -&gt; None:\n        \"\"\"Use absolute path as name for micromamba to consider the activation from a folder path, not from a name\"\"\"\n        super().__init__(name, path, environmentManager)\n\n    def execute(self, modulePath: str | Path, function: str, args: tuple = (), kwargs: dict[str, Any] = {}) -&gt; Any:\n        \"\"\"Executes a function in the given module\n\n        Args:\n                modulePath: the path to the module to import\n                function: the name of the function to execute\n                args: the argument list for the function\n                kwargs: the keyword arguments for the function\n\n        Returns:\n                The result of the function\n        \"\"\"\n        module = self._importModule(modulePath)\n        if not self._isModFunction(module, function):\n            raise Exception(f\"Module {modulePath} has no function {function}.\")\n        return getattr(module, function)(*args)\n\n    def runScript(self, scriptPath: str | Path, args: tuple = (), run_name: str = \"__main__\") -&gt; Any:\n        \"\"\"\n        Runs a Python script locally using runpy.run_path(), simulating\n        'python script.py arg1 arg2 ...'\n\n        Args:\n            scriptPath: Path to the script to execute.\n            args: List of arguments to pass (becomes sys.argv[1:] locally).\n            run_name: Value for runpy.run_path(run_name=...); defaults to \"__main__\".\n\n        Returns:\n            The resulting globals dict from the executed script, or None on failure.\n        \"\"\"\n        scriptPath = str(scriptPath)\n        sys.argv = [scriptPath] + list(args)\n        runpy.run_path(scriptPath, run_name=run_name)\n        return None\n</code></pre>"},{"location":"reference/wetlands/internal_environment/#wetlands.internal_environment.InternalEnvironment.__init__","title":"<code>__init__(name, path, environmentManager)</code>","text":"<p>Use absolute path as name for micromamba to consider the activation from a folder path, not from a name</p> Source code in <code>wetlands/internal_environment.py</code> <pre><code>def __init__(self, name: str, path: Path | None, environmentManager: \"EnvironmentManager\") -&gt; None:\n    \"\"\"Use absolute path as name for micromamba to consider the activation from a folder path, not from a name\"\"\"\n    super().__init__(name, path, environmentManager)\n</code></pre>"},{"location":"reference/wetlands/internal_environment/#wetlands.internal_environment.InternalEnvironment.execute","title":"<code>execute(modulePath, function, args=(), kwargs={})</code>","text":"<p>Executes a function in the given module</p> <p>Parameters:</p> Name Type Description Default <code>modulePath</code> <code>str | Path</code> <p>the path to the module to import</p> required <code>function</code> <code>str</code> <p>the name of the function to execute</p> required <code>args</code> <code>tuple</code> <p>the argument list for the function</p> <code>()</code> <code>kwargs</code> <code>dict[str, Any]</code> <p>the keyword arguments for the function</p> <code>{}</code> <p>Returns:</p> Type Description <code>Any</code> <p>The result of the function</p> Source code in <code>wetlands/internal_environment.py</code> <pre><code>def execute(self, modulePath: str | Path, function: str, args: tuple = (), kwargs: dict[str, Any] = {}) -&gt; Any:\n    \"\"\"Executes a function in the given module\n\n    Args:\n            modulePath: the path to the module to import\n            function: the name of the function to execute\n            args: the argument list for the function\n            kwargs: the keyword arguments for the function\n\n    Returns:\n            The result of the function\n    \"\"\"\n    module = self._importModule(modulePath)\n    if not self._isModFunction(module, function):\n        raise Exception(f\"Module {modulePath} has no function {function}.\")\n    return getattr(module, function)(*args)\n</code></pre>"},{"location":"reference/wetlands/internal_environment/#wetlands.internal_environment.InternalEnvironment.runScript","title":"<code>runScript(scriptPath, args=(), run_name='__main__')</code>","text":"<p>Runs a Python script locally using runpy.run_path(), simulating 'python script.py arg1 arg2 ...'</p> <p>Parameters:</p> Name Type Description Default <code>scriptPath</code> <code>str | Path</code> <p>Path to the script to execute.</p> required <code>args</code> <code>tuple</code> <p>List of arguments to pass (becomes sys.argv[1:] locally).</p> <code>()</code> <code>run_name</code> <code>str</code> <p>Value for runpy.run_path(run_name=...); defaults to \"main\".</p> <code>'__main__'</code> <p>Returns:</p> Type Description <code>Any</code> <p>The resulting globals dict from the executed script, or None on failure.</p> Source code in <code>wetlands/internal_environment.py</code> <pre><code>def runScript(self, scriptPath: str | Path, args: tuple = (), run_name: str = \"__main__\") -&gt; Any:\n    \"\"\"\n    Runs a Python script locally using runpy.run_path(), simulating\n    'python script.py arg1 arg2 ...'\n\n    Args:\n        scriptPath: Path to the script to execute.\n        args: List of arguments to pass (becomes sys.argv[1:] locally).\n        run_name: Value for runpy.run_path(run_name=...); defaults to \"__main__\".\n\n    Returns:\n        The resulting globals dict from the executed script, or None on failure.\n    \"\"\"\n    scriptPath = str(scriptPath)\n    sys.argv = [scriptPath] + list(args)\n    runpy.run_path(scriptPath, run_name=run_name)\n    return None\n</code></pre>"},{"location":"reference/wetlands/_internal/command_executor/","title":"Command executor","text":""},{"location":"reference/wetlands/_internal/command_executor/#wetlands._internal.command_executor.CommandExecutor","title":"<code>CommandExecutor</code>","text":"<p>Handles execution of shell commands with error checking and logging.</p> <p>Methods:</p> Name Description <code>__init__</code> <p>scriptsPath: Path where to create temporary script files for command execution (useful for debugging). If None, use the system default temp directory.</p> <code>killProcess</code> <p>Terminates the process and its children</p> <code>getOutput</code> <p>Captures and processes output from a subprocess.</p> <code>executeCommands</code> <p>Executes shell commands in a subprocess. Warning: does not wait for completion unless <code>wait</code> is True.</p> <code>executeCommandsAndGetOutput</code> <p>Executes commands and captures their output. See <code>CommandExecutor.executeCommands</code> for more details on the arguments.</p> <code>executeCommandAndGetJsonOutput</code> <p>Execute <code>CommandExecutor.executeCommandsAndGetOutput</code> and parse the json output.</p> Source code in <code>wetlands/_internal/command_executor.py</code> <pre><code>class CommandExecutor:\n    \"\"\"Handles execution of shell commands with error checking and logging.\"\"\"\n\n    def __init__(self, scriptsPath: Path | None = None) -&gt; None:\n        \"\"\"scriptsPath: Path where to create temporary script files for command execution (useful for debugging). If None, use the system default temp directory.\"\"\"\n        self.scriptsPath = scriptsPath\n\n    @staticmethod\n    def killProcess(process) -&gt; None:\n        \"\"\"Terminates the process and its children\"\"\"\n        if process is None:\n            return\n        parent = psutil.Process(process.pid)\n        for child in parent.children(recursive=True):  # Get all child processes\n            if child.is_running():\n                child.kill()\n        if parent.is_running():\n            parent.kill()\n\n    def _isWindows(self) -&gt; bool:\n        \"\"\"Checks if the current OS is Windows.\"\"\"\n        return platform.system() == \"Windows\"\n\n    def _insertCommandErrorChecks(self, commands: list[str]) -&gt; list[str]:\n        \"\"\"Inserts error checking commands after each shell command.\n        Note: could also use [`set -e`](https://stackoverflow.com/questions/3474526/stop-on-first-error),\n        and [`$ErrorActionPreference = \"Stop\"`](https://stackoverflow.com/questions/9948517/how-to-stop-a-powershell-script-on-the-first-error).\n\n        Args:\n                commands: List of original shell commands.\n\n        Returns:\n                Augmented command list with error checking logic.\n        \"\"\"\n        commandsWithChecks = []\n        errorMessage = \"Errors encountered during execution. Exited with status:\"\n        windowsChecks = [\"\", \"if (! $?) { exit 1 } \"]\n        posixChecks = [\n            \"\",\n            \"return_status=$?\",\n            \"if [ $return_status -ne 0 ]\",\n            \"then\",\n            f'    echo \"{errorMessage} $return_status\"',\n            \"    exit 1\",\n            \"fi\",\n            \"\",\n        ]\n        checks = windowsChecks if self._isWindows() else posixChecks\n        for command in commands:\n            commandsWithChecks.append(command)\n            commandsWithChecks += checks\n        return commandsWithChecks\n\n    def _commandsExcerpt(self, commands: list[str]) -&gt; str:\n        \"\"\"Returns the command list as a string but cap the length at 150 characters\n        (for example to be able to display it in a dialog window).\"\"\"\n        if commands is None or len(commands) == 0:\n            return \"\"\n        prefix: str = \"[...] \" if len(str(commands)) &gt; 150 else \"\"\n        return prefix + str(commands)[-150:]\n\n    def getOutput(\n        self,\n        process: subprocess.Popen,\n        commands: list[str],\n        log: bool = True,\n        strip: bool = True,\n    ) -&gt; list[str]:\n        \"\"\"Captures and processes output from a subprocess.\n\n        Args:\n                process: Subprocess to monitor.\n                commands: Commands that were executed (for error messages).\n                log: Whether to log output lines.\n                strip: Whether to strip whitespace from output lines.\n\n        Returns:\n                Output lines.\n\n        Raises:\n                Exception: If CondaSystemExit is detected or non-zero exit code.\n        \"\"\"\n        outputs = []\n        if process.stdout is not None:\n            for line in process.stdout:\n                if strip:\n                    line = line.strip()\n                if log:\n                    logger.info(line)\n                if \"CondaSystemExit\" in line:  # Sometime conda exists with a CondaSystemExit and a return code 0\n                    # we want to stop our script when this happens (and not run the later commands)\n                    self.killProcess(process)\n                    raise Exception(f'The execution of the commands \"{self._commandsExcerpt(commands)}\" failed.')\n                outputs.append(line)\n        process.wait()\n        if process.returncode != 0:\n            raise Exception(f'The execution of the commands \"{self._commandsExcerpt(commands)}\" failed.')\n        return outputs\n\n    def executeCommands(\n        self,\n        commands: list[str],\n        exitIfCommandError: bool = True,\n        popenKwargs: dict[str, Any] = {},\n        wait: bool = False,\n        removePythonEnvVars: bool = True,\n    ) -&gt; subprocess.Popen:\n        \"\"\"Executes shell commands in a subprocess. Warning: does not wait for completion unless ``wait`` is True.\n\n        Args:\n                commands: List of shell commands to execute.\n                exitIfCommandError: Whether to insert error checking after each command to make sure the whole command chain stops if an error occurs (otherwise the script will be executed entirely even when one command fails at the beginning).\n                popenKwargs: Keyword arguments for subprocess.Popen() (see [Popen documentation](https://docs.python.org/3/library/subprocess.html#popen-constructor)). Defaults are: dict(stdout=subprocess.PIPE, stderr=subprocess.STDOUT, stdin=subprocess.DEVNULL, encoding=\"utf-8\", errors=\"replace\", bufsize=1).\n                wait: Whether to wait for the process to complete before returning.\n                removePythonEnvVars: Whether to remove PYTHONEXECUTABLE, PYTHONHOME and PYTHONPATH from the environment variables to avoid interference with conda/pixi environment activation.\n\n        Returns:\n                Subprocess handle for the executed commands.\n        \"\"\"\n        import os\n\n        commandsString = \"\\n\\t\\t\".join(commands)\n        logger.debug(f\"Execute commands:\\n\\n\\t\\t{commandsString}\\n\")\n        with tempfile.NamedTemporaryFile(\n            dir=self.scriptsPath, suffix=\".ps1\" if self._isWindows() else \".sh\", mode=\"w\", delete=False\n        ) as tmp:\n            if exitIfCommandError:\n                commands = self._insertCommandErrorChecks(commands)\n            tmp.write(\"\\n\".join(commands))\n            tmp.flush()\n            tmp.close()\n            executeFile = (\n                [\n                    \"powershell\",\n                    \"-WindowStyle\",\n                    \"Hidden\",\n                    \"-NoProfile\",\n                    \"-ExecutionPolicy\",\n                    \"ByPass\",\n                    \"-File\",\n                    tmp.name,\n                ]\n                if self._isWindows()\n                else [\"/bin/bash\", tmp.name]\n            )\n            if not self._isWindows():\n                subprocess.run([\"chmod\", \"u+x\", tmp.name])\n            logger.debug(f\"Script file: {tmp.name}\")\n\n            if removePythonEnvVars:\n                # Remove environment variables that can interfere with conda/pixi activation\n                # These are typically set by the parent application (e.g., napari) and can cause\n                # Python to use the wrong interpreter or libraries instead of the isolated environment\n                env = popenKwargs.get(\"env\")\n                vars_to_remove = [\"PYTHONEXECUTABLE\", \"PYTHONHOME\", \"PYTHONPATH\"]\n                # warn if mergedKwargs had an env variable which can cause issues with env activation\n                if env is not None and any(var in vars_to_remove for var in env):\n                    logger.warning(f\"Removing variables {vars_to_remove} from env.\")\n\n                if env is None:\n                    env = os.environ.copy()\n\n                for var in vars_to_remove:\n                    env.pop(var, None)\n                popenKwargs[\"env\"] = env\n\n            defaultPopenKwargs = {\n                \"stdout\": subprocess.PIPE,\n                \"stderr\": subprocess.STDOUT,  # Merge stderr and stdout to handle all them with a single loop\n                \"stdin\": subprocess.DEVNULL,  # Prevent the command to wait for input: instead we want to stop if this happens\n                \"encoding\": \"utf-8\",\n                \"errors\": \"replace\",  # Determines how encoding and decoding errors should be handled: replaces invalid characters with a placeholder (e.g., ? in ASCII).\n                \"bufsize\": 1,  # 1 means line buffered\n            }\n            process = subprocess.Popen(executeFile, **(defaultPopenKwargs | popenKwargs))\n            if wait:\n                process.wait()\n            return process\n\n    def executeCommandsAndGetOutput(\n        self, commands: list[str], exitIfCommandError: bool = True, log: bool = True, popenKwargs: dict[str, Any] = {}\n    ) -&gt; list[str]:\n        \"\"\"Executes commands and captures their output. See [`CommandExecutor.executeCommands`][wetlands._internal.command_executor.CommandExecutor.executeCommands] for more details on the arguments.\n\n        Args:\n                commands: Shell commands to execute.\n                exitIfCommandError: Whether to insert error checking.\n                log: Enable logging of command output.\n                popenKwargs: Keyword arguments for subprocess.Popen().\n\n        Returns:\n                Output lines.\n        \"\"\"\n        rawCommands = commands.copy()\n        process = self.executeCommands(commands, exitIfCommandError, popenKwargs)\n        with process:\n            output = self.getOutput(process, rawCommands, log=log)\n            return output\n\n    def executeCommandAndGetJsonOutput(\n        self, commands: list[str], exitIfCommandError: bool = True, log: bool = True, popenKwargs: dict[str, Any] = {}\n    ) -&gt; list[dict[str, str]]:\n        \"\"\"Execute [`CommandExecutor.executeCommandsAndGetOutput`][wetlands._internal.command_executor.CommandExecutor.executeCommandsAndGetOutput] and parse the json output.\n\n        Returns:\n                Output json.\n        \"\"\"\n        output = self.executeCommandsAndGetOutput(commands, exitIfCommandError, log, popenKwargs)\n        return json.loads(\"\".join(output))\n</code></pre>"},{"location":"reference/wetlands/_internal/command_executor/#wetlands._internal.command_executor.CommandExecutor.__init__","title":"<code>__init__(scriptsPath=None)</code>","text":"<p>scriptsPath: Path where to create temporary script files for command execution (useful for debugging). If None, use the system default temp directory.</p> Source code in <code>wetlands/_internal/command_executor.py</code> <pre><code>def __init__(self, scriptsPath: Path | None = None) -&gt; None:\n    \"\"\"scriptsPath: Path where to create temporary script files for command execution (useful for debugging). If None, use the system default temp directory.\"\"\"\n    self.scriptsPath = scriptsPath\n</code></pre>"},{"location":"reference/wetlands/_internal/command_executor/#wetlands._internal.command_executor.CommandExecutor.killProcess","title":"<code>killProcess(process)</code>  <code>staticmethod</code>","text":"<p>Terminates the process and its children</p> Source code in <code>wetlands/_internal/command_executor.py</code> <pre><code>@staticmethod\ndef killProcess(process) -&gt; None:\n    \"\"\"Terminates the process and its children\"\"\"\n    if process is None:\n        return\n    parent = psutil.Process(process.pid)\n    for child in parent.children(recursive=True):  # Get all child processes\n        if child.is_running():\n            child.kill()\n    if parent.is_running():\n        parent.kill()\n</code></pre>"},{"location":"reference/wetlands/_internal/command_executor/#wetlands._internal.command_executor.CommandExecutor.getOutput","title":"<code>getOutput(process, commands, log=True, strip=True)</code>","text":"<p>Captures and processes output from a subprocess.</p> <p>Parameters:</p> Name Type Description Default <code>process</code> <code>Popen</code> <p>Subprocess to monitor.</p> required <code>commands</code> <code>list[str]</code> <p>Commands that were executed (for error messages).</p> required <code>log</code> <code>bool</code> <p>Whether to log output lines.</p> <code>True</code> <code>strip</code> <code>bool</code> <p>Whether to strip whitespace from output lines.</p> <code>True</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>Output lines.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If CondaSystemExit is detected or non-zero exit code.</p> Source code in <code>wetlands/_internal/command_executor.py</code> <pre><code>def getOutput(\n    self,\n    process: subprocess.Popen,\n    commands: list[str],\n    log: bool = True,\n    strip: bool = True,\n) -&gt; list[str]:\n    \"\"\"Captures and processes output from a subprocess.\n\n    Args:\n            process: Subprocess to monitor.\n            commands: Commands that were executed (for error messages).\n            log: Whether to log output lines.\n            strip: Whether to strip whitespace from output lines.\n\n    Returns:\n            Output lines.\n\n    Raises:\n            Exception: If CondaSystemExit is detected or non-zero exit code.\n    \"\"\"\n    outputs = []\n    if process.stdout is not None:\n        for line in process.stdout:\n            if strip:\n                line = line.strip()\n            if log:\n                logger.info(line)\n            if \"CondaSystemExit\" in line:  # Sometime conda exists with a CondaSystemExit and a return code 0\n                # we want to stop our script when this happens (and not run the later commands)\n                self.killProcess(process)\n                raise Exception(f'The execution of the commands \"{self._commandsExcerpt(commands)}\" failed.')\n            outputs.append(line)\n    process.wait()\n    if process.returncode != 0:\n        raise Exception(f'The execution of the commands \"{self._commandsExcerpt(commands)}\" failed.')\n    return outputs\n</code></pre>"},{"location":"reference/wetlands/_internal/command_executor/#wetlands._internal.command_executor.CommandExecutor.executeCommands","title":"<code>executeCommands(commands, exitIfCommandError=True, popenKwargs={}, wait=False, removePythonEnvVars=True)</code>","text":"<p>Executes shell commands in a subprocess. Warning: does not wait for completion unless <code>wait</code> is True.</p> <p>Parameters:</p> Name Type Description Default <code>commands</code> <code>list[str]</code> <p>List of shell commands to execute.</p> required <code>exitIfCommandError</code> <code>bool</code> <p>Whether to insert error checking after each command to make sure the whole command chain stops if an error occurs (otherwise the script will be executed entirely even when one command fails at the beginning).</p> <code>True</code> <code>popenKwargs</code> <code>dict[str, Any]</code> <p>Keyword arguments for subprocess.Popen() (see Popen documentation). Defaults are: dict(stdout=subprocess.PIPE, stderr=subprocess.STDOUT, stdin=subprocess.DEVNULL, encoding=\"utf-8\", errors=\"replace\", bufsize=1).</p> <code>{}</code> <code>wait</code> <code>bool</code> <p>Whether to wait for the process to complete before returning.</p> <code>False</code> <code>removePythonEnvVars</code> <code>bool</code> <p>Whether to remove PYTHONEXECUTABLE, PYTHONHOME and PYTHONPATH from the environment variables to avoid interference with conda/pixi environment activation.</p> <code>True</code> <p>Returns:</p> Type Description <code>Popen</code> <p>Subprocess handle for the executed commands.</p> Source code in <code>wetlands/_internal/command_executor.py</code> <pre><code>def executeCommands(\n    self,\n    commands: list[str],\n    exitIfCommandError: bool = True,\n    popenKwargs: dict[str, Any] = {},\n    wait: bool = False,\n    removePythonEnvVars: bool = True,\n) -&gt; subprocess.Popen:\n    \"\"\"Executes shell commands in a subprocess. Warning: does not wait for completion unless ``wait`` is True.\n\n    Args:\n            commands: List of shell commands to execute.\n            exitIfCommandError: Whether to insert error checking after each command to make sure the whole command chain stops if an error occurs (otherwise the script will be executed entirely even when one command fails at the beginning).\n            popenKwargs: Keyword arguments for subprocess.Popen() (see [Popen documentation](https://docs.python.org/3/library/subprocess.html#popen-constructor)). Defaults are: dict(stdout=subprocess.PIPE, stderr=subprocess.STDOUT, stdin=subprocess.DEVNULL, encoding=\"utf-8\", errors=\"replace\", bufsize=1).\n            wait: Whether to wait for the process to complete before returning.\n            removePythonEnvVars: Whether to remove PYTHONEXECUTABLE, PYTHONHOME and PYTHONPATH from the environment variables to avoid interference with conda/pixi environment activation.\n\n    Returns:\n            Subprocess handle for the executed commands.\n    \"\"\"\n    import os\n\n    commandsString = \"\\n\\t\\t\".join(commands)\n    logger.debug(f\"Execute commands:\\n\\n\\t\\t{commandsString}\\n\")\n    with tempfile.NamedTemporaryFile(\n        dir=self.scriptsPath, suffix=\".ps1\" if self._isWindows() else \".sh\", mode=\"w\", delete=False\n    ) as tmp:\n        if exitIfCommandError:\n            commands = self._insertCommandErrorChecks(commands)\n        tmp.write(\"\\n\".join(commands))\n        tmp.flush()\n        tmp.close()\n        executeFile = (\n            [\n                \"powershell\",\n                \"-WindowStyle\",\n                \"Hidden\",\n                \"-NoProfile\",\n                \"-ExecutionPolicy\",\n                \"ByPass\",\n                \"-File\",\n                tmp.name,\n            ]\n            if self._isWindows()\n            else [\"/bin/bash\", tmp.name]\n        )\n        if not self._isWindows():\n            subprocess.run([\"chmod\", \"u+x\", tmp.name])\n        logger.debug(f\"Script file: {tmp.name}\")\n\n        if removePythonEnvVars:\n            # Remove environment variables that can interfere with conda/pixi activation\n            # These are typically set by the parent application (e.g., napari) and can cause\n            # Python to use the wrong interpreter or libraries instead of the isolated environment\n            env = popenKwargs.get(\"env\")\n            vars_to_remove = [\"PYTHONEXECUTABLE\", \"PYTHONHOME\", \"PYTHONPATH\"]\n            # warn if mergedKwargs had an env variable which can cause issues with env activation\n            if env is not None and any(var in vars_to_remove for var in env):\n                logger.warning(f\"Removing variables {vars_to_remove} from env.\")\n\n            if env is None:\n                env = os.environ.copy()\n\n            for var in vars_to_remove:\n                env.pop(var, None)\n            popenKwargs[\"env\"] = env\n\n        defaultPopenKwargs = {\n            \"stdout\": subprocess.PIPE,\n            \"stderr\": subprocess.STDOUT,  # Merge stderr and stdout to handle all them with a single loop\n            \"stdin\": subprocess.DEVNULL,  # Prevent the command to wait for input: instead we want to stop if this happens\n            \"encoding\": \"utf-8\",\n            \"errors\": \"replace\",  # Determines how encoding and decoding errors should be handled: replaces invalid characters with a placeholder (e.g., ? in ASCII).\n            \"bufsize\": 1,  # 1 means line buffered\n        }\n        process = subprocess.Popen(executeFile, **(defaultPopenKwargs | popenKwargs))\n        if wait:\n            process.wait()\n        return process\n</code></pre>"},{"location":"reference/wetlands/_internal/command_executor/#wetlands._internal.command_executor.CommandExecutor.executeCommandsAndGetOutput","title":"<code>executeCommandsAndGetOutput(commands, exitIfCommandError=True, log=True, popenKwargs={})</code>","text":"<p>Executes commands and captures their output. See <code>CommandExecutor.executeCommands</code> for more details on the arguments.</p> <p>Parameters:</p> Name Type Description Default <code>commands</code> <code>list[str]</code> <p>Shell commands to execute.</p> required <code>exitIfCommandError</code> <code>bool</code> <p>Whether to insert error checking.</p> <code>True</code> <code>log</code> <code>bool</code> <p>Enable logging of command output.</p> <code>True</code> <code>popenKwargs</code> <code>dict[str, Any]</code> <p>Keyword arguments for subprocess.Popen().</p> <code>{}</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>Output lines.</p> Source code in <code>wetlands/_internal/command_executor.py</code> <pre><code>def executeCommandsAndGetOutput(\n    self, commands: list[str], exitIfCommandError: bool = True, log: bool = True, popenKwargs: dict[str, Any] = {}\n) -&gt; list[str]:\n    \"\"\"Executes commands and captures their output. See [`CommandExecutor.executeCommands`][wetlands._internal.command_executor.CommandExecutor.executeCommands] for more details on the arguments.\n\n    Args:\n            commands: Shell commands to execute.\n            exitIfCommandError: Whether to insert error checking.\n            log: Enable logging of command output.\n            popenKwargs: Keyword arguments for subprocess.Popen().\n\n    Returns:\n            Output lines.\n    \"\"\"\n    rawCommands = commands.copy()\n    process = self.executeCommands(commands, exitIfCommandError, popenKwargs)\n    with process:\n        output = self.getOutput(process, rawCommands, log=log)\n        return output\n</code></pre>"},{"location":"reference/wetlands/_internal/command_executor/#wetlands._internal.command_executor.CommandExecutor.executeCommandAndGetJsonOutput","title":"<code>executeCommandAndGetJsonOutput(commands, exitIfCommandError=True, log=True, popenKwargs={})</code>","text":"<p>Execute <code>CommandExecutor.executeCommandsAndGetOutput</code> and parse the json output.</p> <p>Returns:</p> Type Description <code>list[dict[str, str]]</code> <p>Output json.</p> Source code in <code>wetlands/_internal/command_executor.py</code> <pre><code>def executeCommandAndGetJsonOutput(\n    self, commands: list[str], exitIfCommandError: bool = True, log: bool = True, popenKwargs: dict[str, Any] = {}\n) -&gt; list[dict[str, str]]:\n    \"\"\"Execute [`CommandExecutor.executeCommandsAndGetOutput`][wetlands._internal.command_executor.CommandExecutor.executeCommandsAndGetOutput] and parse the json output.\n\n    Returns:\n            Output json.\n    \"\"\"\n    output = self.executeCommandsAndGetOutput(commands, exitIfCommandError, log, popenKwargs)\n    return json.loads(\"\".join(output))\n</code></pre>"},{"location":"reference/wetlands/_internal/command_generator/","title":"Command generator","text":""},{"location":"reference/wetlands/_internal/command_generator/#wetlands._internal.command_generator.CommandGenerator","title":"<code>CommandGenerator</code>","text":"<p>Generate Conda commands.</p> <p>Methods:</p> Name Description <code>getShellHookCommands</code> <p>Generates shell commands for Conda initialization.</p> <code>createMambaConfigFile</code> <p>Create Mamba config file .mambarc in condaPath, with nodefaults and conda-forge channels.</p> <code>getPlatformCommonName</code> <p>Gets common platform name (mac/linux/windows).</p> <code>getCommandsForCurrentPlatform</code> <p>Selects platform-specific commands from a dictionary.</p> <code>getActivateCondaCommands</code> <p>Generates commands to activate Conda</p> <code>getActivateEnvironmentCommands</code> <p>Generates commands to activate the given environment</p> <code>getAddChannelsCommands</code> <p>Add Conda channels in manifest file when using Pixi (<code>pixi add channelName::packageName</code> is not enough, channelName must be in manifest file).</p> Source code in <code>wetlands/_internal/command_generator.py</code> <pre><code>class CommandGenerator:\n    \"\"\"Generate Conda commands.\"\"\"\n\n    def __init__(self, settingsManager: SettingsManager):\n        self.settingsManager = settingsManager\n\n    def getShellHookCommands(self) -&gt; list[str]:\n        \"\"\"Generates shell commands for Conda initialization.\n\n        Returns:\n                OS-specific commands to activate Conda shell hooks.\n        \"\"\"\n        currentPath = Path.cwd().resolve()\n        condaPath, condaBinPath = self.settingsManager.getCondaPaths()\n        if self.settingsManager.usePixi:\n            if platform.system() == \"Windows\":\n                return [f'$env:PATH = \"{condaPath / condaBinPath.parent};\" + $env:PATH']\n            else:\n                return [f'export PATH=\"{condaPath / condaBinPath.parent}:$PATH\"']\n        if platform.system() == \"Windows\":\n            return [\n                f'Set-Location -Path \"{condaPath}\"',\n                f'$Env:MAMBA_ROOT_PREFIX=\"{condaPath}\"',\n                f\".\\\\{condaBinPath} shell hook -s powershell | Out-String | Invoke-Expression\",\n                f'Set-Location -Path \"{currentPath}\"',\n            ]\n        else:\n            return [\n                f'cd \"{condaPath}\"',\n                f'export MAMBA_ROOT_PREFIX=\"{condaPath}\"',\n                f'eval \"$({condaBinPath} shell hook -s posix)\"',\n                f'cd \"{currentPath}\"',\n            ]\n\n    def createMambaConfigFile(self, condaPath):\n        \"\"\"Create Mamba config file .mambarc in condaPath, with nodefaults and conda-forge channels.\"\"\"\n        if self.settingsManager.usePixi:\n            return\n        with open(condaPath / \".mambarc\", \"w\") as f:\n            mambaSettings = dict(\n                channel_priority=\"flexible\",\n                channels=[\"conda-forge\", \"nodefaults\"],\n                default_channels=[\"conda-forge\"],\n            )\n            yaml.safe_dump(mambaSettings, f)\n\n    def getPlatformCommonName(self) -&gt; str:\n        \"\"\"Gets common platform name (mac/linux/windows).\"\"\"\n        return \"mac\" if platform.system() == \"Darwin\" else platform.system().lower()\n\n    def toCommandsDict(self, commands: Commands) -&gt; CommandsDict:\n        return {\"all\": commands} if isinstance(commands, list) else commands\n\n    def getCommandsForCurrentPlatform(self, additionalCommands: Commands = {}) -&gt; list[str]:\n        \"\"\"Selects platform-specific commands from a dictionary.\n\n        Args:\n                additionalCommands: Dictionary mapping platforms to command lists (e.g. dict(all=[], linux=['wget \"http://something.cool\"']) ).\n\n        Returns:\n                Merged list of commands for 'all' and current platform.\n        \"\"\"\n        commands = []\n        if additionalCommands is None:\n            return commands\n        additionalCommandsDict = self.toCommandsDict(additionalCommands)\n        for name in [\"all\", self.getPlatformCommonName()]:\n            commands += additionalCommandsDict.get(name, [])\n        return commands\n\n    def getActivateCondaCommands(self) -&gt; list[str]:\n        \"\"\"Generates commands to activate Conda\"\"\"\n        # Previouly, this function was also installing Conda if necessary\n        return self.getShellHookCommands()\n\n    def getActivateEnvironmentCommands(\n        self, environment: \"Environment\", additionalActivateCommands: Commands = {}, activateConda: bool = True\n    ) -&gt; list[str]:\n        \"\"\"Generates commands to activate the given environment\n\n        Args:\n                environment: Environment name to launch. If none, the resulting command list will be empty.\n                additionalActivateCommands: Platform-specific activation commands.\n                activateConda: Whether to activate Conda or not.\n\n        Returns:\n                List of commands to activate the environment\n        \"\"\"\n        if environment is None:\n            return []\n        commands = self.getActivateCondaCommands() if activateConda else []\n        if self.settingsManager.usePixi:\n            # Warning: Use `pixi shell-hook` instead of `pixi shell` since `pixi shell` creates a new shell (and we want to keep the same shell)\n            if platform.system() != \"Windows\":\n                commands += [\n                    f'eval \"$({self.settingsManager.condaBin} shell-hook --manifest-path \"{environment.path}\")\"'\n                ]\n            else:\n                commands += [\n                    f'{self.settingsManager.condaBin} shell-hook --manifest-path \"{environment.path}\" | Out-String | Invoke-Expression'\n                ]\n        else:\n            commands += [f\"{self.settingsManager.condaBin} activate {environment.path}\"]\n        return commands + self.getCommandsForCurrentPlatform(additionalActivateCommands)\n\n    def getAddChannelsCommands(\n        self, environment: \"Environment\", channels: list[str], condaDependencies: list[str], activateConda: bool = True\n    ) -&gt; list[str]:\n        \"\"\"Add Conda channels in manifest file when using Pixi (`pixi add channelName::packageName` is not enough, channelName must be in manifest file).\n        The returned command will be something like `pixi project add --manifest-path \"/path/to/pixi.toml\" --prepend channel1 channel2`.\n\n        Args:\n                environment: Environment name.\n                condaChannels: The channels to add.\n                condaDependencies: The conda dependecies to install (e.g. [\"bioimageit::atlas\", \"openjdk\"]).\n                activateConda: Whether to activate conda or not.\n\n        Returns:\n                List of commands to add required channels\n        \"\"\"\n        if not self.settingsManager.usePixi:\n            if len(channels) &gt; 0:\n                return [f\"{self.settingsManager.condaBinConfig} config --add channels \" + \" \".join(channels)]\n            else:\n                return []\n        channels += set([dep.split(\"::\")[0].replace('\"', \"\") for dep in condaDependencies if \"::\" in dep])\n        if len(channels) == 0:\n            return []\n        commands = self.getActivateCondaCommands() if activateConda else []\n        commands += [\n            f'{self.settingsManager.condaBin} project channel add --manifest-path \"{environment.path}\" --no-progress --prepend '\n            + \" \".join(channels)\n        ]\n        return commands\n</code></pre>"},{"location":"reference/wetlands/_internal/command_generator/#wetlands._internal.command_generator.CommandGenerator.getShellHookCommands","title":"<code>getShellHookCommands()</code>","text":"<p>Generates shell commands for Conda initialization.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>OS-specific commands to activate Conda shell hooks.</p> Source code in <code>wetlands/_internal/command_generator.py</code> <pre><code>def getShellHookCommands(self) -&gt; list[str]:\n    \"\"\"Generates shell commands for Conda initialization.\n\n    Returns:\n            OS-specific commands to activate Conda shell hooks.\n    \"\"\"\n    currentPath = Path.cwd().resolve()\n    condaPath, condaBinPath = self.settingsManager.getCondaPaths()\n    if self.settingsManager.usePixi:\n        if platform.system() == \"Windows\":\n            return [f'$env:PATH = \"{condaPath / condaBinPath.parent};\" + $env:PATH']\n        else:\n            return [f'export PATH=\"{condaPath / condaBinPath.parent}:$PATH\"']\n    if platform.system() == \"Windows\":\n        return [\n            f'Set-Location -Path \"{condaPath}\"',\n            f'$Env:MAMBA_ROOT_PREFIX=\"{condaPath}\"',\n            f\".\\\\{condaBinPath} shell hook -s powershell | Out-String | Invoke-Expression\",\n            f'Set-Location -Path \"{currentPath}\"',\n        ]\n    else:\n        return [\n            f'cd \"{condaPath}\"',\n            f'export MAMBA_ROOT_PREFIX=\"{condaPath}\"',\n            f'eval \"$({condaBinPath} shell hook -s posix)\"',\n            f'cd \"{currentPath}\"',\n        ]\n</code></pre>"},{"location":"reference/wetlands/_internal/command_generator/#wetlands._internal.command_generator.CommandGenerator.createMambaConfigFile","title":"<code>createMambaConfigFile(condaPath)</code>","text":"<p>Create Mamba config file .mambarc in condaPath, with nodefaults and conda-forge channels.</p> Source code in <code>wetlands/_internal/command_generator.py</code> <pre><code>def createMambaConfigFile(self, condaPath):\n    \"\"\"Create Mamba config file .mambarc in condaPath, with nodefaults and conda-forge channels.\"\"\"\n    if self.settingsManager.usePixi:\n        return\n    with open(condaPath / \".mambarc\", \"w\") as f:\n        mambaSettings = dict(\n            channel_priority=\"flexible\",\n            channels=[\"conda-forge\", \"nodefaults\"],\n            default_channels=[\"conda-forge\"],\n        )\n        yaml.safe_dump(mambaSettings, f)\n</code></pre>"},{"location":"reference/wetlands/_internal/command_generator/#wetlands._internal.command_generator.CommandGenerator.getPlatformCommonName","title":"<code>getPlatformCommonName()</code>","text":"<p>Gets common platform name (mac/linux/windows).</p> Source code in <code>wetlands/_internal/command_generator.py</code> <pre><code>def getPlatformCommonName(self) -&gt; str:\n    \"\"\"Gets common platform name (mac/linux/windows).\"\"\"\n    return \"mac\" if platform.system() == \"Darwin\" else platform.system().lower()\n</code></pre>"},{"location":"reference/wetlands/_internal/command_generator/#wetlands._internal.command_generator.CommandGenerator.getCommandsForCurrentPlatform","title":"<code>getCommandsForCurrentPlatform(additionalCommands={})</code>","text":"<p>Selects platform-specific commands from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>additionalCommands</code> <code>Commands</code> <p>Dictionary mapping platforms to command lists (e.g. dict(all=[], linux=['wget \"http://something.cool\"']) ).</p> <code>{}</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>Merged list of commands for 'all' and current platform.</p> Source code in <code>wetlands/_internal/command_generator.py</code> <pre><code>def getCommandsForCurrentPlatform(self, additionalCommands: Commands = {}) -&gt; list[str]:\n    \"\"\"Selects platform-specific commands from a dictionary.\n\n    Args:\n            additionalCommands: Dictionary mapping platforms to command lists (e.g. dict(all=[], linux=['wget \"http://something.cool\"']) ).\n\n    Returns:\n            Merged list of commands for 'all' and current platform.\n    \"\"\"\n    commands = []\n    if additionalCommands is None:\n        return commands\n    additionalCommandsDict = self.toCommandsDict(additionalCommands)\n    for name in [\"all\", self.getPlatformCommonName()]:\n        commands += additionalCommandsDict.get(name, [])\n    return commands\n</code></pre>"},{"location":"reference/wetlands/_internal/command_generator/#wetlands._internal.command_generator.CommandGenerator.getActivateCondaCommands","title":"<code>getActivateCondaCommands()</code>","text":"<p>Generates commands to activate Conda</p> Source code in <code>wetlands/_internal/command_generator.py</code> <pre><code>def getActivateCondaCommands(self) -&gt; list[str]:\n    \"\"\"Generates commands to activate Conda\"\"\"\n    # Previouly, this function was also installing Conda if necessary\n    return self.getShellHookCommands()\n</code></pre>"},{"location":"reference/wetlands/_internal/command_generator/#wetlands._internal.command_generator.CommandGenerator.getActivateEnvironmentCommands","title":"<code>getActivateEnvironmentCommands(environment, additionalActivateCommands={}, activateConda=True)</code>","text":"<p>Generates commands to activate the given environment</p> <p>Parameters:</p> Name Type Description Default <code>environment</code> <code>Environment</code> <p>Environment name to launch. If none, the resulting command list will be empty.</p> required <code>additionalActivateCommands</code> <code>Commands</code> <p>Platform-specific activation commands.</p> <code>{}</code> <code>activateConda</code> <code>bool</code> <p>Whether to activate Conda or not.</p> <code>True</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of commands to activate the environment</p> Source code in <code>wetlands/_internal/command_generator.py</code> <pre><code>def getActivateEnvironmentCommands(\n    self, environment: \"Environment\", additionalActivateCommands: Commands = {}, activateConda: bool = True\n) -&gt; list[str]:\n    \"\"\"Generates commands to activate the given environment\n\n    Args:\n            environment: Environment name to launch. If none, the resulting command list will be empty.\n            additionalActivateCommands: Platform-specific activation commands.\n            activateConda: Whether to activate Conda or not.\n\n    Returns:\n            List of commands to activate the environment\n    \"\"\"\n    if environment is None:\n        return []\n    commands = self.getActivateCondaCommands() if activateConda else []\n    if self.settingsManager.usePixi:\n        # Warning: Use `pixi shell-hook` instead of `pixi shell` since `pixi shell` creates a new shell (and we want to keep the same shell)\n        if platform.system() != \"Windows\":\n            commands += [\n                f'eval \"$({self.settingsManager.condaBin} shell-hook --manifest-path \"{environment.path}\")\"'\n            ]\n        else:\n            commands += [\n                f'{self.settingsManager.condaBin} shell-hook --manifest-path \"{environment.path}\" | Out-String | Invoke-Expression'\n            ]\n    else:\n        commands += [f\"{self.settingsManager.condaBin} activate {environment.path}\"]\n    return commands + self.getCommandsForCurrentPlatform(additionalActivateCommands)\n</code></pre>"},{"location":"reference/wetlands/_internal/command_generator/#wetlands._internal.command_generator.CommandGenerator.getAddChannelsCommands","title":"<code>getAddChannelsCommands(environment, channels, condaDependencies, activateConda=True)</code>","text":"<p>Add Conda channels in manifest file when using Pixi (<code>pixi add channelName::packageName</code> is not enough, channelName must be in manifest file). The returned command will be something like <code>pixi project add --manifest-path \"/path/to/pixi.toml\" --prepend channel1 channel2</code>.</p> <p>Parameters:</p> Name Type Description Default <code>environment</code> <code>Environment</code> <p>Environment name.</p> required <code>condaChannels</code> <p>The channels to add.</p> required <code>condaDependencies</code> <code>list[str]</code> <p>The conda dependecies to install (e.g. [\"bioimageit::atlas\", \"openjdk\"]).</p> required <code>activateConda</code> <code>bool</code> <p>Whether to activate conda or not.</p> <code>True</code> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of commands to add required channels</p> Source code in <code>wetlands/_internal/command_generator.py</code> <pre><code>def getAddChannelsCommands(\n    self, environment: \"Environment\", channels: list[str], condaDependencies: list[str], activateConda: bool = True\n) -&gt; list[str]:\n    \"\"\"Add Conda channels in manifest file when using Pixi (`pixi add channelName::packageName` is not enough, channelName must be in manifest file).\n    The returned command will be something like `pixi project add --manifest-path \"/path/to/pixi.toml\" --prepend channel1 channel2`.\n\n    Args:\n            environment: Environment name.\n            condaChannels: The channels to add.\n            condaDependencies: The conda dependecies to install (e.g. [\"bioimageit::atlas\", \"openjdk\"]).\n            activateConda: Whether to activate conda or not.\n\n    Returns:\n            List of commands to add required channels\n    \"\"\"\n    if not self.settingsManager.usePixi:\n        if len(channels) &gt; 0:\n            return [f\"{self.settingsManager.condaBinConfig} config --add channels \" + \" \".join(channels)]\n        else:\n            return []\n    channels += set([dep.split(\"::\")[0].replace('\"', \"\") for dep in condaDependencies if \"::\" in dep])\n    if len(channels) == 0:\n        return []\n    commands = self.getActivateCondaCommands() if activateConda else []\n    commands += [\n        f'{self.settingsManager.condaBin} project channel add --manifest-path \"{environment.path}\" --no-progress --prepend '\n        + \" \".join(channels)\n    ]\n    return commands\n</code></pre>"},{"location":"reference/wetlands/_internal/config_parser/","title":"Config parser","text":"<p>Parser for configuration files (pixi.toml, pyproject.toml, environment.yml).</p>"},{"location":"reference/wetlands/_internal/config_parser/#wetlands._internal.config_parser.ConfigParser","title":"<code>ConfigParser</code>","text":"<p>Parse dependency configurations from various file formats.</p> <p>Methods:</p> Name Description <code>parse</code> <p>Parse configuration file and extract dependencies.</p> <code>detectConfigFileType</code> <p>Detect the type of configuration file.</p> <code>parsePixiToml</code> <p>Parse pixi.toml file and extract dependencies.</p> <code>parsePyprojectToml</code> <p>Parse pyproject.toml file and extract dependencies.</p> <code>parseEnvironmentYml</code> <p>Parse environment.yml file and extract dependencies.</p> <code>parseRequirementsTxt</code> <p>Parse requirements.txt file and extract dependencies.</p> Source code in <code>wetlands/_internal/config_parser.py</code> <pre><code>class ConfigParser:\n    \"\"\"Parse dependency configurations from various file formats.\"\"\"\n\n    def parse(\n        self,\n        config_path: Union[str, Path],\n        environmentName: Optional[str] = None,\n        optionalDependencies: Optional[list[str]] = None,\n    ) -&gt; Dependencies:\n        \"\"\"Parse configuration file and extract dependencies.\n\n        Args:\n            config_path: Path to configuration file (pixi.toml, pyproject.toml, environment.yml, or requirements.txt)\n            environmentName: Environment name to use (for pixi.toml and pyproject.toml)\n            optionalDependencies: Optional dependency groups to include (for pyproject.toml)\n\n        Returns:\n            Dependencies dict with conda, pip, and python keys\n\n        Raises:\n            FileNotFoundError: If config file doesn't exist\n            ValueError: If config format is unsupported or parameters invalid\n            Exception: If file parsing fails\n        \"\"\"\n        config_path = Path(config_path)\n\n        if not config_path.exists():\n            raise FileNotFoundError(f\"Config file not found: {config_path}\")\n\n        file_type = self.detectConfigFileType(config_path)\n\n        if file_type == \"pixi\":\n            return self.parsePixiToml(config_path, environmentName)\n        elif file_type == \"pyproject\":\n            return self.parsePyprojectToml(\n                config_path,\n                environmentName=environmentName,\n                optionalDependencies=optionalDependencies,\n            )\n        elif file_type == \"environment\":\n            return self.parseEnvironmentYml(config_path)\n        elif file_type == \"requirements\":\n            return self.parseRequirementsTxt(config_path)\n        else:\n            raise ValueError(f\"Unsupported config file type: {file_type}\")\n\n    def detectConfigFileType(self, config_path: Union[str, Path]) -&gt; str:\n        \"\"\"Detect the type of configuration file.\n\n        Args:\n            config_path: Path to configuration file\n\n        Returns:\n            \"pixi\", \"pyproject\", \"environment\", or \"requirements\"\n\n        Raises:\n            ValueError: If file type is not supported\n        \"\"\"\n        config_path = Path(config_path)\n        name = config_path.name.lower()\n\n        if name == \"pixi.toml\":\n            return \"pixi\"\n        elif name == \"pyproject.toml\":\n            return \"pyproject\"\n        elif name in [\"environment.yml\", \"environment.yaml\"]:\n            return \"environment\"\n        elif name == \"requirements.txt\":\n            return \"requirements\"\n        else:\n            raise ValueError(\n                f\"Unsupported config file type: {name}. \"\n                \"Expected pixi.toml, pyproject.toml, environment.yml, or requirements.txt\"\n            )\n\n    def parsePixiToml(\n        self,\n        pixi_path: Union[str, Path],\n        environmentName: Optional[str] = None,\n    ) -&gt; Dependencies:\n        \"\"\"Parse pixi.toml file and extract dependencies.\n\n        Args:\n            pixi_path: Path to pixi.toml file\n            environmentName: Name of environment to extract (optional - falls back to default)\n\n        Returns:\n            Dependencies dict\n\n        Raises:\n            FileNotFoundError: If file doesn't exist\n            ValueError: If no valid environment found\n            Exception: If TOML parsing fails\n        \"\"\"\n        pixi_path = Path(pixi_path)\n\n        if not pixi_path.exists():\n            raise FileNotFoundError(f\"pixi.toml not found: {pixi_path}\")\n\n        with open(pixi_path, \"rb\") as f:\n            config = tomllib.load(f)\n\n        # Get environment configuration\n        environments = config.get(\"tool\", {}).get(\"pixi\", {}).get(\"environments\", {})\n\n        # Determine which environment to use\n        env_to_use = environmentName\n        if env_to_use and env_to_use not in environments:\n            # Fall back to default if requested environment doesn't exist\n            env_to_use = \"default\"\n\n        if not env_to_use:\n            # No environmentName provided, use default\n            env_to_use = \"default\"\n\n        if env_to_use not in environments:\n            available = list(environments.keys())\n            raise ValueError(f\"Environment '{env_to_use}' not found in pixi.toml. Available environments: {available}\")\n\n        env_config = environments[env_to_use]\n        features = env_config.get(\"features\", [])\n\n        # Start with base dependencies\n        dependencies: Dependencies = {}\n\n        # Extract python version\n        pixi_config = config.get(\"tool\", {}).get(\"pixi\", {})\n        if \"python\" in pixi_config.get(\"dependencies\", {}):\n            dependencies[\"python\"] = pixi_config[\"dependencies\"][\"python\"]\n\n        # Collect dependencies from features and base\n        conda_deps = []\n        pip_deps = []\n\n        # Base dependencies\n        conda_deps.extend(pixi_config.get(\"dependencies\", {}).keys())\n        pip_deps.extend(pixi_config.get(\"pypi-dependencies\", {}).keys())\n\n        # Feature dependencies\n        features_config = pixi_config.get(\"feature\", {})\n        for feature_name in features:\n            if feature_name in features_config:\n                feature = features_config[feature_name]\n                conda_deps.extend(feature.get(\"dependencies\", {}).keys())\n                pip_deps.extend(feature.get(\"pypi-dependencies\", {}).keys())\n\n        # Remove duplicates and python key if present\n        conda_deps = list(set(d for d in conda_deps if d != \"python\"))\n        pip_deps = list(set(pip_deps))\n\n        if conda_deps:\n            dependencies[\"conda\"] = conda_deps\n        if pip_deps:\n            dependencies[\"pip\"] = pip_deps\n\n        return dependencies\n\n    def parsePyprojectToml(\n        self,\n        pyproject_path: Union[str, Path],\n        environmentName: Optional[str] = None,\n        optionalDependencies: Optional[list[str]] = None,\n    ) -&gt; Dependencies:\n        \"\"\"Parse pyproject.toml file and extract dependencies.\n\n        Args:\n            pyproject_path: Path to pyproject.toml file\n            environmentName: Name of pixi environment to extract\n            optionalDependencies: List of optional dependency groups to include\n\n        Returns:\n            Dependencies dict\n\n        Raises:\n            FileNotFoundError: If file doesn't exist\n            ValueError: If required parameters missing or not found\n            Exception: If TOML parsing fails\n        \"\"\"\n        pyproject_path = Path(pyproject_path)\n\n        if not pyproject_path.exists():\n            raise FileNotFoundError(f\"pyproject.toml not found: {pyproject_path}\")\n\n        with open(pyproject_path, \"rb\") as f:\n            config = tomllib.load(f)\n\n        dependencies: Dependencies = {}\n        pixi_config = config.get(\"tool\", {}).get(\"pixi\", {})\n\n        # If pixi config exists, use it (like pixi.toml)\n        if pixi_config:\n            if environmentName or not optionalDependencies:\n                # Use pixi environment if environmentName provided, or if no optionalDependencies\n                environments = pixi_config.get(\"environments\", {})\n\n                # Determine which environment to use\n                env_to_use = environmentName\n                if env_to_use and env_to_use not in environments:\n                    # Fall back to default if requested environment doesn't exist\n                    env_to_use = \"default\"\n\n                if not env_to_use:\n                    # No environmentName provided, use default\n                    env_to_use = \"default\"\n\n                if env_to_use not in environments:\n                    available = list(environments.keys())\n                    raise ValueError(\n                        f\"Environment '{env_to_use}' not found in pyproject.toml. Available environments: {available}\"\n                    )\n\n                env_config = environments[env_to_use]\n                features = env_config.get(\"features\", [])\n\n                # Extract python version\n                if \"python\" in pixi_config.get(\"dependencies\", {}):\n                    dependencies[\"python\"] = pixi_config[\"dependencies\"][\"python\"]\n\n                # Collect dependencies from features and base\n                conda_deps = []\n                pip_deps = []\n\n                # Base dependencies\n                conda_deps.extend(pixi_config.get(\"dependencies\", {}).keys())\n                pip_deps.extend(pixi_config.get(\"pypi-dependencies\", {}).keys())\n\n                # Feature dependencies\n                features_config = pixi_config.get(\"feature\", {})\n                for feature_name in features:\n                    if feature_name in features_config:\n                        feature = features_config[feature_name]\n                        conda_deps.extend(feature.get(\"dependencies\", {}).keys())\n                        pip_deps.extend(feature.get(\"pypi-dependencies\", {}).keys())\n\n                # Remove duplicates and python key\n                conda_deps = list(set(d for d in conda_deps if d != \"python\"))\n                pip_deps = list(set(pip_deps))\n\n                if conda_deps:\n                    dependencies[\"conda\"] = conda_deps\n                if pip_deps:\n                    dependencies[\"pip\"] = pip_deps\n\n            elif optionalDependencies:\n                # Use pixi features as optional dependencies\n                features_config = pixi_config.get(\"feature\", {})\n                conda_deps = []\n                pip_deps = []\n\n                for feature_name in optionalDependencies:\n                    if feature_name not in features_config:\n                        available = list(features_config.keys())\n                        raise ValueError(\n                            f\"Feature '{feature_name}' not found in pyproject.toml. Available features: {available}\"\n                        )\n\n                    feature = features_config[feature_name]\n                    conda_deps.extend(feature.get(\"dependencies\", {}).keys())\n                    pip_deps.extend(feature.get(\"pypi-dependencies\", {}).keys())\n\n                # Remove duplicates\n                conda_deps = list(set(d for d in conda_deps if d != \"python\"))\n                pip_deps = list(set(pip_deps))\n\n                if conda_deps:\n                    dependencies[\"conda\"] = conda_deps\n                if pip_deps:\n                    dependencies[\"pip\"] = pip_deps\n            else:\n                raise ValueError(\n                    \"For pyproject.toml with pixi config, provide either environmentName or optionalDependencies\"\n                )\n        else:\n            # Standard PEP 621 pyproject.toml (no pixi config)\n            project_config = config.get(\"project\", {})\n\n            # Main dependencies go to pip\n            main_deps = project_config.get(\"dependencies\", [])\n            if main_deps:\n                dependencies[\"pip\"] = main_deps\n\n            # Optional dependencies\n            if optionalDependencies:\n                optional_deps = project_config.get(\"optional-dependencies\", {})\n                pip_deps = dependencies.get(\"pip\", [])\n\n                for group_name in optionalDependencies:\n                    if group_name not in optional_deps:\n                        available = list(optional_deps.keys())\n                        raise ValueError(\n                            f\"Optional dependency group '{group_name}' not found. Available groups: {available}\"\n                        )\n\n                    pip_deps.extend(optional_deps[group_name])\n\n                if pip_deps:\n                    dependencies[\"pip\"] = list(set(pip_deps))\n\n        return dependencies\n\n    def parseEnvironmentYml(\n        self,\n        env_path: Union[str, Path],\n    ) -&gt; Dependencies:\n        \"\"\"Parse environment.yml file and extract dependencies.\n\n        Args:\n            env_path: Path to environment.yml file\n\n        Returns:\n            Dependencies dict with conda and pip keys\n\n        Raises:\n            FileNotFoundError: If file doesn't exist\n            Exception: If YAML parsing fails\n        \"\"\"\n        env_path = Path(env_path)\n\n        if not env_path.exists():\n            raise FileNotFoundError(f\"environment.yml not found: {env_path}\")\n\n        with open(env_path, \"r\") as f:\n            config = yaml.safe_load(f)\n\n        dependencies: Dependencies = {}\n\n        if not config or not isinstance(config, dict):\n            return dependencies\n\n        # Process dependencies list\n        deps_list = config.get(\"dependencies\", [])\n        conda_deps = []\n        pip_deps = []\n\n        for dep in deps_list:\n            if isinstance(dep, str):\n                if dep == \"pip\":\n                    # Skip the 'pip' marker itself\n                    continue\n                else:\n                    # Regular conda dependency\n                    conda_deps.append(dep)\n            elif isinstance(dep, dict):\n                # Nested pip dependencies\n                for key, value in dep.items():\n                    if key == \"pip\" and isinstance(value, list):\n                        pip_deps.extend(value)\n\n        if conda_deps:\n            dependencies[\"conda\"] = conda_deps\n        if pip_deps:\n            dependencies[\"pip\"] = pip_deps\n\n        return dependencies\n\n    def parseRequirementsTxt(\n        self,\n        requirements_path: Union[str, Path],\n    ) -&gt; Dependencies:\n        \"\"\"Parse requirements.txt file and extract dependencies.\n\n        Args:\n            requirements_path: Path to requirements.txt file\n\n        Returns:\n            Dependencies dict with pip key containing all dependencies\n\n        Raises:\n            FileNotFoundError: If file doesn't exist\n            Exception: If file reading fails\n        \"\"\"\n        requirements_path = Path(requirements_path)\n\n        if not requirements_path.exists():\n            raise FileNotFoundError(f\"requirements.txt not found: {requirements_path}\")\n\n        pip_deps = []\n\n        with open(requirements_path, \"r\") as f:\n            for line in f:\n                line = line.strip()\n\n                # Skip empty lines and comments\n                if not line or line.startswith(\"#\"):\n                    continue\n\n                # Skip environment markers (e.g., lines with ; python_version)\n                if \";\" in line:\n                    line = line.split(\";\")[0].strip()\n\n                if line:\n                    pip_deps.append(line)\n\n        dependencies: Dependencies = {}\n        if pip_deps:\n            dependencies[\"pip\"] = pip_deps\n\n        return dependencies\n</code></pre>"},{"location":"reference/wetlands/_internal/config_parser/#wetlands._internal.config_parser.ConfigParser.parse","title":"<code>parse(config_path, environmentName=None, optionalDependencies=None)</code>","text":"<p>Parse configuration file and extract dependencies.</p> <p>Parameters:</p> Name Type Description Default <code>config_path</code> <code>Union[str, Path]</code> <p>Path to configuration file (pixi.toml, pyproject.toml, environment.yml, or requirements.txt)</p> required <code>environmentName</code> <code>Optional[str]</code> <p>Environment name to use (for pixi.toml and pyproject.toml)</p> <code>None</code> <code>optionalDependencies</code> <code>Optional[list[str]]</code> <p>Optional dependency groups to include (for pyproject.toml)</p> <code>None</code> <p>Returns:</p> Type Description <code>Dependencies</code> <p>Dependencies dict with conda, pip, and python keys</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If config file doesn't exist</p> <code>ValueError</code> <p>If config format is unsupported or parameters invalid</p> <code>Exception</code> <p>If file parsing fails</p> Source code in <code>wetlands/_internal/config_parser.py</code> <pre><code>def parse(\n    self,\n    config_path: Union[str, Path],\n    environmentName: Optional[str] = None,\n    optionalDependencies: Optional[list[str]] = None,\n) -&gt; Dependencies:\n    \"\"\"Parse configuration file and extract dependencies.\n\n    Args:\n        config_path: Path to configuration file (pixi.toml, pyproject.toml, environment.yml, or requirements.txt)\n        environmentName: Environment name to use (for pixi.toml and pyproject.toml)\n        optionalDependencies: Optional dependency groups to include (for pyproject.toml)\n\n    Returns:\n        Dependencies dict with conda, pip, and python keys\n\n    Raises:\n        FileNotFoundError: If config file doesn't exist\n        ValueError: If config format is unsupported or parameters invalid\n        Exception: If file parsing fails\n    \"\"\"\n    config_path = Path(config_path)\n\n    if not config_path.exists():\n        raise FileNotFoundError(f\"Config file not found: {config_path}\")\n\n    file_type = self.detectConfigFileType(config_path)\n\n    if file_type == \"pixi\":\n        return self.parsePixiToml(config_path, environmentName)\n    elif file_type == \"pyproject\":\n        return self.parsePyprojectToml(\n            config_path,\n            environmentName=environmentName,\n            optionalDependencies=optionalDependencies,\n        )\n    elif file_type == \"environment\":\n        return self.parseEnvironmentYml(config_path)\n    elif file_type == \"requirements\":\n        return self.parseRequirementsTxt(config_path)\n    else:\n        raise ValueError(f\"Unsupported config file type: {file_type}\")\n</code></pre>"},{"location":"reference/wetlands/_internal/config_parser/#wetlands._internal.config_parser.ConfigParser.detectConfigFileType","title":"<code>detectConfigFileType(config_path)</code>","text":"<p>Detect the type of configuration file.</p> <p>Parameters:</p> Name Type Description Default <code>config_path</code> <code>Union[str, Path]</code> <p>Path to configuration file</p> required <p>Returns:</p> Type Description <code>str</code> <p>\"pixi\", \"pyproject\", \"environment\", or \"requirements\"</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If file type is not supported</p> Source code in <code>wetlands/_internal/config_parser.py</code> <pre><code>def detectConfigFileType(self, config_path: Union[str, Path]) -&gt; str:\n    \"\"\"Detect the type of configuration file.\n\n    Args:\n        config_path: Path to configuration file\n\n    Returns:\n        \"pixi\", \"pyproject\", \"environment\", or \"requirements\"\n\n    Raises:\n        ValueError: If file type is not supported\n    \"\"\"\n    config_path = Path(config_path)\n    name = config_path.name.lower()\n\n    if name == \"pixi.toml\":\n        return \"pixi\"\n    elif name == \"pyproject.toml\":\n        return \"pyproject\"\n    elif name in [\"environment.yml\", \"environment.yaml\"]:\n        return \"environment\"\n    elif name == \"requirements.txt\":\n        return \"requirements\"\n    else:\n        raise ValueError(\n            f\"Unsupported config file type: {name}. \"\n            \"Expected pixi.toml, pyproject.toml, environment.yml, or requirements.txt\"\n        )\n</code></pre>"},{"location":"reference/wetlands/_internal/config_parser/#wetlands._internal.config_parser.ConfigParser.parsePixiToml","title":"<code>parsePixiToml(pixi_path, environmentName=None)</code>","text":"<p>Parse pixi.toml file and extract dependencies.</p> <p>Parameters:</p> Name Type Description Default <code>pixi_path</code> <code>Union[str, Path]</code> <p>Path to pixi.toml file</p> required <code>environmentName</code> <code>Optional[str]</code> <p>Name of environment to extract (optional - falls back to default)</p> <code>None</code> <p>Returns:</p> Type Description <code>Dependencies</code> <p>Dependencies dict</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If file doesn't exist</p> <code>ValueError</code> <p>If no valid environment found</p> <code>Exception</code> <p>If TOML parsing fails</p> Source code in <code>wetlands/_internal/config_parser.py</code> <pre><code>def parsePixiToml(\n    self,\n    pixi_path: Union[str, Path],\n    environmentName: Optional[str] = None,\n) -&gt; Dependencies:\n    \"\"\"Parse pixi.toml file and extract dependencies.\n\n    Args:\n        pixi_path: Path to pixi.toml file\n        environmentName: Name of environment to extract (optional - falls back to default)\n\n    Returns:\n        Dependencies dict\n\n    Raises:\n        FileNotFoundError: If file doesn't exist\n        ValueError: If no valid environment found\n        Exception: If TOML parsing fails\n    \"\"\"\n    pixi_path = Path(pixi_path)\n\n    if not pixi_path.exists():\n        raise FileNotFoundError(f\"pixi.toml not found: {pixi_path}\")\n\n    with open(pixi_path, \"rb\") as f:\n        config = tomllib.load(f)\n\n    # Get environment configuration\n    environments = config.get(\"tool\", {}).get(\"pixi\", {}).get(\"environments\", {})\n\n    # Determine which environment to use\n    env_to_use = environmentName\n    if env_to_use and env_to_use not in environments:\n        # Fall back to default if requested environment doesn't exist\n        env_to_use = \"default\"\n\n    if not env_to_use:\n        # No environmentName provided, use default\n        env_to_use = \"default\"\n\n    if env_to_use not in environments:\n        available = list(environments.keys())\n        raise ValueError(f\"Environment '{env_to_use}' not found in pixi.toml. Available environments: {available}\")\n\n    env_config = environments[env_to_use]\n    features = env_config.get(\"features\", [])\n\n    # Start with base dependencies\n    dependencies: Dependencies = {}\n\n    # Extract python version\n    pixi_config = config.get(\"tool\", {}).get(\"pixi\", {})\n    if \"python\" in pixi_config.get(\"dependencies\", {}):\n        dependencies[\"python\"] = pixi_config[\"dependencies\"][\"python\"]\n\n    # Collect dependencies from features and base\n    conda_deps = []\n    pip_deps = []\n\n    # Base dependencies\n    conda_deps.extend(pixi_config.get(\"dependencies\", {}).keys())\n    pip_deps.extend(pixi_config.get(\"pypi-dependencies\", {}).keys())\n\n    # Feature dependencies\n    features_config = pixi_config.get(\"feature\", {})\n    for feature_name in features:\n        if feature_name in features_config:\n            feature = features_config[feature_name]\n            conda_deps.extend(feature.get(\"dependencies\", {}).keys())\n            pip_deps.extend(feature.get(\"pypi-dependencies\", {}).keys())\n\n    # Remove duplicates and python key if present\n    conda_deps = list(set(d for d in conda_deps if d != \"python\"))\n    pip_deps = list(set(pip_deps))\n\n    if conda_deps:\n        dependencies[\"conda\"] = conda_deps\n    if pip_deps:\n        dependencies[\"pip\"] = pip_deps\n\n    return dependencies\n</code></pre>"},{"location":"reference/wetlands/_internal/config_parser/#wetlands._internal.config_parser.ConfigParser.parsePyprojectToml","title":"<code>parsePyprojectToml(pyproject_path, environmentName=None, optionalDependencies=None)</code>","text":"<p>Parse pyproject.toml file and extract dependencies.</p> <p>Parameters:</p> Name Type Description Default <code>pyproject_path</code> <code>Union[str, Path]</code> <p>Path to pyproject.toml file</p> required <code>environmentName</code> <code>Optional[str]</code> <p>Name of pixi environment to extract</p> <code>None</code> <code>optionalDependencies</code> <code>Optional[list[str]]</code> <p>List of optional dependency groups to include</p> <code>None</code> <p>Returns:</p> Type Description <code>Dependencies</code> <p>Dependencies dict</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If file doesn't exist</p> <code>ValueError</code> <p>If required parameters missing or not found</p> <code>Exception</code> <p>If TOML parsing fails</p> Source code in <code>wetlands/_internal/config_parser.py</code> <pre><code>def parsePyprojectToml(\n    self,\n    pyproject_path: Union[str, Path],\n    environmentName: Optional[str] = None,\n    optionalDependencies: Optional[list[str]] = None,\n) -&gt; Dependencies:\n    \"\"\"Parse pyproject.toml file and extract dependencies.\n\n    Args:\n        pyproject_path: Path to pyproject.toml file\n        environmentName: Name of pixi environment to extract\n        optionalDependencies: List of optional dependency groups to include\n\n    Returns:\n        Dependencies dict\n\n    Raises:\n        FileNotFoundError: If file doesn't exist\n        ValueError: If required parameters missing or not found\n        Exception: If TOML parsing fails\n    \"\"\"\n    pyproject_path = Path(pyproject_path)\n\n    if not pyproject_path.exists():\n        raise FileNotFoundError(f\"pyproject.toml not found: {pyproject_path}\")\n\n    with open(pyproject_path, \"rb\") as f:\n        config = tomllib.load(f)\n\n    dependencies: Dependencies = {}\n    pixi_config = config.get(\"tool\", {}).get(\"pixi\", {})\n\n    # If pixi config exists, use it (like pixi.toml)\n    if pixi_config:\n        if environmentName or not optionalDependencies:\n            # Use pixi environment if environmentName provided, or if no optionalDependencies\n            environments = pixi_config.get(\"environments\", {})\n\n            # Determine which environment to use\n            env_to_use = environmentName\n            if env_to_use and env_to_use not in environments:\n                # Fall back to default if requested environment doesn't exist\n                env_to_use = \"default\"\n\n            if not env_to_use:\n                # No environmentName provided, use default\n                env_to_use = \"default\"\n\n            if env_to_use not in environments:\n                available = list(environments.keys())\n                raise ValueError(\n                    f\"Environment '{env_to_use}' not found in pyproject.toml. Available environments: {available}\"\n                )\n\n            env_config = environments[env_to_use]\n            features = env_config.get(\"features\", [])\n\n            # Extract python version\n            if \"python\" in pixi_config.get(\"dependencies\", {}):\n                dependencies[\"python\"] = pixi_config[\"dependencies\"][\"python\"]\n\n            # Collect dependencies from features and base\n            conda_deps = []\n            pip_deps = []\n\n            # Base dependencies\n            conda_deps.extend(pixi_config.get(\"dependencies\", {}).keys())\n            pip_deps.extend(pixi_config.get(\"pypi-dependencies\", {}).keys())\n\n            # Feature dependencies\n            features_config = pixi_config.get(\"feature\", {})\n            for feature_name in features:\n                if feature_name in features_config:\n                    feature = features_config[feature_name]\n                    conda_deps.extend(feature.get(\"dependencies\", {}).keys())\n                    pip_deps.extend(feature.get(\"pypi-dependencies\", {}).keys())\n\n            # Remove duplicates and python key\n            conda_deps = list(set(d for d in conda_deps if d != \"python\"))\n            pip_deps = list(set(pip_deps))\n\n            if conda_deps:\n                dependencies[\"conda\"] = conda_deps\n            if pip_deps:\n                dependencies[\"pip\"] = pip_deps\n\n        elif optionalDependencies:\n            # Use pixi features as optional dependencies\n            features_config = pixi_config.get(\"feature\", {})\n            conda_deps = []\n            pip_deps = []\n\n            for feature_name in optionalDependencies:\n                if feature_name not in features_config:\n                    available = list(features_config.keys())\n                    raise ValueError(\n                        f\"Feature '{feature_name}' not found in pyproject.toml. Available features: {available}\"\n                    )\n\n                feature = features_config[feature_name]\n                conda_deps.extend(feature.get(\"dependencies\", {}).keys())\n                pip_deps.extend(feature.get(\"pypi-dependencies\", {}).keys())\n\n            # Remove duplicates\n            conda_deps = list(set(d for d in conda_deps if d != \"python\"))\n            pip_deps = list(set(pip_deps))\n\n            if conda_deps:\n                dependencies[\"conda\"] = conda_deps\n            if pip_deps:\n                dependencies[\"pip\"] = pip_deps\n        else:\n            raise ValueError(\n                \"For pyproject.toml with pixi config, provide either environmentName or optionalDependencies\"\n            )\n    else:\n        # Standard PEP 621 pyproject.toml (no pixi config)\n        project_config = config.get(\"project\", {})\n\n        # Main dependencies go to pip\n        main_deps = project_config.get(\"dependencies\", [])\n        if main_deps:\n            dependencies[\"pip\"] = main_deps\n\n        # Optional dependencies\n        if optionalDependencies:\n            optional_deps = project_config.get(\"optional-dependencies\", {})\n            pip_deps = dependencies.get(\"pip\", [])\n\n            for group_name in optionalDependencies:\n                if group_name not in optional_deps:\n                    available = list(optional_deps.keys())\n                    raise ValueError(\n                        f\"Optional dependency group '{group_name}' not found. Available groups: {available}\"\n                    )\n\n                pip_deps.extend(optional_deps[group_name])\n\n            if pip_deps:\n                dependencies[\"pip\"] = list(set(pip_deps))\n\n    return dependencies\n</code></pre>"},{"location":"reference/wetlands/_internal/config_parser/#wetlands._internal.config_parser.ConfigParser.parseEnvironmentYml","title":"<code>parseEnvironmentYml(env_path)</code>","text":"<p>Parse environment.yml file and extract dependencies.</p> <p>Parameters:</p> Name Type Description Default <code>env_path</code> <code>Union[str, Path]</code> <p>Path to environment.yml file</p> required <p>Returns:</p> Type Description <code>Dependencies</code> <p>Dependencies dict with conda and pip keys</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If file doesn't exist</p> <code>Exception</code> <p>If YAML parsing fails</p> Source code in <code>wetlands/_internal/config_parser.py</code> <pre><code>def parseEnvironmentYml(\n    self,\n    env_path: Union[str, Path],\n) -&gt; Dependencies:\n    \"\"\"Parse environment.yml file and extract dependencies.\n\n    Args:\n        env_path: Path to environment.yml file\n\n    Returns:\n        Dependencies dict with conda and pip keys\n\n    Raises:\n        FileNotFoundError: If file doesn't exist\n        Exception: If YAML parsing fails\n    \"\"\"\n    env_path = Path(env_path)\n\n    if not env_path.exists():\n        raise FileNotFoundError(f\"environment.yml not found: {env_path}\")\n\n    with open(env_path, \"r\") as f:\n        config = yaml.safe_load(f)\n\n    dependencies: Dependencies = {}\n\n    if not config or not isinstance(config, dict):\n        return dependencies\n\n    # Process dependencies list\n    deps_list = config.get(\"dependencies\", [])\n    conda_deps = []\n    pip_deps = []\n\n    for dep in deps_list:\n        if isinstance(dep, str):\n            if dep == \"pip\":\n                # Skip the 'pip' marker itself\n                continue\n            else:\n                # Regular conda dependency\n                conda_deps.append(dep)\n        elif isinstance(dep, dict):\n            # Nested pip dependencies\n            for key, value in dep.items():\n                if key == \"pip\" and isinstance(value, list):\n                    pip_deps.extend(value)\n\n    if conda_deps:\n        dependencies[\"conda\"] = conda_deps\n    if pip_deps:\n        dependencies[\"pip\"] = pip_deps\n\n    return dependencies\n</code></pre>"},{"location":"reference/wetlands/_internal/config_parser/#wetlands._internal.config_parser.ConfigParser.parseRequirementsTxt","title":"<code>parseRequirementsTxt(requirements_path)</code>","text":"<p>Parse requirements.txt file and extract dependencies.</p> <p>Parameters:</p> Name Type Description Default <code>requirements_path</code> <code>Union[str, Path]</code> <p>Path to requirements.txt file</p> required <p>Returns:</p> Type Description <code>Dependencies</code> <p>Dependencies dict with pip key containing all dependencies</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If file doesn't exist</p> <code>Exception</code> <p>If file reading fails</p> Source code in <code>wetlands/_internal/config_parser.py</code> <pre><code>def parseRequirementsTxt(\n    self,\n    requirements_path: Union[str, Path],\n) -&gt; Dependencies:\n    \"\"\"Parse requirements.txt file and extract dependencies.\n\n    Args:\n        requirements_path: Path to requirements.txt file\n\n    Returns:\n        Dependencies dict with pip key containing all dependencies\n\n    Raises:\n        FileNotFoundError: If file doesn't exist\n        Exception: If file reading fails\n    \"\"\"\n    requirements_path = Path(requirements_path)\n\n    if not requirements_path.exists():\n        raise FileNotFoundError(f\"requirements.txt not found: {requirements_path}\")\n\n    pip_deps = []\n\n    with open(requirements_path, \"r\") as f:\n        for line in f:\n            line = line.strip()\n\n            # Skip empty lines and comments\n            if not line or line.startswith(\"#\"):\n                continue\n\n            # Skip environment markers (e.g., lines with ; python_version)\n            if \";\" in line:\n                line = line.split(\";\")[0].strip()\n\n            if line:\n                pip_deps.append(line)\n\n    dependencies: Dependencies = {}\n    if pip_deps:\n        dependencies[\"pip\"] = pip_deps\n\n    return dependencies\n</code></pre>"},{"location":"reference/wetlands/_internal/dependency_manager/","title":"Dependency manager","text":""},{"location":"reference/wetlands/_internal/dependency_manager/#wetlands._internal.dependency_manager.DependencyManager","title":"<code>DependencyManager</code>","text":"<p>Manage pip and conda dependencies.</p> <p>Methods:</p> Name Description <code>formatDependencies</code> <p>Formats dependencies for installation with platform checks.</p> <code>getInstallDependenciesCommands</code> <p>Generates commands to install dependencies in the given environment. Note: this does not activate conda, use self.getActivateCondaCommands() first.</p> Source code in <code>wetlands/_internal/dependency_manager.py</code> <pre><code>class DependencyManager:\n    \"\"\"Manage pip and conda dependencies.\"\"\"\n\n    def __init__(self, commandGenerator: CommandGenerator):\n        self.installedPackages: dict[str, dict[str, str]] = {}\n        self.settingsManager = commandGenerator.settingsManager\n        self.commandGenerator = commandGenerator\n\n    def _platformCondaFormat(self) -&gt; str:\n        \"\"\"Get conda-compatible platform string (e.g., 'linux-64', 'osx-arm64', 'win-64').\"\"\"\n        machine = platform.machine()\n        machine = \"64\" if machine == \"x86_64\" or machine == \"AMD64\" else machine\n        system = dict(Darwin=\"osx\", Windows=\"win\", Linux=\"linux\")[platform.system()]\n        return f\"{system}-{machine}\"\n\n    def formatDependencies(\n        self,\n        package_manager: str,\n        dependencies: Dependencies,\n        raiseIncompatibilityError: bool = True,\n        quotes: bool = True,\n    ) -&gt; tuple[list[str], list[str], bool]:\n        \"\"\"Formats dependencies for installation with platform checks.\n\n        Args:\n                package_manager: 'conda' or 'pip'.\n                dependencies: Dependencies to process.\n                raiseIncompatibilityError: Whether to raise on incompatible platforms.\n                quotes: Whether to put dependencies in quotes (required when installing extras on mac, e.g. `pip install \"napari[pyqt5]\"`)\n\n        Returns:\n                Tuple of (dependencies, no-deps dependencies, has_dependencies).\n\n        Raises:\n                IncompatibilityException: For non-optional incompatible dependencies.\n        \"\"\"\n        dependencyList: list[str | Dependency] = dependencies.get(package_manager, [])  # type: ignore\n        finalDependencies: list[str] = []\n        finalDependenciesNoDeps: list[str] = []\n        for dependency in dependencyList:\n            if isinstance(dependency, str):\n                finalDependencies.append(dependency)\n            else:\n                currentPlatform = self._platformCondaFormat()\n                platforms = dependency.get(\"platforms\", \"all\")\n                if (\n                    currentPlatform in platforms\n                    or platforms == \"all\"\n                    or len(platforms) == 0\n                    or not raiseIncompatibilityError\n                ):\n                    if \"dependencies\" not in dependency or dependency[\"dependencies\"]:\n                        finalDependencies.append(dependency[\"name\"])\n                    else:\n                        finalDependenciesNoDeps.append(dependency[\"name\"])\n                elif not dependency.get(\"optional\", False):\n                    platformsString = \", \".join(platforms)\n                    raise IncompatibilityException(\n                        f\"Error: the library {dependency['name']} is not available on this platform ({currentPlatform}). It is only available on the following platforms: {platformsString}.\"\n                    )\n        if quotes:\n            finalDependencies = [f'\"{d}\"' for d in finalDependencies]\n            finalDependenciesNoDeps = [f'\"{d}\"' for d in finalDependenciesNoDeps]\n        return (\n            finalDependencies,\n            finalDependenciesNoDeps,\n            len(finalDependencies) + len(finalDependenciesNoDeps) &gt; 0,\n        )\n\n    def getInstallDependenciesCommands(self, environment: \"Environment\", dependencies: Dependencies) -&gt; list[str]:\n        \"\"\"Generates commands to install dependencies in the given environment. Note: this does not activate conda, use self.getActivateCondaCommands() first.\n\n        Args:\n                environment: Target environment name. If none, no conda environment will be activated, only pip dependencies will be installed in the current python environemnt ; conda dependencies will be ignored.\n                dependencies: Dependencies to install.\n\n        Returns:\n                list of installation commands.\n\n        Raises:\n                Exception: If pip dependencies contain Conda channel syntax.\n        \"\"\"\n        condaDependencies, condaDependenciesNoDeps, hasCondaDependencies = self.formatDependencies(\n            \"conda\", dependencies\n        )\n        pipDependencies, pipDependenciesNoDeps, hasPipDependencies = self.formatDependencies(\"pip\", dependencies)\n\n        if hasCondaDependencies and not environment:\n            raise Exception(\n                \"Conda dependencies can only be installed in a Conda environment. Please provide an existing conda environment to install dependencies.\"\n            )\n        if any(\"::\" in d for d in pipDependencies + pipDependenciesNoDeps):\n            raise Exception(\n                f'One pip dependency has a channel specifier \"::\". Is it a conda dependency?\\n\\n({dependencies.get(\"pip\")})'\n            )\n        installDepsCommands = self.settingsManager.getProxyEnvironmentVariablesCommands()\n\n        installDepsCommands += self.commandGenerator.getActivateCondaCommands()\n\n        if environment:\n            installDepsCommands += self.commandGenerator.getActivateEnvironmentCommands(\n                environment, activateConda=False\n            )\n            installDepsCommands += self.commandGenerator.getAddChannelsCommands(\n                environment, dependencies.get(\"channels\", []), condaDependencies, activateConda=False\n            )\n\n        proxyString = self.settingsManager.getProxyString()\n        proxyArgs = f\"--proxy {proxyString}\" if proxyString is not None else \"\"\n        if self.settingsManager.usePixi:\n            if environment is None:\n                raise Exception(\n                    \"Use micromamba if you want to install a pip dependency without specifying a conda environment.\"\n                )\n            if hasPipDependencies:\n                installDepsCommands += [\n                    f'echo \"Installing pip dependencies...\"',\n                    f'{self.settingsManager.condaBin} add --manifest-path \"{environment.path}\" --pypi {\" \".join(pipDependencies)}',\n                ]\n            if hasCondaDependencies:\n                installDepsCommands += [\n                    f'echo \"Installing conda dependencies...\"',\n                    f'{self.settingsManager.condaBin} add --manifest-path \"{environment.path}\" {\" \".join(condaDependencies)}',\n                ]\n            if len(condaDependenciesNoDeps) &gt; 0:\n                raise Exception(f\"Use micromamba to be able to install conda packages without their dependencies.\")\n            if len(pipDependenciesNoDeps) &gt; 0:\n                installDepsCommands += [\n                    f'echo \"Installing pip dependencies without their dependencies...\"',\n                    f\"pip install {proxyArgs} --no-deps {' '.join(pipDependenciesNoDeps)}\",\n                ]\n            return installDepsCommands\n\n        if len(condaDependencies) &gt; 0:\n            installDepsCommands += [\n                f'echo \"Installing conda dependencies...\"',\n                f\"{self.settingsManager.condaBinConfig} install {' '.join(condaDependencies)} -y\",\n            ]\n        if len(condaDependenciesNoDeps) &gt; 0:\n            installDepsCommands += [\n                f'echo \"Installing conda dependencies without their dependencies...\"',\n                f\"{self.settingsManager.condaBinConfig} install --no-deps {' '.join(condaDependenciesNoDeps)} -y\",\n            ]\n\n        if len(pipDependencies) &gt; 0:\n            installDepsCommands += [\n                f'echo \"Installing pip dependencies...\"',\n                f\"pip install {proxyArgs} {' '.join(pipDependencies)}\",\n            ]\n        if len(pipDependenciesNoDeps) &gt; 0:\n            installDepsCommands += [\n                f'echo \"Installing pip dependencies without their dependencies...\"',\n                f\"pip install {proxyArgs} --no-deps {' '.join(pipDependenciesNoDeps)}\",\n            ]\n        return installDepsCommands\n</code></pre>"},{"location":"reference/wetlands/_internal/dependency_manager/#wetlands._internal.dependency_manager.DependencyManager.formatDependencies","title":"<code>formatDependencies(package_manager, dependencies, raiseIncompatibilityError=True, quotes=True)</code>","text":"<p>Formats dependencies for installation with platform checks.</p> <p>Parameters:</p> Name Type Description Default <code>package_manager</code> <code>str</code> <p>'conda' or 'pip'.</p> required <code>dependencies</code> <code>Dependencies</code> <p>Dependencies to process.</p> required <code>raiseIncompatibilityError</code> <code>bool</code> <p>Whether to raise on incompatible platforms.</p> <code>True</code> <code>quotes</code> <code>bool</code> <p>Whether to put dependencies in quotes (required when installing extras on mac, e.g. <code>pip install \"napari[pyqt5]\"</code>)</p> <code>True</code> <p>Returns:</p> Type Description <code>tuple[list[str], list[str], bool]</code> <p>Tuple of (dependencies, no-deps dependencies, has_dependencies).</p> <p>Raises:</p> Type Description <code>IncompatibilityException</code> <p>For non-optional incompatible dependencies.</p> Source code in <code>wetlands/_internal/dependency_manager.py</code> <pre><code>def formatDependencies(\n    self,\n    package_manager: str,\n    dependencies: Dependencies,\n    raiseIncompatibilityError: bool = True,\n    quotes: bool = True,\n) -&gt; tuple[list[str], list[str], bool]:\n    \"\"\"Formats dependencies for installation with platform checks.\n\n    Args:\n            package_manager: 'conda' or 'pip'.\n            dependencies: Dependencies to process.\n            raiseIncompatibilityError: Whether to raise on incompatible platforms.\n            quotes: Whether to put dependencies in quotes (required when installing extras on mac, e.g. `pip install \"napari[pyqt5]\"`)\n\n    Returns:\n            Tuple of (dependencies, no-deps dependencies, has_dependencies).\n\n    Raises:\n            IncompatibilityException: For non-optional incompatible dependencies.\n    \"\"\"\n    dependencyList: list[str | Dependency] = dependencies.get(package_manager, [])  # type: ignore\n    finalDependencies: list[str] = []\n    finalDependenciesNoDeps: list[str] = []\n    for dependency in dependencyList:\n        if isinstance(dependency, str):\n            finalDependencies.append(dependency)\n        else:\n            currentPlatform = self._platformCondaFormat()\n            platforms = dependency.get(\"platforms\", \"all\")\n            if (\n                currentPlatform in platforms\n                or platforms == \"all\"\n                or len(platforms) == 0\n                or not raiseIncompatibilityError\n            ):\n                if \"dependencies\" not in dependency or dependency[\"dependencies\"]:\n                    finalDependencies.append(dependency[\"name\"])\n                else:\n                    finalDependenciesNoDeps.append(dependency[\"name\"])\n            elif not dependency.get(\"optional\", False):\n                platformsString = \", \".join(platforms)\n                raise IncompatibilityException(\n                    f\"Error: the library {dependency['name']} is not available on this platform ({currentPlatform}). It is only available on the following platforms: {platformsString}.\"\n                )\n    if quotes:\n        finalDependencies = [f'\"{d}\"' for d in finalDependencies]\n        finalDependenciesNoDeps = [f'\"{d}\"' for d in finalDependenciesNoDeps]\n    return (\n        finalDependencies,\n        finalDependenciesNoDeps,\n        len(finalDependencies) + len(finalDependenciesNoDeps) &gt; 0,\n    )\n</code></pre>"},{"location":"reference/wetlands/_internal/dependency_manager/#wetlands._internal.dependency_manager.DependencyManager.getInstallDependenciesCommands","title":"<code>getInstallDependenciesCommands(environment, dependencies)</code>","text":"<p>Generates commands to install dependencies in the given environment. Note: this does not activate conda, use self.getActivateCondaCommands() first.</p> <p>Parameters:</p> Name Type Description Default <code>environment</code> <code>Environment</code> <p>Target environment name. If none, no conda environment will be activated, only pip dependencies will be installed in the current python environemnt ; conda dependencies will be ignored.</p> required <code>dependencies</code> <code>Dependencies</code> <p>Dependencies to install.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>list of installation commands.</p> <p>Raises:</p> Type Description <code>Exception</code> <p>If pip dependencies contain Conda channel syntax.</p> Source code in <code>wetlands/_internal/dependency_manager.py</code> <pre><code>def getInstallDependenciesCommands(self, environment: \"Environment\", dependencies: Dependencies) -&gt; list[str]:\n    \"\"\"Generates commands to install dependencies in the given environment. Note: this does not activate conda, use self.getActivateCondaCommands() first.\n\n    Args:\n            environment: Target environment name. If none, no conda environment will be activated, only pip dependencies will be installed in the current python environemnt ; conda dependencies will be ignored.\n            dependencies: Dependencies to install.\n\n    Returns:\n            list of installation commands.\n\n    Raises:\n            Exception: If pip dependencies contain Conda channel syntax.\n    \"\"\"\n    condaDependencies, condaDependenciesNoDeps, hasCondaDependencies = self.formatDependencies(\n        \"conda\", dependencies\n    )\n    pipDependencies, pipDependenciesNoDeps, hasPipDependencies = self.formatDependencies(\"pip\", dependencies)\n\n    if hasCondaDependencies and not environment:\n        raise Exception(\n            \"Conda dependencies can only be installed in a Conda environment. Please provide an existing conda environment to install dependencies.\"\n        )\n    if any(\"::\" in d for d in pipDependencies + pipDependenciesNoDeps):\n        raise Exception(\n            f'One pip dependency has a channel specifier \"::\". Is it a conda dependency?\\n\\n({dependencies.get(\"pip\")})'\n        )\n    installDepsCommands = self.settingsManager.getProxyEnvironmentVariablesCommands()\n\n    installDepsCommands += self.commandGenerator.getActivateCondaCommands()\n\n    if environment:\n        installDepsCommands += self.commandGenerator.getActivateEnvironmentCommands(\n            environment, activateConda=False\n        )\n        installDepsCommands += self.commandGenerator.getAddChannelsCommands(\n            environment, dependencies.get(\"channels\", []), condaDependencies, activateConda=False\n        )\n\n    proxyString = self.settingsManager.getProxyString()\n    proxyArgs = f\"--proxy {proxyString}\" if proxyString is not None else \"\"\n    if self.settingsManager.usePixi:\n        if environment is None:\n            raise Exception(\n                \"Use micromamba if you want to install a pip dependency without specifying a conda environment.\"\n            )\n        if hasPipDependencies:\n            installDepsCommands += [\n                f'echo \"Installing pip dependencies...\"',\n                f'{self.settingsManager.condaBin} add --manifest-path \"{environment.path}\" --pypi {\" \".join(pipDependencies)}',\n            ]\n        if hasCondaDependencies:\n            installDepsCommands += [\n                f'echo \"Installing conda dependencies...\"',\n                f'{self.settingsManager.condaBin} add --manifest-path \"{environment.path}\" {\" \".join(condaDependencies)}',\n            ]\n        if len(condaDependenciesNoDeps) &gt; 0:\n            raise Exception(f\"Use micromamba to be able to install conda packages without their dependencies.\")\n        if len(pipDependenciesNoDeps) &gt; 0:\n            installDepsCommands += [\n                f'echo \"Installing pip dependencies without their dependencies...\"',\n                f\"pip install {proxyArgs} --no-deps {' '.join(pipDependenciesNoDeps)}\",\n            ]\n        return installDepsCommands\n\n    if len(condaDependencies) &gt; 0:\n        installDepsCommands += [\n            f'echo \"Installing conda dependencies...\"',\n            f\"{self.settingsManager.condaBinConfig} install {' '.join(condaDependencies)} -y\",\n        ]\n    if len(condaDependenciesNoDeps) &gt; 0:\n        installDepsCommands += [\n            f'echo \"Installing conda dependencies without their dependencies...\"',\n            f\"{self.settingsManager.condaBinConfig} install --no-deps {' '.join(condaDependenciesNoDeps)} -y\",\n        ]\n\n    if len(pipDependencies) &gt; 0:\n        installDepsCommands += [\n            f'echo \"Installing pip dependencies...\"',\n            f\"pip install {proxyArgs} {' '.join(pipDependencies)}\",\n        ]\n    if len(pipDependenciesNoDeps) &gt; 0:\n        installDepsCommands += [\n            f'echo \"Installing pip dependencies without their dependencies...\"',\n            f\"pip install {proxyArgs} --no-deps {' '.join(pipDependenciesNoDeps)}\",\n        ]\n    return installDepsCommands\n</code></pre>"},{"location":"reference/wetlands/_internal/exceptions/","title":"Exceptions","text":""},{"location":"reference/wetlands/_internal/exceptions/#wetlands._internal.exceptions.ExecutionException","title":"<code>ExecutionException</code>","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised when the environment raises an error when executing the requested function.</p> <p>Attributes:</p> Name Type Description <code>message</code> <p>explanation of the error</p> Source code in <code>wetlands/_internal/exceptions.py</code> <pre><code>class ExecutionException(Exception):\n    \"\"\"Exception raised when the environment raises an error when executing the requested function.\n\n    Attributes:\n            message: explanation of the error\n    \"\"\"\n\n    def __init__(self, message):\n        super().__init__(message)\n        self.exception = message[\"exception\"] if \"exception\" in message else None\n        self.traceback = message[\"traceback\"] if \"traceback\" in message else None\n</code></pre>"},{"location":"reference/wetlands/_internal/install/","title":"Install","text":"<p>Functions:</p> Name Description <code>downloadFile</code> <p>Downloads a file from a URL to a destination path using urllib.</p> <code>calculateSha256</code> <p>Calculates the SHA256 checksum of a file.</p> <code>verifyChecksum</code> <p>Verifies the SHA256 checksum of a file against an expected value from a file.</p> <code>downloadAndVerify</code> <p>A helper to chain download and verification, with cleanup on failure.</p> <code>getMicromambaPlatformInfo</code> <p>Determines the OS platform and architecture for micromamba URLs.</p> <code>getMicromambaUrl</code> <p>Constructs the micromamba download URL.</p> <code>installVcRedistWindows</code> <p>Downloads, verifies, and silently installs VC Redistributable on Windows.</p> <code>createMambaConfigFile</code> <p>Create Mamba config file .mambarc in condaPath, with nodefaults and conda-forge channels.</p> <code>installMicromamba</code> <p>High-level function to orchestrate Micromamba installation.</p> <code>getPixiTarget</code> <p>Determines the target triple for Pixi downloads.</p> <code>installPixi</code> <p>Downloads, verifies, and installs a specific version of Pixi.</p> <code>main</code> <p>Main function to demonstrate script usage.</p>"},{"location":"reference/wetlands/_internal/install/#wetlands._internal.install.downloadFile","title":"<code>downloadFile(url, destPath, proxies=None)</code>","text":"<p>Downloads a file from a URL to a destination path using urllib.</p> <p>Note: For more complex scenarios, consider using the 'requests' library.</p> Source code in <code>wetlands/_internal/install.py</code> <pre><code>def downloadFile(url: str, destPath: Path, proxies: Optional[Dict[str, str]] = None) -&gt; None:\n    \"\"\"\n    Downloads a file from a URL to a destination path using urllib.\n\n    Note: For more complex scenarios, consider using the 'requests' library.\n    \"\"\"\n    print(f\"Downloading {url} to {destPath}...\")\n    destPath.parent.mkdir(parents=True, exist_ok=True)\n\n    proxyHandler = urllib.request.ProxyHandler(proxies)\n    opener = urllib.request.build_opener(proxyHandler)\n    urllib.request.install_opener(opener)\n\n    try:\n        with urllib.request.urlopen(url, timeout=120) as response, open(destPath, \"wb\") as outFile:\n            shutil.copyfileobj(response, outFile)\n        print(f\"Successfully downloaded {destPath.name}.\")\n    except urllib.error.URLError as e:\n        raise RuntimeError(f\"Failed to download {url}. Reason: {e.reason}\") from e\n</code></pre>"},{"location":"reference/wetlands/_internal/install/#wetlands._internal.install.calculateSha256","title":"<code>calculateSha256(filePath)</code>","text":"<p>Calculates the SHA256 checksum of a file.</p> Source code in <code>wetlands/_internal/install.py</code> <pre><code>def calculateSha256(filePath: Path) -&gt; str:\n    \"\"\"Calculates the SHA256 checksum of a file.\"\"\"\n    sha256Hash = hashlib.sha256()\n    try:\n        with open(filePath, \"rb\") as f:\n            # Read in chunks to handle large files efficiently.\n            for byteBlock in iter(lambda: f.read(4096), b\"\"):\n                sha256Hash.update(byteBlock)\n        return sha256Hash.hexdigest()\n    except FileNotFoundError as e:\n        raise FileNotFoundError(f\"Cannot calculate checksum, file not found: {filePath}\") from e\n</code></pre>"},{"location":"reference/wetlands/_internal/install/#wetlands._internal.install.verifyChecksum","title":"<code>verifyChecksum(filePath, checksumFilePath)</code>","text":"<p>Verifies the SHA256 checksum of a file against an expected value from a file.</p> Source code in <code>wetlands/_internal/install.py</code> <pre><code>def verifyChecksum(filePath: Path, checksumFilePath: Path) -&gt; None:\n    \"\"\"Verifies the SHA256 checksum of a file against an expected value from a file.\"\"\"\n    print(f\"Verifying checksum for {filePath.name} using {checksumFilePath}...\")\n\n    try:\n        with open(checksumFilePath, \"r\") as f:\n            expectedChecksum = f.read().strip().split()[0].lower()\n    except (FileNotFoundError, IndexError) as e:\n        raise ValueError(f\"Could not read expected checksum from {checksumFilePath}\") from e\n\n    actualChecksum = calculateSha256(filePath)\n\n    if actualChecksum == expectedChecksum:\n        print(f\"Checksum OK for {filePath.name}.\")\n    else:\n        raise ValueError(\n            f\"Checksum MISMATCH for {filePath.name}!\\n  Expected: {expectedChecksum}\\n  Actual:   {actualChecksum}\"\n        )\n</code></pre>"},{"location":"reference/wetlands/_internal/install/#wetlands._internal.install.downloadAndVerify","title":"<code>downloadAndVerify(url, downloadPath, checksumPath, proxies)</code>","text":"<p>A helper to chain download and verification, with cleanup on failure.</p> Source code in <code>wetlands/_internal/install.py</code> <pre><code>def downloadAndVerify(url: str, downloadPath: Path, checksumPath: Path, proxies: Optional[Dict[str, str]]) -&gt; None:\n    \"\"\"A helper to chain download and verification, with cleanup on failure.\"\"\"\n    try:\n        downloadFile(url, downloadPath, proxies)\n        verifyChecksum(downloadPath, checksumPath)\n    except (RuntimeError, ValueError) as e:\n        print(f\"Error during download or verification: {e}\", file=sys.stderr)\n        # Clean up partially downloaded file on failure\n        if downloadPath.exists():\n            downloadPath.unlink()\n        raise\n</code></pre>"},{"location":"reference/wetlands/_internal/install/#wetlands._internal.install.getMicromambaPlatformInfo","title":"<code>getMicromambaPlatformInfo()</code>","text":"<p>Determines the OS platform and architecture for micromamba URLs.</p> Source code in <code>wetlands/_internal/install.py</code> <pre><code>def getMicromambaPlatformInfo() -&gt; Tuple[str, str]:\n    \"\"\"Determines the OS platform and architecture for micromamba URLs.\"\"\"\n    system = platform.system()\n    arch = platform.machine().lower()\n\n    systemMap = {\"Linux\": \"linux\", \"Darwin\": \"osx\", \"Windows\": \"win\"}\n    platformOs = systemMap.get(system)\n    if not platformOs:\n        raise ValueError(f\"Unsupported operating system: {system}\")\n\n    archMap = {\n        \"aarch64\": \"aarch64\",\n        \"ppc64le\": \"ppc64le\",\n        \"arm64\": \"arm64\",  # For macOS\n        \"x86_64\": \"64\",\n        \"amd64\": \"64\",\n    }\n    platformArch = archMap.get(arch)\n    if (not platformArch) or (platformOs == \"win\" and platformArch != \"64\"):\n        print(f\"Warning: Detected architecture '{arch}', defaulting to '64'.\")\n        platformArch = \"64\"\n\n    # Validate the final combination\n    validCombinations = {\"linux-aarch64\", \"linux-ppc64le\", \"linux-64\", \"osx-arm64\", \"osx-64\", \"win-64\"}\n    if f\"{platformOs}-{platformArch}\" not in validCombinations:\n        raise ValueError(f\"Unsupported OS-Architecture combination: {platformOs}-{platformArch}\")\n\n    return platformOs, platformArch\n</code></pre>"},{"location":"reference/wetlands/_internal/install/#wetlands._internal.install.getMicromambaUrl","title":"<code>getMicromambaUrl(platformOs, platformArch, version)</code>","text":"<p>Constructs the micromamba download URL.</p> Source code in <code>wetlands/_internal/install.py</code> <pre><code>def getMicromambaUrl(platformOs: str, platformArch: str, version: str) -&gt; Tuple[str, str]:\n    \"\"\"Constructs the micromamba download URL.\"\"\"\n    baseName = f\"micromamba-{platformOs}-{platformArch}\"\n    baseUrl = \"https://github.com/mamba-org/micromamba-releases/releases\"\n\n    if version:\n        return f\"{baseUrl}/download/{version}/{baseName}\", baseName\n    return f\"{baseUrl}/latest/download/{baseName}\", baseName\n</code></pre>"},{"location":"reference/wetlands/_internal/install/#wetlands._internal.install.installVcRedistWindows","title":"<code>installVcRedistWindows(proxies)</code>","text":"<p>Downloads, verifies, and silently installs VC Redistributable on Windows.</p> Source code in <code>wetlands/_internal/install.py</code> <pre><code>def installVcRedistWindows(proxies: Optional[Dict[str, str]]) -&gt; None:\n    \"\"\"Downloads, verifies, and silently installs VC Redistributable on Windows.\"\"\"\n    print(\"\\n--- Starting VC Redistributable Setup ---\")\n\n    with tempfile.TemporaryDirectory() as tmpDir:\n        vcRedistPath = Path(tmpDir) / VC_REDIST_ARTIFACT_NAME\n\n        downloadAndVerify(VC_REDIST_URL_DEFAULT, vcRedistPath, VC_REDIST_CHECKSUM_PATH, proxies)\n\n        print(f\"Installing {VC_REDIST_ARTIFACT_NAME}...\")\n        try:\n            # Prepare the PowerShell command to launch the installer with -Wait\n            ps_command = [\n                \"powershell\",\n                \"-Command\",\n                f\"Start-Process -FilePath '{vcRedistPath}' -ArgumentList '/install','/passive','/norestart' -Wait -NoNewWindow\",\n            ]\n\n            result = subprocess.run(\n                ps_command,\n                check=False,  # We check returncode manually for success codes\n                capture_output=True,\n                text=True,\n            )\n\n            # Successful exit codes for vc_redist are 0 (success) or 3010 (reboot required)\n            if result.returncode in [0, 3010]:\n                print(f\"{VC_REDIST_ARTIFACT_NAME} installation successful. Code: {result.returncode}\")\n            else:\n                raise subprocess.CalledProcessError(result.returncode, result.args, result.stdout, result.stderr)\n        except subprocess.CalledProcessError as e:\n            error_message = (\n                f\"Error: {VC_REDIST_ARTIFACT_NAME} installation failed with code {e.returncode}.\\n\"\n                f\"  Stdout: {e.stdout}\\n\"\n                f\"  Stderr: {e.stderr}\"\n            )\n            raise RuntimeError(error_message) from e\n</code></pre>"},{"location":"reference/wetlands/_internal/install/#wetlands._internal.install.createMambaConfigFile","title":"<code>createMambaConfigFile(mambaPath)</code>","text":"<p>Create Mamba config file .mambarc in condaPath, with nodefaults and conda-forge channels.</p> Source code in <code>wetlands/_internal/install.py</code> <pre><code>def createMambaConfigFile(mambaPath):\n    \"\"\"Create Mamba config file .mambarc in condaPath, with nodefaults and conda-forge channels.\"\"\"\n    with open(mambaPath / \".mambarc\", \"w\") as f:\n        mambaSettings = dict(\n            channel_priority=\"flexible\",\n            channels=[\"conda-forge\", \"nodefaults\"],\n            default_channels=[\"conda-forge\"],\n        )\n        yaml.safe_dump(mambaSettings, f)\n</code></pre>"},{"location":"reference/wetlands/_internal/install/#wetlands._internal.install.installMicromamba","title":"<code>installMicromamba(installPath, version=MICROMAMBA_VERSION, proxies=None)</code>","text":"<p>High-level function to orchestrate Micromamba installation.</p> Source code in <code>wetlands/_internal/install.py</code> <pre><code>def installMicromamba(\n    installPath: Path, version: str = MICROMAMBA_VERSION, proxies: Optional[Dict[str, str]] = None\n) -&gt; Path:\n    \"\"\"High-level function to orchestrate Micromamba installation.\"\"\"\n    currentOs, currentArch = getMicromambaPlatformInfo()\n\n    if currentOs == \"win\":\n        installVcRedistWindows(proxies)\n\n    print(f\"\\n--- Starting Micromamba Setup for {currentOs}-{currentArch} ---\")\n    micromambaUrl, micromambaBaseName = getMicromambaUrl(currentOs, currentArch, version)\n    print(f\"Target Micromamba URL: {micromambaUrl}\")\n\n    suffix = \".exe\" if currentOs == \"win\" else \"\"\n    micromambaFullPath = installPath / \"bin\" / f\"micromamba{suffix}\"\n    micromambaFullPath.parent.mkdir(exist_ok=True, parents=True)\n\n    # Use the combined helper to download and verify\n    downloadAndVerify(micromambaUrl, micromambaFullPath, CHECKSUMS_BASE_DIR / f\"{micromambaBaseName}.sha256\", proxies)\n\n    # Ensure the file is executable and properly named on Windows\n    if currentOs == \"win\":\n        # On Windows, verify the file exists and has the correct extension\n        if not micromambaFullPath.exists():\n            raise Exception(f\"Micromamba executable not found at {micromambaFullPath}\")\n        # Make sure it's readable and not locked\n        try:\n            micromambaFullPath.stat()\n        except Exception as e:\n            raise Exception(f\"Failed to access micromamba executable at {micromambaFullPath}: {e}\") from e\n    else:\n        micromambaFullPath.chmod(0o755)  # rwxr-xr-x\n        print(f\"Made {micromambaFullPath} executable.\")\n\n    print(f\"Micromamba successfully set up at {micromambaFullPath}\")\n\n    createMambaConfigFile(installPath)\n    return micromambaFullPath\n</code></pre>"},{"location":"reference/wetlands/_internal/install/#wetlands._internal.install.getPixiTarget","title":"<code>getPixiTarget(architecture=None)</code>","text":"<p>Determines the target triple for Pixi downloads.</p> Source code in <code>wetlands/_internal/install.py</code> <pre><code>def getPixiTarget(architecture=None) -&gt; str:\n    \"\"\"\n    Determines the target triple for Pixi downloads.\n    \"\"\"\n    platformSystem = platform.system()\n    platformMachine = platform.machine().lower()\n\n    if architecture is None:\n        architecture = \"x86_64\"\n        if platformMachine in (\"aarch64\", \"arm64\"):\n            architecture = \"aarch64\"\n\n    platformName = \"unknown-linux-musl\"\n    archiveExtension = \".tar.gz\"\n    if platformSystem == \"Windows\":\n        platformName = \"pc-windows-msvc\"\n        archiveExtension = \".zip\"\n    elif platformSystem == \"Darwin\":\n        platformName = \"apple-darwin\"\n\n    return f\"pixi-{architecture}-{platformName}{archiveExtension}\"\n</code></pre>"},{"location":"reference/wetlands/_internal/install/#wetlands._internal.install.installPixi","title":"<code>installPixi(installPath, version=PIXI_VERSION, proxies=None)</code>","text":"<p>Downloads, verifies, and installs a specific version of Pixi.</p> Source code in <code>wetlands/_internal/install.py</code> <pre><code>def installPixi(installPath: Path, version: str = PIXI_VERSION, proxies: Optional[Dict[str, str]] = None) -&gt; Path:\n    \"\"\"Downloads, verifies, and installs a specific version of Pixi.\"\"\"\n\n    binaryFilename = getPixiTarget()\n\n    pixiRepoUrl = \"https://github.com/prefix-dev/pixi\"\n\n    if version == \"latest\":\n        downloadUrl = f\"{pixiRepoUrl}/releases/latest/download/{binaryFilename}\"\n    else:\n        downloadUrl = f\"{pixiRepoUrl}/releases/download/{version}/{binaryFilename}\"\n\n    binDir = installPath / \"bin\"\n\n    print(f\"Preparing to install Pixi ({version}, {binaryFilename}).\")\n    print(f\"  URL: {downloadUrl}\")\n    print(f\"  Destination: {binDir}\")\n\n    checksumPath = CHECKSUMS_BASE_DIR / f\"{binaryFilename}.sha256\"\n    if not checksumPath.exists():\n        raise Exception(f\"Error: Checksum file not found at {checksumPath}\")\n\n    try:\n        with tempfile.TemporaryDirectory() as tmpDir:\n            archive_path = Path(tmpDir) / binaryFilename\n            downloadAndVerify(downloadUrl, archive_path, checksumPath, proxies)\n\n            print(f\"Extracting {archive_path.name} to {binDir}...\")\n            binDir.mkdir(parents=True, exist_ok=True)\n\n            if binaryFilename.endswith(\".zip\"):\n                with zipfile.ZipFile(archive_path, \"r\") as zip_ref:\n                    zip_ref.extractall(binDir)\n            else:  # .tar.gz\n                with tarfile.open(archive_path, \"r:gz\") as tar_ref:\n                    if sys.version_info &gt;= (3, 12):\n                        tar_ref.extractall(binDir, filter=\"data\")\n                    else:\n                        # Emulate 'filter=\"data\"' for 3.10\u20133.11\n                        for member in tar_ref.getmembers():\n                            if member.isfile():  # Only extract files, not symlinks/devices/etc\n                                tar_ref.extract(member, path=binDir)\n\n            print(\"Pixi installed successfully.\")\n\n    except (RuntimeError, ValueError, FileNotFoundError) as e:\n        raise Exception(\"Pixi installation failed\") from e\n\n    # Find the actual executable - it may be named 'pixi' or 'pixi.exe' depending on the zip contents\n    # and the platform\n    is_windows = platform.system() == \"Windows\"\n\n    # On Windows, the executable might be named just 'pixi' in the zip, so we need to rename it to 'pixi.exe'\n    # to ensure it can be executed properly\n    pixi_without_ext = binDir / \"pixi\"\n    pixi_with_ext = binDir / \"pixi.exe\"\n\n    if pixi_without_ext.is_file():\n        if is_windows:\n            # Rename to add .exe extension if it doesn't have one\n            if not pixi_with_ext.exists():\n                pixi_without_ext.rename(pixi_with_ext)\n            else:\n                pixi_without_ext.unlink()  # Remove the non-.exe version\n            return pixi_with_ext\n        else:\n            pixi_without_ext.chmod(0o755)  # Make executable on Unix-like systems\n            return pixi_without_ext\n\n    if pixi_with_ext.is_file():\n        return pixi_with_ext\n\n    raise Exception(f\"Pixi executable not found. Checked locations: {pixi_without_ext}, {pixi_with_ext}\")\n</code></pre>"},{"location":"reference/wetlands/_internal/install/#wetlands._internal.install.main","title":"<code>main()</code>","text":"<p>Main function to demonstrate script usage.</p> Source code in <code>wetlands/_internal/install.py</code> <pre><code>def main():\n    \"\"\"\n    Main function to demonstrate script usage.\n    \"\"\"\n    # Example: Install Micromamba\n    micromambaInstallDir = SCRIPT_DIR / \"micromamba_install\"\n    print(f\"--- Example: Installing Micromamba to {micromambaInstallDir} ---\")\n    try:\n        installMicromamba(micromambaInstallDir)\n    except (RuntimeError, ValueError, FileNotFoundError) as e:\n        print(f\"\\nFATAL ERROR during Micromamba setup: {e}\", file=sys.stderr)\n        sys.exit(1)\n\n    print(\"\\n\" + \"=\" * 50 + \"\\n\")\n\n    # Example: Install Pixi\n    pixiInstallDir = SCRIPT_DIR / \"pixi_install\"\n    print(f\"--- Example: Installing Pixi to {pixiInstallDir} ---\")\n    try:\n        installPixi(pixiInstallDir, version=\"0.21.0\")  # Use a specific version\n    except (RuntimeError, ValueError, FileNotFoundError) as e:\n        print(f\"\\nFATAL ERROR during Pixi setup: {e}\", file=sys.stderr)\n        sys.exit(1)\n</code></pre>"},{"location":"reference/wetlands/_internal/module_executor/","title":"Module executor","text":"<p>This script launches a server inside a specified conda environment. It listens on a dynamically assigned local port for incoming execution commands sent via a multiprocessing connection.</p> <p>Clients can send instructions to: - Dynamically import a Python module from a specified path and execute a function - Run a Python script via runpy.run_path() - Receive the result or any errors from the execution</p> <p>Designed to be run within isolated environments for sandboxed execution of Python code modules.</p> <p>Functions:</p> Name Description <code>sendMessage</code> <p>Thread-safe sending of messages.</p> <code>handleExecutionError</code> <p>Common error handling for any execution type.</p> <code>executeFunction</code> <p>Import a module and execute one of its functions.</p> <code>runScript</code> <p>Run a Python script via runpy.run_path(), simulating 'python script.py args...'.</p> <code>executionWorker</code> <p>Worker function handling both 'execute' and 'run' actions.</p> <code>launchListener</code> <p>Launches a listener on a random available port on localhost.</p>"},{"location":"reference/wetlands/_internal/module_executor/#wetlands._internal.module_executor.sendMessage","title":"<code>sendMessage(lock, connection, message)</code>","text":"<p>Thread-safe sending of messages.</p> Source code in <code>wetlands/_internal/module_executor.py</code> <pre><code>def sendMessage(lock: threading.Lock, connection: Connection, message: dict):\n    \"\"\"Thread-safe sending of messages.\"\"\"\n    with lock:\n        connection.send(message)\n</code></pre>"},{"location":"reference/wetlands/_internal/module_executor/#wetlands._internal.module_executor.handleExecutionError","title":"<code>handleExecutionError(lock, connection, e)</code>","text":"<p>Common error handling for any execution type.</p> Source code in <code>wetlands/_internal/module_executor.py</code> <pre><code>def handleExecutionError(lock: threading.Lock, connection: Connection, e: Exception):\n    \"\"\"Common error handling for any execution type.\"\"\"\n    logger.error(str(e))\n    logger.error(\"Traceback:\")\n    tbftb = traceback.format_tb(e.__traceback__)\n    for line in tbftb:\n        logger.error(line)\n    sys.stderr.flush()\n    sendMessage(\n        lock,\n        connection,\n        dict(\n            action=\"error\",\n            exception=str(e),\n            traceback=tbftb,\n        ),\n    )\n    logger.debug(\"Error sent\")\n</code></pre>"},{"location":"reference/wetlands/_internal/module_executor/#wetlands._internal.module_executor.executeFunction","title":"<code>executeFunction(message)</code>","text":"<p>Import a module and execute one of its functions.</p> Source code in <code>wetlands/_internal/module_executor.py</code> <pre><code>def executeFunction(message: dict):\n    \"\"\"Import a module and execute one of its functions.\"\"\"\n    modulePath = Path(message[\"modulePath\"])\n    logger.debug(f\"Import module {modulePath}\")\n    sys.path.append(str(modulePath.parent))\n    module = import_module(modulePath.stem)\n    if not hasattr(module, message[\"function\"]):\n        raise Exception(f\"Module {modulePath} has no function {message['function']}.\")\n    args = message.get(\"args\", [])\n    kwargs = message.get(\"kwargs\", {})\n    logger.info(f\"Execute {message['modulePath']}:{message['function']}({args})\")\n    try:\n        result = getattr(module, message[\"function\"])(*args, **kwargs)\n    except SystemExit as se:\n        raise Exception(f\"Function raised SystemExit: {se}\\n\\n\")\n    logger.info(\"Executed\")\n    return result\n</code></pre>"},{"location":"reference/wetlands/_internal/module_executor/#wetlands._internal.module_executor.runScript","title":"<code>runScript(message)</code>","text":"<p>Run a Python script via runpy.run_path(), simulating 'python script.py args...'.</p> Source code in <code>wetlands/_internal/module_executor.py</code> <pre><code>def runScript(message: dict):\n    \"\"\"Run a Python script via runpy.run_path(), simulating 'python script.py args...'.\"\"\"\n    scriptPath = message[\"scriptPath\"]\n    args = message.get(\"args\", [])\n    run_name = message.get(\"run_name\", \"__main__\")\n\n    sys.argv = [scriptPath] + list(args)\n    logger.info(f\"Running script {scriptPath} with args {args} and run_name={run_name}\")\n    runpy.run_path(scriptPath, run_name=run_name)\n    logger.info(\"Script executed\")\n    return None\n</code></pre>"},{"location":"reference/wetlands/_internal/module_executor/#wetlands._internal.module_executor.executionWorker","title":"<code>executionWorker(lock, connection, message)</code>","text":"<p>Worker function handling both 'execute' and 'run' actions.</p> Source code in <code>wetlands/_internal/module_executor.py</code> <pre><code>def executionWorker(lock: threading.Lock, connection: Connection, message: dict):\n    \"\"\"\n    Worker function handling both 'execute' and 'run' actions.\n    \"\"\"\n    try:\n        action = message[\"action\"]\n        if action == \"execute\":\n            result = executeFunction(message)\n        elif action == \"run\":\n            result = runScript(message)\n        else:\n            raise Exception(f\"Unknown action: {action}\")\n\n        sendMessage(\n            lock,\n            connection,\n            dict(\n                action=\"execution finished\",\n                message=f\"{action} completed\",\n                result=result,\n            ),\n        )\n    except Exception as e:\n        handleExecutionError(lock, connection, e)\n</code></pre>"},{"location":"reference/wetlands/_internal/module_executor/#wetlands._internal.module_executor.launchListener","title":"<code>launchListener()</code>","text":"<p>Launches a listener on a random available port on localhost. Waits for client connections and handles 'execute', 'run', or 'exit' messages.</p> Source code in <code>wetlands/_internal/module_executor.py</code> <pre><code>def launchListener():\n    \"\"\"\n    Launches a listener on a random available port on localhost.\n    Waits for client connections and handles 'execute', 'run', or 'exit' messages.\n    \"\"\"\n    lock = threading.Lock()\n    with Listener((\"localhost\", port)) as listener:\n        while True:\n            print(f\"Listening port {listener.address[1]}\")\n            with listener.accept() as connection:\n                logger.debug(f\"Connection accepted {listener.address}\")\n                message = \"\"\n                try:\n                    while message := getMessage(connection):\n                        logger.debug(f\"Got message: {message}\")\n\n                        if message[\"action\"] in (\"execute\", \"run\"):\n                            logger.debug(f\"Launch thread for action {message['action']}\")\n                            thread = threading.Thread(\n                                target=executionWorker,\n                                args=(lock, connection, message),\n                            )\n                            thread.start()\n\n                        elif message[\"action\"] == \"exit\":\n                            logger.info(\"exit\")\n                            sendMessage(lock, connection, dict(action=\"exited\"))\n                            listener.close()\n                            return\n                except Exception as e:\n                    handleExecutionError(lock, connection, e)\n</code></pre>"},{"location":"reference/wetlands/_internal/settings_manager/","title":"Settings manager","text":""},{"location":"reference/wetlands/_internal/settings_manager/#wetlands._internal.settings_manager.SettingsManager","title":"<code>SettingsManager</code>","text":"<p>Methods:</p> Name Description <code>setCondaPath</code> <p>Updates the micromamba path and loads proxy settings if exists.</p> <code>setProxies</code> <p>Configures proxy settings for Conda operations (see Using Anaconda behind a company proxy).</p> <code>getCondaPaths</code> <p>Gets micromamba root path and binary path.</p> <code>getProxyEnvironmentVariablesCommands</code> <p>Generates proxy environment variable commands.</p> <code>getProxyString</code> <p>Gets active proxy string from configuration (HTTPS preferred, fallback to HTTP).</p> Source code in <code>wetlands/_internal/settings_manager.py</code> <pre><code>class SettingsManager:\n    usePixi = True\n    condaBin = \"pixi\"  # \"micromamba\"\n    condaBinConfig = \"pixi --manifest-path .pixi/project.toml\"  # \"micromamba --rc-file ~/.mambarc\"\n    proxies: dict[str, str] | None = None\n\n    def __init__(self, condaPath: str | Path = Path(\"pixi\"), usePixi=True) -&gt; None:\n        self.setCondaPath(condaPath, usePixi)\n\n    def setCondaPath(self, condaPath: str | Path, usePixi=True) -&gt; None:\n        \"\"\"Updates the micromamba path and loads proxy settings if exists.\n\n        Args:\n                condaPath: New path to micromamba binary.\n\n        Side Effects:\n                Updates condaBinConfig and proxies from the .mambarc file.\n        \"\"\"\n        self.usePixi = usePixi\n        self.condaBin = (\n            \"pixi.exe\" if platform.system() == \"Windows\" and usePixi else \"pixi\" if usePixi else \"micromamba\"\n        )\n        self.condaPath = Path(condaPath).resolve()\n        # condaBinConfig is only used with micromamba but let's initialize it for pixi as well\n        condaConfigPath = self.condaPath / \"pixi.toml\" if self.usePixi else self.condaPath / \".mambarc\"\n        self.condaBinConfig = (\n            f'{self.condaBin} --manifest-path \"{condaConfigPath}\"'\n            if self.usePixi\n            else f'{self.condaBin} --rc-file \"{condaConfigPath}\"'\n        )\n\n        if self.usePixi:\n            return\n        import yaml\n\n        if condaConfigPath.exists():\n            with open(condaConfigPath, \"r\") as f:\n                condaConfig = yaml.safe_load(f)\n                if condaConfig is not None and \"proxies\" in condaConfig:\n                    self.proxies = condaConfig[\"proxies\"]\n\n    def setProxies(self, proxies: dict[str, str]) -&gt; None:\n        \"\"\"Configures proxy settings for Conda operations (see [Using Anaconda behind a company proxy](https://www.anaconda.com/docs/tools/working-with-conda/reference/proxy)).\n\n        Args:\n                proxies: Proxy configuration dictionary (e.g., {'http': 'http://username:password@corp.com:8080', 'https': 'https://username:password@corp.com:8080'}).\n\n        Side Effects:\n                Updates .mambarc configuration file with proxy settings.\n        \"\"\"\n        self.proxies = proxies\n        if self.usePixi:\n            return\n        condaConfigPath = self.condaPath / \".mambarc\"\n        condaConfig = dict()\n        import yaml\n\n        if condaConfigPath.exists():\n            with open(condaConfigPath, \"r\") as f:\n                condaConfig = yaml.safe_load(f)\n            if proxies:\n                condaConfig[\"proxy_servers\"] = proxies\n            else:\n                del condaConfig[\"proxy_servers\"]\n            with open(condaConfigPath, \"w\") as f:\n                yaml.safe_dump(condaConfig, f)\n\n    def getCondaPaths(self) -&gt; tuple[Path, Path]:\n        \"\"\"Gets micromamba root path and binary path.\n\n        Returns:\n                Tuple of (conda directory path, binary relative path).\n        \"\"\"\n        condaName = \"pixi\" if self.usePixi else \"micromamba\"\n        suffix = \".exe\" if platform.system() == \"Windows\" else \"\"\n        condaBinPath = f\"bin/{condaName}{suffix}\"\n        return self.condaPath.resolve(), Path(condaBinPath)\n\n    def getEnvironmentPathFromName(self, environmentName: str) -&gt; Path:\n        return (\n            self.condaPath / \"workspaces\" / environmentName / \"pixi.toml\"\n            if self.usePixi\n            else self.condaPath / \"envs\" / environmentName\n        )\n\n    def getProxyEnvironmentVariablesCommands(self) -&gt; list[str]:\n        \"\"\"Generates proxy environment variable commands.\n\n        Returns:\n                List of OS-specific proxy export commands.\n        \"\"\"\n        if self.proxies is None:\n            return []\n        return [\n            f'export {name.lower()}_proxy=\"{value}\"'\n            if platform.system() != \"Windows\"\n            else f'$Env:{name.upper()}_PROXY=\"{value}\"'\n            for name, value in self.proxies.items()\n        ]\n\n    def getProxyString(self) -&gt; str | None:\n        \"\"\"Gets active proxy string from configuration (HTTPS preferred, fallback to HTTP).\"\"\"\n        if self.proxies is None:\n            return None\n        return self.proxies.get(\"https\", self.proxies.get(\"http\", None))\n</code></pre>"},{"location":"reference/wetlands/_internal/settings_manager/#wetlands._internal.settings_manager.SettingsManager.setCondaPath","title":"<code>setCondaPath(condaPath, usePixi=True)</code>","text":"<p>Updates the micromamba path and loads proxy settings if exists.</p> <p>Parameters:</p> Name Type Description Default <code>condaPath</code> <code>str | Path</code> <p>New path to micromamba binary.</p> required Side Effects <p>Updates condaBinConfig and proxies from the .mambarc file.</p> Source code in <code>wetlands/_internal/settings_manager.py</code> <pre><code>def setCondaPath(self, condaPath: str | Path, usePixi=True) -&gt; None:\n    \"\"\"Updates the micromamba path and loads proxy settings if exists.\n\n    Args:\n            condaPath: New path to micromamba binary.\n\n    Side Effects:\n            Updates condaBinConfig and proxies from the .mambarc file.\n    \"\"\"\n    self.usePixi = usePixi\n    self.condaBin = (\n        \"pixi.exe\" if platform.system() == \"Windows\" and usePixi else \"pixi\" if usePixi else \"micromamba\"\n    )\n    self.condaPath = Path(condaPath).resolve()\n    # condaBinConfig is only used with micromamba but let's initialize it for pixi as well\n    condaConfigPath = self.condaPath / \"pixi.toml\" if self.usePixi else self.condaPath / \".mambarc\"\n    self.condaBinConfig = (\n        f'{self.condaBin} --manifest-path \"{condaConfigPath}\"'\n        if self.usePixi\n        else f'{self.condaBin} --rc-file \"{condaConfigPath}\"'\n    )\n\n    if self.usePixi:\n        return\n    import yaml\n\n    if condaConfigPath.exists():\n        with open(condaConfigPath, \"r\") as f:\n            condaConfig = yaml.safe_load(f)\n            if condaConfig is not None and \"proxies\" in condaConfig:\n                self.proxies = condaConfig[\"proxies\"]\n</code></pre>"},{"location":"reference/wetlands/_internal/settings_manager/#wetlands._internal.settings_manager.SettingsManager.setProxies","title":"<code>setProxies(proxies)</code>","text":"<p>Configures proxy settings for Conda operations (see Using Anaconda behind a company proxy).</p> <p>Parameters:</p> Name Type Description Default <code>proxies</code> <code>dict[str, str]</code> <p>Proxy configuration dictionary (e.g., {'http': 'http://username:password@corp.com:8080', 'https': 'https://username:password@corp.com:8080'}).</p> required Side Effects <p>Updates .mambarc configuration file with proxy settings.</p> Source code in <code>wetlands/_internal/settings_manager.py</code> <pre><code>def setProxies(self, proxies: dict[str, str]) -&gt; None:\n    \"\"\"Configures proxy settings for Conda operations (see [Using Anaconda behind a company proxy](https://www.anaconda.com/docs/tools/working-with-conda/reference/proxy)).\n\n    Args:\n            proxies: Proxy configuration dictionary (e.g., {'http': 'http://username:password@corp.com:8080', 'https': 'https://username:password@corp.com:8080'}).\n\n    Side Effects:\n            Updates .mambarc configuration file with proxy settings.\n    \"\"\"\n    self.proxies = proxies\n    if self.usePixi:\n        return\n    condaConfigPath = self.condaPath / \".mambarc\"\n    condaConfig = dict()\n    import yaml\n\n    if condaConfigPath.exists():\n        with open(condaConfigPath, \"r\") as f:\n            condaConfig = yaml.safe_load(f)\n        if proxies:\n            condaConfig[\"proxy_servers\"] = proxies\n        else:\n            del condaConfig[\"proxy_servers\"]\n        with open(condaConfigPath, \"w\") as f:\n            yaml.safe_dump(condaConfig, f)\n</code></pre>"},{"location":"reference/wetlands/_internal/settings_manager/#wetlands._internal.settings_manager.SettingsManager.getCondaPaths","title":"<code>getCondaPaths()</code>","text":"<p>Gets micromamba root path and binary path.</p> <p>Returns:</p> Type Description <code>tuple[Path, Path]</code> <p>Tuple of (conda directory path, binary relative path).</p> Source code in <code>wetlands/_internal/settings_manager.py</code> <pre><code>def getCondaPaths(self) -&gt; tuple[Path, Path]:\n    \"\"\"Gets micromamba root path and binary path.\n\n    Returns:\n            Tuple of (conda directory path, binary relative path).\n    \"\"\"\n    condaName = \"pixi\" if self.usePixi else \"micromamba\"\n    suffix = \".exe\" if platform.system() == \"Windows\" else \"\"\n    condaBinPath = f\"bin/{condaName}{suffix}\"\n    return self.condaPath.resolve(), Path(condaBinPath)\n</code></pre>"},{"location":"reference/wetlands/_internal/settings_manager/#wetlands._internal.settings_manager.SettingsManager.getProxyEnvironmentVariablesCommands","title":"<code>getProxyEnvironmentVariablesCommands()</code>","text":"<p>Generates proxy environment variable commands.</p> <p>Returns:</p> Type Description <code>list[str]</code> <p>List of OS-specific proxy export commands.</p> Source code in <code>wetlands/_internal/settings_manager.py</code> <pre><code>def getProxyEnvironmentVariablesCommands(self) -&gt; list[str]:\n    \"\"\"Generates proxy environment variable commands.\n\n    Returns:\n            List of OS-specific proxy export commands.\n    \"\"\"\n    if self.proxies is None:\n        return []\n    return [\n        f'export {name.lower()}_proxy=\"{value}\"'\n        if platform.system() != \"Windows\"\n        else f'$Env:{name.upper()}_PROXY=\"{value}\"'\n        for name, value in self.proxies.items()\n    ]\n</code></pre>"},{"location":"reference/wetlands/_internal/settings_manager/#wetlands._internal.settings_manager.SettingsManager.getProxyString","title":"<code>getProxyString()</code>","text":"<p>Gets active proxy string from configuration (HTTPS preferred, fallback to HTTP).</p> Source code in <code>wetlands/_internal/settings_manager.py</code> <pre><code>def getProxyString(self) -&gt; str | None:\n    \"\"\"Gets active proxy string from configuration (HTTPS preferred, fallback to HTTP).\"\"\"\n    if self.proxies is None:\n        return None\n    return self.proxies.get(\"https\", self.proxies.get(\"http\", None))\n</code></pre>"}]}